{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Practicalli ClojureScript","text":"<p>ClojureScript is an implementation of the Clojure functional programming language for JavaScript platforms, web browser JavaScript engines and  server-side node.js.</p> <p>Discover the joy of ClojureScript for building single page applications, complex UI's, lightweight services and server side web applications.  Design approaches common to ClojureScript &amp; React will be covered along the way.</p> <p>Projects covered here focus on the Figwheel-main development tool, the reagent library for react.js style applications, hiccup syntax for html content and ClojureScript code.</p> <p>JavaScript npm packages can be used with Figwheel-main, however, this guide focuses on ClojureScript where ever possible</p> <p></p>"},{"location":"#example-websites","title":"Example websites","text":"<p> Practicalli Landing page  ClojureBridgeLondon</p>"},{"location":"#requirements","title":"Requirements","text":"<p>Practicalli Clojure install instructions to set up a Clojure environment.  ClojureScript tools depend on Clojure and Java, although there are self-hosted environments.</p> <p>A Clojure aware editor is highly recommend along with web browser development tools to provide even greater feedback from the running application.</p> Need tight integration with npm? <p> shadow-cljs is built with node.js and NPM and so has deep integration with JavaScript packages, an advantage if a project benefits from significant use of node.js packages.</p> <p>Follow the shadow-cljs documentation carefully and in detail for a smooth experience.  Ensure the project runs on the command line first, before trying to run the project from an editor.  Also check the documentation for specific configuration to ensure your chosen editor will work correctly with shadow-cljs</p> <p>Content being refreshed</p> <p>, especially around shadow-cljs which is not yet covered.</p> <p>The most relevant content includes the TicTacToe game with ClojureScript, Reagent and Scalable Vector Graphics, the Practicalli ClojureScript YouTube playlist and building ClojureScript websites.</p>"},{"location":"#additional-resources","title":"Additional Resources","text":"<p>Learning ClojureScript</p> <ul> <li>ClojureScript Unraveled</li> <li>ClojureScript Koans</li> <li>Reagent Cookbook</li> </ul> <p>Tooling</p> <ul> <li>figwheel-main - instant feedback for ClojureScript development</li> <li>figwheel-main project template - quickly create a figwheel-main based ClojureScript project</li> </ul> <p>Community</p> <ul> <li>Cljs js - javascript foreigner libraries for ClojureScript</li> </ul> <p>Commercial courses</p> <ul> <li>Jacek Schae - Reagent, Reframe, Reitit</li> </ul>"},{"location":"#creative-commons-license","title":"Creative commons license","text":"This work is licensed under a Creative Commons Attribution 4.0 ShareAlike License (including images &amp; stylesheets)."},{"location":"browser-devtools/","title":"Browser DevTools","text":""},{"location":"twilight-zone/","title":"Twilight zone","text":"<p>You unlock this door with the key of imagination, beyond it is another dimention a dimension of sound (sound design of a language) a dimension of sight (the repl lets you see clearly what is going on in your code) a dimention of mind (thinking functionally, thinking about pure functions and immutablility, thinking about data)</p> <p>Your moving into a land of both shadow and substance (javascript &amp; Clojurescript) of things and ideas (data structures and functions)</p> <p>you just crossed over to the Clojurescript Zone...</p> <p>The boundaries are only your imagination</p>"},{"location":"assets/images/social/","title":"Social Cards","text":"<p>Social Cards are visual previews of the website that are included when sending links via social media platforms.</p> <p>Material for MkDocs is configured to generate beautiful social cards automatically, using the colors, fonts and logos defined in <code>mkdocs.yml</code></p> <p>Generated images are stored in this directory.</p>"},{"location":"basic-om-next-project/","title":"Basic Om-Next project","text":""},{"location":"basic-om-next-project/#what-is-om","title":"What is Om","text":"<ul> <li>V in MVC</li> <li>Immediate mode rendering</li> <li>Components</li> </ul>"},{"location":"basic-om-next-project/#updating-the-dom","title":"Updating the DOM","text":"<p>Om (and react) compares the latest changes to the virtual dom with the previous version of the dom, essentially creating a diff.  This diff is then applied to the DOM in the browser.  This approach avoids having to query the DOM in the browser which is an incredibly slow process.</p>"},{"location":"basic-om-next-project/create-project/","title":"Basic Om-Next project","text":""},{"location":"clojure-syntax/","title":"Some Basic Clojure","text":"<p>We are going to use the LightTable Instarepl to try out some Clojure, giving you a basic introduction to the syntax.</p> <p>Note Run LightTable.  Open the command bar, <code>Ctrl-space</code>, and type <code>Instarepl</code>.  Select <code>Instarepl: Open a Clojure Instarepl</code></p> <p></p> <p>For more examples of Clojure, take a look at the Clojure Through Code github repository</p>"},{"location":"clojure-syntax/basic-syntax/","title":"Basic Syntax","text":"<p>Clojure has a really small syntax, probably the smallest readable syntax ever create.  The core primitives that make up the language are:</p> <p></p> <p>There are a few primitives added for host language interop too.  Everything else is either a function or occasionally a macro.</p>"},{"location":"clojure-syntax/basic-syntax/#clojure-syntax-brackets-everywhere","title":"Clojure syntax - brackets everywhere","text":"<p>Clojure is percieved as having an abundance of <code>()</code>, the symbols that represent a list.  </p> <p>As Clojure is a LISP (List Processing) language then everything is written in the form of a list.  This makes Clojure very powerful and also easier to read.</p> <p>Using a list structure also demonstrates the data-centric nature of Clojure.  Every item in the list has a value, with the first item evaluated by a function call.</p> <p>Comment The seemingly abundance of <code>()</code> does put some people off until they realise there are fewer \"special characters\" in Clojure than in other C-based langauges (Java, C#, C, etc).  A good editor will also match brackets for you as you type, making it easy to write Clojure.</p> <p>Syntax differences seem a very trivial reason to avoid learning Clojure.  Any Clojure or Lisp aware editor will significantly reduce your typing and errors due to missing delimiters (ie. no more errors due to missing ; in C-based languages)</p>"},{"location":"clojure-syntax/basic-syntax/#prefix-notation","title":"Prefix notation","text":"<p>Instead of having a mix of notations like in many other languages, Clojure uses pre-fix notation entirely.</p> <p>In Clojure operators are applied uniformly and there is no room for ambiguity: <pre><code>    (+ 1 2 3 5 8 13 21)\n(+ 1 2 (- 4 1) 5 (* 2 4) 13 (/ 42 2))\n(str \"Clojure\" \" uses \" \"prefix notation\")\n</code></pre>   In Java and other C-based languages you have to explicitly add operators everywhere and there can be a mixture of notations</p> <pre><code>    (1 + 2 + 3 + 5 + 8 + 13 + 21);\n(1 + 2 + (- 4 1) + 5 + (* 2 4) + 13 + (/ 42 2));\nStringBuffer mystring = new StringBuffer(\"C-based languages\" + \" mix \" + \"notation\");\nx+=1; x++; x--; x+=y; x-=y; x*=y; x/=y;\n</code></pre>"},{"location":"clojure-syntax/basic-syntax/#extending-the-language-with-macros","title":"Extending the language with macros","text":"<p>A macro is a way to reduce boilerplate by wrapping up common code into a much simpler expression.  For example the the <code>defn</code> macro acts like any other function, but as it is a macro it is first expanded to the code structure it represents and then evaluated.</p> <p>See the [Macros section on Clojure.org] for more information.  Other good introductions to macros include</p> <ul> <li>Clojure from the ground up: macros</li> <li>Clojure for the brave and true: Macros</li> </ul> <p>Hint As anyone developer can create macros, the language can grow and evolve without having to wait for the language designers or official releases.  Macros are something you will use as functions, it is rare that you will write your own macros unless you are building a new kind of library or framework.</p>"},{"location":"clojure-syntax/control-flow/","title":"Control Flow","text":""},{"location":"clojure-syntax/control-flow/#if-this-then-that-else-the-other","title":"If this then that, else the other","text":"<p>Using the <code>if</code> funtion you can test if an expression evaluates to true.  If it is true, the first value is returned, if its false the second value is returned.</p> <p>Here is a simple example to see if one number is bigger that another</p> <pre><code>(if (&gt; 3 2) \"Higher\" \"Lower\")\n=&gt; \"Higher\"\n</code></pre> <pre><code>    (fn [x]\n(if (even? x)\n(inc x)\n(dec x)))\n</code></pre> <pre><code>(doc if)\n(doc if-not)\n</code></pre>"},{"location":"clojure-syntax/control-flow/#when","title":"When","text":"<p><pre><code>    (when ( (when (&gt; 3 2)\n(println \"3 is greater than 2\")\n\"Higher\")))\n=&gt; 3 is greater than 2\n=&gt; \"Higher\"\n</code></pre>   You can use Lighttable to see the docs for a function by placing the cursor over the function name and pressing <code>Cntrl-d</code> - or search the Clojure docs in the command window  <pre><code>(doc when)\n(doc when-not)\n</code></pre></p>"},{"location":"clojure-syntax/control-flow/#conditional-case","title":"Conditional - Case","text":"<p><pre><code>(case (inc 3)\n3 \"Uh oh\"\n4 \"Yep!\"\n\"Not so sure...\")\n</code></pre> <pre><code>\"Yep!\"\n</code></pre></p> <p><pre><code>(cond\n(= 4 (inc 2)) \"(inc 2) is 4\"\n(= 4 (/ 8 2)) \"Cond picks the first correct case\"\n(zero? (- (* 4 2) 8) \"This is true, but we won't get here\"\n:otherwise \"None of the above.\"\n</code></pre> <pre><code>\"Cond picks the first correct case\"\n</code></pre></p> <pre><code>(doc cond)\n(doc condp)\n</code></pre>"},{"location":"clojure-syntax/data-structures/","title":"Data Structures","text":"<p>When you define a name for a persistent data structure (list, map, vector, set), that name is termed a <code>Var</code>.  A var is a mutable reference that points to the data structure.  A Var is mutable, because it can be changed to point to another data structure (or any other legal Clojure expression)</p> <p>When you pass a name as an argument to a function, you are passing a reference to a data structure.  If that function modifies that data structure, it will create a new data structure and pass that back by value.</p> <p>The new data structure may include references to the original data structure if they have common values, an in-memory sharing model that makes persistent data structures very efficient in terms of memory use.</p> <p>Persistent data structures are held in memory as binary tree of values - TODO: how does this look for the different persistent data structures (eg. is the node value for a map the key &amp; value)</p>"},{"location":"clojure-syntax/data-types/","title":"Clojure data types","text":"<ul> <li>Numbers</li> </ul> <p>1 2 3 4 5 6.0 </p> <ul> <li> <p>Ratios</p> </li> <li> <p>Strings </p> </li> <li> <p>Symbols </p> </li> </ul> <p>The names we give funcitons and data structures to have an easy way to refer to them </p> <ul> <li>Keywords </li> </ul> <p>Used for enumerations and as keys in maps (a map is a series of zero or more key value pairs)</p> <ul> <li>Lists </li> </ul> <p>A linked list, however the first element of a list is evaluated as a function call (unless a quote character is placed in front of the list)</p> <ul> <li>Maps </li> </ul> <p>essentially hash maps</p> <ul> <li>Vectors </li> </ul> <p>esentially an array, however its persistent and therefore immutable</p> <ul> <li>Sets </li> </ul> <p>a unique set of elements, which can be ordered but are not by default</p>"},{"location":"clojure-syntax/destructuring/","title":"Destructuring","text":"<p>Destructuring is a powerful way to get data from a collection using positional or key based pattern matching.</p> <p>In our examples We are using the <code>let</code> function to create local bindings (labeling data with a specific name).  The let function has two arguments, the first is the name to be used for the binding and the second argument is the value the name will be assigned to.</p> <p>When the value passed to the <code>let</code> function is a collection, you can use destructuring to do the assignments.</p> <p>Example 1: Here we have data in a vector (an array like collection) and we want one or more names to reference the individual elements.</p> <pre><code>(let [[a b c &amp; d :as e] [1 2 3 4 5 6 7]]\n[a b c d e])\n</code></pre> <p>The let function creates the local names <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> and <code>e</code>.  The names a to d take the corresponding positional value in the collection: a is bound to 1, b is bound to 2, etc.</p> <p>The <code>:as</code> keyword tells the <code>let</code> function to bind everything else remaining to <code>e</code>.</p> <p>Example 2: We now have a nested collection, a vector that contains two vectors.  We can still use positional destructuring to pull out the values into names</p> <pre><code>(let [[[x1 y1][x2 y2]] [[1 2] [3 4]]]\n[x1 y1 x2 y2])\n</code></pre> <p>Example 3: This distructuring also works with strings</p> <pre><code>(let [[a b &amp; c :as str] \"asdjhhfdas\"]\n[a b c str])\n</code></pre> <p>Example 4 And finally destructuring with maps.  Here we are also using the <code>:or</code> directive to set a default value if there is no match.</p> <pre><code>(let [{a :a, b :b, c :c, :as m :or {a 2 b 3}}  {:a 5 :c 6}]\n[a b c m])\n</code></pre> <p>It is often the case that you will want to bind same-named symbols to the map keys. The :keys directive allows you to avoid the redundancy:</p> <p><pre><code>(let [{fred :fred ethel :ethel lucy :lucy} m] )\n</code></pre>  can be factored to:</p> <pre><code>(let [{:keys [fred ethel lucy]} m] )\n</code></pre>"},{"location":"clojure-syntax/functions/","title":"Defining Funtions","text":"<p>Here is a simple function definition that takes a number and divides it by two</p> <pre><code>    (defn half-a-number \"Divide a given number by 2\"\n[number]\n(/ number 2))\n</code></pre> <p>Once you have defined a function, you can call it by using the function name as the first element of a list</p> <pre><code>    (half-a-number 4)\n</code></pre>"},{"location":"clojure-syntax/functions/#breaking-down-the-defn-syntax","title":"Breaking down the defn syntax","text":"<p>The syntax <code>defn</code> is what we call a macro, it is a simpler way to write clojure code that does the same thing.  </p> <p>You can think of defining a function with <code>defn</code> as two steps</p> <p>1) Give the function a name - using the <code>def</code> syntax   2) Define the functions behaviour and arguments it takes - using the <code>fn</code> syntax</p> <p>Here is the same function if you typed it out in full</p> <pre><code>    (def half-a-number\n(fn [number]\n(/ number 2)))\n</code></pre> <p>fixme is it too soon to show macroexpand ?</p>"},{"location":"clojure-syntax/local-assignement/","title":"Local Assignment","text":""},{"location":"clojure-syntax/maths/","title":"Maths and numbers","text":"<p>Doing some simple math helps you to get used to the structure of Clojure, espeicially the prefix notation.  Mathematics is also a good way to show how effective and clean prefix notation is.</p> <pre><code>(+ 1 1 2489 459 2.) ; =&gt; 2\n(- 2 1) ; =&gt; 1\n(* 1 2) ; =&gt; 2\n(/ 2 1) ; =&gt; 2\n</code></pre> <p>Clojure uses Prefix notation, so math operations on many arguments is easy.</p> <pre><code>(+ 1 2 3 4 5)\n(+ 1 2 (* 3 4) (- 5 6 -7))\n(apply + [1 2 3])\n(map + [1 2 3.0] [4.0 5 6])\n(repeat 4 9)\n</code></pre> <p>Equality is represented by the <code>=</code> function.  Yes, <code>=</code> is a proper function too, not just an operator as with other languages.</p> <pre><code>(= 1 1) ; =&gt; true\n(= 2 1) ; =&gt; false\n</code></pre> <p>Equality is very efficient when your data structures are immutable.  For example if you have very large data sets, you can simply compare a hash value to see if those data structures are the same.</p> <p>Of course you also have the <code>not</code> function for reversing logic too</p> <pre><code>(not true) =&gt; false\n</code></pre>"},{"location":"clojure-syntax/maths/#truethy-experiments","title":"Truethy experiments","text":"<p>;; some truthiness with math functions for you to try, as well as look at the types Clojure assigns</p> <pre><code>(+)\n(class (+))\n(*)\n(true? +)\n(false? +)\n(true? *)\n(false? *)\n(true? 1)\n(true? -1)\n(true? true)\n(- 2)\n; (class (/))  ;; wrong number of arguments error\n</code></pre> <p>Predicates - take a value and return a boolean result (true | false) <pre><code>(true? true)\n(true? (not true))\n(true? false)\n(true? (not false))\n(true? nil)\n</code></pre></p>"},{"location":"clojure-syntax/maths/#types","title":"Types","text":"<p>Clojure uses Java's object types for booleans, strings and numbers.  Use the <code>class</code> function to inspect them.</p> <pre><code>(class 1)\n; Integer literals are java.lang.Long by default\n(class 1.1)    ; Float literals are java.lang.Double\n(class \"\")\n; Strings always double-quoted, and are java.lang.String\n(class false)  ; Booleans are java.lang.Boolean\n(class nil)    ; The \"null\" value is called nil\n(class (list 1 2 3 4))\n(class true)\n(class ())\n(class (list 1 2 34 5))\n(class (str 2 3 4 5))\n(class (+ 22/7))\n(class 5)\n(class \"fish\")\n(type [1 2 3])\n(type {:a 1 :b 2})\n(type (take 3 (range 10)))\n</code></pre>"},{"location":"clojure-syntax/maths/#ratios","title":"Ratios","text":"<p>To help maintain the precision of numbers, Clojure has a type called Ratio.  So when you are dividing numbers you can keep the as a fraction using whole numbers, rather than constrain the result to a approximate</p> <pre><code>(/ 2)\n</code></pre> <p>A classic example is dividing 22 by 7 which is approximately the value of Pi</p> <pre><code>(/ 22 7)\n(class (/ 22 7))\n</code></pre> <p>If you want to force Clojure to evaluate this then you can specify one of the numbers with a decimal point</p> <pre><code>(class (/ 22 7.0))\n</code></pre>"},{"location":"clojure-syntax/namespace/","title":"Namespace","text":"<p>A namespace in Clojure is used to manage the logical seperation of code, usually along features of the application, service or library you are developing.  A namespace contains data structures and functions, limiting their scope to that function.</p> <p>Unless otherwise defined, any function can call any other function in the namespace by just the function name.  The same is true for any naed data structures, they can be called from anywhere in the namespace with just their name.</p> <p>Hint Remember that Clojure is evaluated from top to bottom, so if you are calling a named function or data structure, it must have had its definition evaluated first.</p>"},{"location":"clojure-syntax/namespace/#including-another-namespace","title":"Including another namespace","text":"<p><code>require</code> or <code>:require</code> is used to enable access to the functions &amp; named datastructures in another namespace than the current one.  </p> <pre><code>(ns my-namespace.core :require [clojure.java.io])\n(defn read-the-file [filename]\n(line-seq (clojure.java.io/reader filename)))\n(read-the-file \"project.clj\")\n</code></pre> <p>The <code>reader</code> funciton can be accessed, however, we still need to include the fully qualified namespace path, <code>clojure.java.io</code>.</p> <p>If the namespace has a long name, you can provide an alias (please use names that keep the code readable)</p> <pre><code>(ns my-namespace.core :require [clojure.java.io :as java-io])\n(defn read-the-file [filename]\n(line-seq (java-io/reader filename)))  (read-the-file \"project.clj\")\n</code></pre> <p>Or if you are going to use the function multiple times in the current namespace, you could also include that function directly, no longer requiring any kind of namespace qualifier</p> <pre><code>(ns my-namespace.core :require [clojure.java.io :as [reader]])\n(defn read-the-file [filename]\n(line-seq (reader filename)))  (read-the-file \"project.clj\")\n</code></pre> <p>Hint You may see <code>use</code> or <code>:use</code> as an alternative approach.  While this will work, it also includes everything from the other namespace into your current one.  This is seen as a bad practice, especially when writing libraries, as you can end up including a great many unused functions into the namespace.  </p> <p>As Clojure is typically composed of many libraries, its prudent to only include the specific things you need from another namespace.  This also helps reduce conflicts when including multiple libraries in your project.</p>"},{"location":"clojure-syntax/namespace/#external-libraries","title":"External libraries","text":"<p>To use a library that is not part of your project you also need to include it as a dependency.  You can do this using the <code>:dependencis</code> section of the  Leiningen project file.</p> <pre><code>;; include and example dependency - eg ring, compujure\n</code></pre>"},{"location":"clojure-syntax/naming-binding/","title":"Naming things - data structues and functions","text":"<p>The <code>def</code> function is used to name data structures in Clojure.</p> <p>You can also use <code>def</code> to name functions, however it is more common to use <code>defn</code> (which is a macro around def) to give a function a name.</p>"},{"location":"clojure-syntax/naming-binding/#keeping-things-private","title":"Keeping things private","text":"<p>There is less empasis on keeping functions and data structures private (compared to Java, C++, C#).  If you want to define a function name so that it is only accessible by other functions of the same namespace, you can use the <code>defn-</code> function.</p> <p>There is no private equivaltent for <code>def</code> (as of Clojure 1.6) however you can use metadata to specify this</p> <p>(def ^:private name data)</p>"},{"location":"clojure-syntax/naming-binding/#note-check-if-there-is-anything-new-around-this-or-other-common-practices","title":"Note:: Check if there is anything new around this or other common practices","text":""},{"location":"clojure-syntax/naming-binding/#misc-writing-a-private-def-macro","title":"Misc - writing a private def macro","text":"<p>You could write your own macro to create a private <code>def</code> called <code>def-</code></p> <pre><code>(defmacro def- [item value]\n`(def ^{:private true} ~item ~value)\n)\n</code></pre> <p>There are no naming conventions for a private symbol name.  As its defined an used within the scope of that one namespace (file), then there is no real need to make a special convention.  Private functions will just be called as normal within the namespace and it will be quite clear from the function definition that it is private.</p> <p>Clojure community style guilde</p>"},{"location":"clojure-syntax/naming-binding/#example","title":"example","text":"<p>Learning Clojure #4: private functions http://tech.puredanger.com/2010/02/09/clojure-4-private-functions/</p> <p>Sometimes in a Clojure file you just want some helper functions that shouldn\u2019t be exposed outside the namespace. You can create a private function using the special defn- macro instead of defn.</p> <p>For instance, create a file foo/bar.clj with a public and a private function:</p> <p>(ns foo.bar) (defn- sq [x] (* x x)) (defn sum-squares [a b] (+ (sq a) (sq b)))</p> <p>Then use it from the REPL:</p> <p>user=&gt; (use 'foo.bar) nil user=&gt; (sum-squares 3 4) 25 user=&gt; (sq 5) java.lang.Exception: Unable to resolve symbol: sq in this context (NO_SOURCE_FILE:6)</p>"},{"location":"clojure-syntax/naming-binding/#naming-local-scope","title":"Naming - local scope","text":""},{"location":"clojure-syntax/naming-binding/#local-names-in-functions","title":"Local names in functions","text":"<p>You can define names for things within the scope of a function using the <code>let</code> function.</p>"},{"location":"clojure-syntax/naming-binding/#example_1","title":"Example","text":""},{"location":"clojure-syntax/naming-binding/#local-names-in-data-structures","title":"Local names in data structures","text":"<p>When defining a map you are creating a series of key value pairs.  The key is essentially a name that represents the value it is paired with.  Keys are often defined using a <code>:keyword</code>.</p> <pre><code>  {:radius 10, :pi 22/7 :colour purple}\n(def my-circle {:radius 10, :pi 22/7 :colour purple})\n</code></pre>"},{"location":"clojure-syntax/persistent-data-structures-lists/","title":"Theory: Lists","text":"<p>List is a general set of elements with a sequential lookup time.  New elements are added to the front of the list as this is the most efficient way to update a list.</p> <p>You can use the list function to create a new list (try the following expressions in a REPL)</p> <pre><code>(list 1 2 3 4)\n(list )    ;; creates an empty list\n(list 1 2 \"three\" [4] five '(6 7 8 9))\n(list -1 -0.234 0 1.3 8/5 3.1415926)\n(list \"cat\" \"dog\" \"rabit\" \"fish\" 12 22/7)\n(list :cat :dog :rabit :fish)\n</code></pre> <p>You can mix types because Clojure is dynamic and it will work it out later, you can even have functions as elements, because a function always returns a value.  In the following example we define a list that includes a function call to the <code>str</code> function that joins its parameters into a single string.</p> <pre><code>(list :cat 1 \"fish\" 22/7 (str \"fish\" \"n\" \"chips\"))\n</code></pre>"},{"location":"clojure-syntax/persistent-data-structures-lists/#lists-evaluate-as-function-calls","title":"Lists evaluate as function calls","text":"<p>One unique thing about lists is that the first element is always evaluated as a function call, with the remaining elements as arguments.  So, defining a list just using <code>()</code> will cause an error</p> <pre><code>(1 2 3 4)   ;; failing expression\n</code></pre> <p>The previous list definition fails because there is no function defined with the name <code>1</code></p> <p>We can call any of our own functions or any functions from Clojure using a list</p> <pre><code>(str \"The str function\" \" \" \"joins strings together\")\n(+ 1 2 3 4 5)  ;; + is a function that adds numbers\n(apply * [2 4 6])  ;; applies the * function to each element in the collection\n</code></pre>"},{"location":"clojure-syntax/persistent-data-structures-lists/#treat-lists-as-data","title":"Treat lists as data","text":"<p>There is a special function called <code>quote</code> that tells Clojure to treat all the elements of the list as data.  You can also use the short-hand quote character, '</p> <pre><code>(quote (1 2 3 4))\n\n'(1 2 3 4)\n</code></pre> <p>So using the quote character we can define lists very easily and concisely.</p> <p>```' '(-1 -0.234 0 1.3 8/5 3.1415926) '(\"cat\" \"dog\" \"rabit\" \"fish\") '(:cat :dog :rabit :fish) '(:cat 1 \"fish\" 22/7 (str \"fish\" \"n\" \"chips\")) <pre><code>## Duplicate elements in a list \n\nA list can contain elements that are the same value.\n</code></pre> (list 1 2 3 4 1) (list \"one\" \"two\" \"one\") (list :fred :barney :fred) <pre><code>If you wish to ensure only unique values then you can use a [set](sets.html)\n\n## Changing lists with the cons function\n\nAs we have seen in the introduction to this section, changing a lists values once created is not possible.  However when a list is used as the paramter to a function call it can return a new list with different values.\n\nThe `cons` function is used to add values to the list\n</code></pre> (cons 5 '(1 2 3 4))</p> <p>;; =&gt; (5 1 2 3 4) <pre><code>You will notice that the value 5 is added to the front of the new list that is returned.  As this is a linked list and not indexed, it is more performant to add values to the front of a list.\n\nHere is another example with strings\n</code></pre> (cons \"fish\" '(\"and\" \"chips\")) ```</p>"},{"location":"clojure-syntax/persistent-data-structures-maps/","title":"Theory: Maps","text":"<p>A map in Clojure is a collection of key &amp; value pairs in the form <code>{key value}</code>.  This kind of map is often referred to as a hash map in other languages.</p> <p>Typically a <code>:keyword</code> is used for the keys in a map as this provides a simple way to extract values (keywords act like a function call that returns the value they are associated with in the map)</p> <p>Values can be of any type, just like in other Clojure collections.  Values can also be defined as function calls or other collections including maps.</p> <pre><code>{:key \"value\"}\n(:key 42)\n{:key :value}\n{\"key\" \"value\"}\n(\"key\" :value)\n\n{:a 1 :b 2 :c 3 }\n</code></pre>"},{"location":"clojure-syntax/persistent-data-structures-maps/#maps-of-maps","title":"Maps of Maps","text":"<p>Its common to have maps made up of other maps.  Here is an example of a map made up of a :keyword as the key and a map as the value.  The map representing the value is itself ;; defined with :keywords and strings</p> <pre><code>{:starwars {\n    :characters {\n      :jedi   [\"Luke Skywalker\"\n               \"Obiwan Kenobi\"]\n      :sith   [\"Darth Vader\"\n               \"Darth Sideous\"]\n      :droids [\"C3P0\"\n               \"R2D2\"]}\n    :ships {\n      :rebel-alliance  [\"Millenium Falcon\"\n                        \"X-wing figher\"]\n      :imperial-empire [\"Intergalactic Cruser\"\n                        \"Destroyer\"\n                        \"Im just making these up now\"]}}}\n</code></pre> <p>Individual starwars characters can be defined using a map of maps</p> <pre><code>{:luke   {:fullname \"Luke Skywarker\" :skill \"Targeting Swamp Rats\"}\n  :vader  {:fullname \"Darth Vader\"    :skill \"Crank phone calls\"}\n  :jarjar {:fullname \"JarJar Binks\"   :skill \"Upsetting a generation of fans\"}}\n</code></pre> <p>To make the starwars character information easier to use, lets give the collection of characters a name using the def function</p> <pre><code>(def starwars-characters\n   {:luke   {:fullname \"Luke Skywarker\" :skill \"Targeting Swamp Rats\"}\n    :vader  {:fullname \"Darth Vader\"    :skill \"Crank phone calls\"}\n    :jarjar {:fullname \"JarJar Binks\"   :skill \"Upsetting a generation of fans\"}})\n</code></pre> <p>Using the get function we return all the informatoin about Luke</p> <pre><code>(get starwars-characters :luke)\n</code></pre> <p>By wrapping a second <code>get</code> function around our first, we can get a specific piece of information about Luke</p> <pre><code>(get (get starwars-characters :luke) :fullname)\n</code></pre> <p>There is also the get-in function that makes the syntax a little easier to read</p> <pre><code>(get-in starwars-characters [:luke :fullname])\n(get-in starwars-characters [:vader :fullname])\n</code></pre> <p>You can write more concise code by using the map or keywords as a function call on the data structure</p> <pre><code>(starwars-characters :luke)\n(:fullname (:luke starwars-characters))\n(:skill (:luke starwars-characters))\n\n(starwars-characters :vader)\n(:skill (:vader starwars-characters))\n(:fullname (:vader starwars-characters))\n</code></pre> <p>And finally we can also use the threading macro to minimise our code further</p> <pre><code>(-&gt; starwars-characters\n    :luke)\n\n(-&gt; starwars-characters\n    :luke\n    :fullname)\n\n(-&gt; starwars-characters\n    :luke\n    :skill)\n</code></pre> <p>See the following gist for more examples of destructuring with Clojure</p>"},{"location":"clojure-syntax/persistent-data-structures-maps/#duplicates-in-following-maps","title":"Duplicates in  following maps...","text":"<p>It is possible to have duplicate values in a map, but its not possible to have duplicate keys.  Any key must be unique within the scope of a map.</p> <p>The following maps will throw duplicate key errors</p> <pre><code>{\"fish\" \"battered\" \"chips\" \"fried\" \"fish\" \"battered and fried\"}\n{:fish \"battered\" :chips \"fried\" :fish \"battered &amp; fried\"}\n</code></pre> <p>Duplicate values are okay though</p> <pre><code>{\"fish\" \"battered\" \"chips\" \"fried\" \"cod\" \"fried\"}\n</code></pre> <p>The same key can be used in a nested map.  For example, if a map has a keyword of <code>:name</code> and that key has a value defined by a map, then that map can also use the key <code>:name</code>.</p> <pre><code>{:name {:name \"john\" :address \"London\"}}\n</code></pre>"},{"location":"clojure-syntax/persistent-data-structures-maps/#changing-maps","title":"Changing Maps","text":"<p>Maps are immutable, however you can </p> <pre><code>(def alphabet-soup {:a 1 :b 2 :c 3})\n\n(assoc alphabet-soup :d 4)\n</code></pre>"},{"location":"clojure-syntax/persistent-data-structures-sets/","title":"Theory: Sets","text":"<p>A Clojure set is a collection of unique values, unordered by default.</p> <p>If you try and define a set with elements that are the same value, then a duplicate key error is returned.  This error can be seen when trying to define the following set</p> <p>You want to create an unordered collection of distinct objects, which can be tested for membership quickly.</p> <pre><code>#{1 2 3 4 1}\n</code></pre> <p>The <code>set</code> function can be used to create a unique set from the another collection.  The <code>sorted-set</code> also created a unique set that is ordered by value</p> <pre><code>(set [1 2 3 4 1])\n\n(sorted-set 1 4 0 2 9 3 5 3 0 2 7 6 5 5 3 8)\n</code></pre> <p>;; Set #{} ;; a unique set of elements</p> <p>(#{:a :b :c} :c) (#{:a :b :c} :z)</p> <p>There are lots of functions that work on data structures</p> <p>(def evil-empire #{\"Palpatine\" \"Darth Vader\" \"Boba Fett\" \"Darth Tyranus\"})</p> <p>(contains? evil-empire \"Darth Vader\")</p>"},{"location":"clojure-syntax/persistent-data-structures-vectors/","title":"Theory: Vectors","text":"<p>Clojure Vectors can be though of as array collections.  The vector is</p> <ul> <li>indexed so you can get fast random access</li> <li>immutable - a persistent data structure</li> </ul> <p>Vectors and maps are the most common data structures use to hold data in Clojure</p> <p>You can use the vector function to create a new vector</p> <pre><code>(vector 1 2 3 4)\n</code></pre> <p>Usually you just use the [] notation to create a vector to help keep your code readable</p> <pre><code>[1 2 3 4]\n[1 2.4 3.1435893 11/4 5.0 6 7]\n[:cat :dog :rabit :fish]\n[:cat 1 \"fish\" 22/7 (str \"fish\" \"n\" \"chips\")]\n[]\n</code></pre> <p>You can also put other data structures in vectors, in this example a list is an element of the vector</p> <pre><code>[1 2 3 '(4 5 6)]\n</code></pre> <p>Remember we defined five earlier in the code</p> <pre><code>[1 2 3 4 (list five)]\n</code></pre>"},{"location":"clojure-syntax/persistent-data-structures-vectors/#duplicate-elements","title":"Duplicate elements","text":"<p>A vector can hold duplicate values, which makes vectors a great default data structure for any kind of values.</p> <pre><code>[1 2 3 4 1]\n</code></pre>"},{"location":"clojure-syntax/persistent-data-structures-vectors/#types","title":"Types","text":"<pre><code>(class [1 2 3])\n\n(coll? [1 2 3]) ; =&gt; true\n\n(seq? [1 2 3]) ; =&gt; false\n</code></pre>"},{"location":"clojure-syntax/persistent-data-structures-vectors/#using-vectors","title":"Using Vectors","text":"<p>Clojure uses dynamic typing, this means its trivial to mix and match different kinds of data.</p> <p>Here we are defining a name for a vector, which contains numbers, a string and name of another def.</p> <pre><code>(def my-data [1 2 3 \"frog\" person])\n\nmy-data\n</code></pre> <p>You can also dynamically re-define a name to points to a different value</p> <pre><code>(def my-data [1 2 3 4 5 \"frog\" person])\n</code></pre> <p>The original value that defined my-data remains unchanged (its immutable), so anything using that value remains unaffected.  Essentially we are re-mapping my-data to a new value.</p> <pre><code>(def developer-events-vector\n  [:devoxxuk :devoxxfr :devoxx :hackthetower] )\n</code></pre> <p>Lets define a simple data structure for stocks data.  This is a vector of maps, as there will be one or more company stocks to track.  Each map represents the stock information for a company.</p> <pre><code>(def portfolio [ { :ticker \"CRM\" :lastTrade 233.12 :open 230.66}\n                 { :ticker \"AAPL\" :lastTrade 203.25 :open 204.50}\n                 { :ticker \"MSFT\" :lastTrade 29.12  :open 29.08 }\n                 { :ticker \"ORCL\" :lastTrade 21.90  :open 21.83 }])\n</code></pre> <p>We can get the value of the whole data structure by refering to it by name</p> <pre><code>portfolio\n</code></pre> <p>As the data structure is a vector (ie. array like) then we can ask for a specific element by its position in the array using the nth function</p> <p>;; Lets get the map that is the first element (again as a vector has array-like properties, the first element is referenced by zero)</p> <pre><code>(nth portfolio 0)\n</code></pre> <p>The vector has 4 elements, so we can access the last element by referencing the vector using 3</p> <pre><code>(nth portfolio 3)\n</code></pre> <p>As portfolio is a collection (list, vector, map, set), also known as a sequence, then we can use a number of functions that provide common ways of getting data from a data structure</p> <pre><code>(first portfolio)\n(rest portfolio)\n(last portfolio)\n</code></pre> <p>You can pull out data from a Vector ([1 2 3] 1)</p> <p>([1 2 3] 1 2)  ;; wrong number of arguments, vectors behaving as a function expect one parameter</p>"},{"location":"clojure-syntax/persistent-data-structures/","title":"Persistent Data Structures","text":"<p>Clojure has 4 built in data structures:</p> <ul> <li>list - simple linked list, the first element is assumed to be a function call</li> <li>map - a key value pair with keys often defined using Clojure keywords</li> <li>vector - an indexed array-like structure</li> <li>set - a unique set of elements, not ordered by default</li> </ul> <p>Each of these data structures are immutable, so once they are created they cannot be changed.</p> <p>When you run a function over these data structures then a new data structure is returned.  This keeps your code very simple as you can guarantee there are no side effects due to other parts of your code changing state.</p>"},{"location":"clojure-syntax/persistent-data-structures/#sharing-data","title":"Sharing data","text":"<p>It may seem inefficient to create a new copy of a data structure each time, especially when working on very large data structure.  Clojure creates very efficient copies, by sharing elements from the original data structure.</p> <p></p> <p>Hint Clojure manages data internally as a binary tree</p>"},{"location":"clojure-syntax/strings/","title":"Strings in Clojure","text":"<p>While you can use the Java-like function <code>println</code>, this is refered to as a side-effect because when you call this function it returns nil.  The actual text is output to the REPL or console.</p> <p>Here is a very simple xeample</p> <pre><code>(println \"Hello, whats different with me?  What value do I return\")\n=&gt; \"Hello, whats different with me\"\n=&gt; nil\n</code></pre> <p>In Clojure, you are more likely to use the <code>str</code> function when working with strings.</p> <pre><code>(str \"Hello, I am returned as a value of this expression\")\n=&gt; Hello, I am returned as a value of this expression\n</code></pre> <p>You can see that there are no side-effects when using <code>str</code> and the string is returned as the value of the function call.</p> <p>Its easy to join strings together with the <code>str</code> function</p> <pre><code>(str \"Hello\" \", \" \"HackTheTower UK\")\n=&gt; Hello, HackTheTower UK\n</code></pre>"},{"location":"clojurescript-code/","title":"ClojureScript code","text":"<p>I have taken examples from a number of sources to give you a basic introduction to using Clojurescript.  Please see Clojurescript Unraveled for a more complete reference guide</p> <ul> <li>Rafel Spacjer's blog: Clojurescript: Javascript interop</li> </ul>"},{"location":"clojurescript-code/#defining-scope","title":"Defining scope","text":""},{"location":"clojurescript-code/#javascript-scope-included","title":"Javascript scope included","text":"<p>ClojureScript defines special js namespace to allow accessing JavaScript types/functions/methods/objects defined in global scope (i.e. window object for browser).</p> <pre><code>(def text js/globalName) ;; JS output: namespace.text = globalName;\n</code></pre> <p>Creating objects</p> <p>We can create JavaScript objects from ClojureScript by adding . to the end of constructor function:</p> <p>(def t1 (js/MyType.)) ;; JS output: namespace.t1 = new MyType;</p> <p>(note: at first I thought that this generated JS code was wrong, because of the lack of parentheses, but as it clarifies it\u2019s valid - if constructor function doesn\u2019t have arguments, then parentheses can be skipped)</p> <p>with arguments:</p> <p>(def t2 (js/MyComplexType. \"Bob\")) ;; JS output: namespace.t2 = new MyComplexType(\"Bob\");</p> <p>There is also a different way of creating objects, by using the new function (the name of JS constructor function should be without period):</p> <p>(def my-type (new js/MyComplexType \"Bob\")) ;; JS output: namespace.my_type = new MyComplexType(\"Bob\");</p> <p>Invoking methods</p> <p>To invoke a JavaScript method we need to prefix the name of the method with the . (dot):</p> <p>(.hello js/window) ;; JS output: window.hello();</p> <p>which is a syntactic sugar of:</p> <p>(. js/window (hello))</p> <p>To pass arguments to the function we do:</p> <p>(.helloAgain js/window \"John\") ;; JS output: window.helloAgain(\"John\");</p> <p>or</p> <p>(. js/window (helloAgain \"John\"))</p> <p>Same thing can be done with created object:</p> <p>(def my-type (js/MyComplexType. \"Bob\")) ;; JS output: namespace.my_type = new MyComplexType(\"Bob\"); (.hello my-type)                        ;; JS output: namespace.my_type.hello();</p> <p>Accessing properties</p> <p>ClojureScript provides a few ways of working with JavaScript properties. The simplest one is to use .- property access syntax:</p> <p>(def my-type (js/MyType.))  ;; JS output: namespace.my_type = new MyType; (def name (.-name my-type)) ;; JS output: namespace.name = namespace.my_type.name;</p> <p>similar thing can be achieved by aget function, which takes object and the name of the property (as a string) as arguments:</p> <p>(def name (aget my-type \"name\")) ;; JS output: namespace.name = namespace.my_type[\"name\"];</p> <p>The aget allows also accessing nested properties:</p> <p>(aget js/object \"prop1\" \"prop2\" \"prop3\") ;; JS output: object[\"prop1\"][\"prop2\"][\"prop3\"];</p> <p>the same thing (generated code is different) can be done by using .. syntax:</p> <p>(.. js/object -prop1 -prop2 -prop3) ;; JS output: object.prop1.prop2.prop3;</p> <p>You can also set a value of a property from the ClojureScript, to do this you can use aset or set! functions:</p> <p>The aset function takes name of the property as a string:</p> <p>(def my-type (js/MyType.)) (aset my-type \"name\" \"Bob\") ;; JS output: namespace.my_type[\"name\"] = \"Bob\";</p> <p>and the set! takes a property access:</p> <p>(set! (.-name my-type) \"Andy\") ;; JS output: namespace.my_type.name = \"Andy\";</p> <p>Arrays</p> <p>The aget function can be also used for accessing JavaScript array element:</p> <p>(aget js/globalArray 1) ;; JS output: globalArray[1];</p> <p>or if you want to get nested element you can use it in this way:</p> <p>(aget js/globalArray 3 1) ;; JS output: globalArray[3][1];</p> <p>Nested scopes</p> <p>This subject was a bit confusing for me. In my project I wanted to translate such a code:</p> <p>var map = new Microsoft.Maps.Map();</p> <p>to ClojureScript. As you can see the Map function is in nested scope. The idiomatic way of accessing nested properties is to use .. or aget functions but this can\u2019t be done for constructor function. In such case, we need to use the dot notation (even it\u2019s not idiomatic for Clojure code):</p> <p>(def m2 (js/Microsoft.Maps.Themes.BingTheme.))</p> <p>or with the new function:</p> <p>(def m1 (new js/Microsoft.Maps.Themes.BingTheme))</p> <p>If we write this expression like this:</p> <p>(def m3 (new (.. js/Microsoft -Maps -Themes -BingTheme)))</p> <p>we will get an exception:</p> <p>First arg to new must be a symbol at line                 core.clj:4403 clojure.core/ex-info              analyzer.clj:268 cljs.analyzer/error              analyzer.clj:265 cljs.analyzer/error              analyzer.clj:908 cljs.analyzer/eval1316[fn]              MultiFn.java:241 clojure.lang.MultiFn.invoke             analyzer.clj:1444 cljs.analyzer/analyze-seq             analyzer.clj:1532 cljs.analyzer/analyze[fn]             analyzer.clj:1525 cljs.analyzer/analyze              analyzer.clj:609 cljs.analyzer/eval1188[fn]              analyzer.clj:608 cljs.analyzer/eval1188[fn]              MultiFn.java:241 clojure.lang.MultiFn.invoke             analyzer.clj:1444 cljs.analyzer/analyze-seq             analyzer.clj:1532 cljs.analyzer/analyze[fn]             analyzer.clj:1525 cljs.analyzer/analyze             analyzer.clj:1520 cljs.analyzer/analyze              compiler.clj:908 cljs.compiler/compile-file*             compiler.clj:1022 cljs.compiler/compile-file</p> <p>Creating JavaScript objects</p> <p>There are many cases where we need to pass JavaScript object to a method from ClojureScript. In general ClojureScript works with its own data structures (immutable, persistent vector, map, set etc.) that can be converted to plain JS objects. There are several ways of doing it.</p> <p>If we want to create a simple JavaScript object from the list of key value pairs we can use js-obj macro:</p> <p>(def my-object (js-obj \"a\" 1 \"b\" true \"c\" nil)) ;; JS output: namespace.my_object_4 = (function (){var obj6284 = {\"a\":(1),\"b\":true,\"c\":null};return obj6284;</p> <p>Note that js-obj forces you to use strings as keys and basic data literals (string, number, boolean) as values. The ClojureScript data structures won\u2019t be changed, so this:</p> <p>(def js-object (js-obj  :a 1 :b [1 2 3] :c #{\"d\" true :e nil}))</p> <p>will create such JavaScript object:</p> <p>{   \":c\" cljs.core.PersistentHashSet,    \":b\" cljs.core.PersistentVector,    \":a\" 1 }</p> <p>as you can see there are used internal types such as: cljs.core.PersistentHashSet cljs.core.PersistentVector and the ClojureScript keyword was changed to string prefixed with colon.</p> <p>To solve this problem we can use clj-&gt;js function that: \u201cRecursively transforms ClojureScript values to JavaScript. sets/vectors/lists become Arrays, Keywords and Symbol become Strings, Maps become Objects.\u201d</p> <p>(def js-object (clj-&gt;js  :a 1 :b [1 2 3] :c #{\"d\" true :e nil}))</p> <p>will produce such object:</p> <p>{   \"a\": 1,   \"b\": [1, 2, 3],   \"c\": [null, \"d\", \"e\", true] }</p> <p>There is also one more way of producing JavaScript objects - we can use #js reader literal:</p> <p>(def js-object #js {:a 1 :b 2})</p> <p>which generates code:</p> <p>namespace.core.js_object = {\"b\": (2), \"a\": (1)};</p> <p>When working with #js you need to be cautious, because this literal also won\u2019t transform inner structures (it\u2019s shallow):</p> <p>(def js-object #js {:a 1 :b [1 2 3] :c {\"d\" true :e nil}})</p> <p>will create such object:</p> <p>{   \"c\": cljs.core.PersistentArrayMap,    \"b\": cljs.core.PersistentVector,    \"a\": 1 }</p> <p>to solve this you need to add #js before every ClojureScript structure:</p> <p>(def js-object #js {:a 1 :b #js [1 2 3] :c #js [\"d\" true :e nil]})</p> <p>JavaScript object:</p> <p>{   \"c\": {     \"e\": null,     \"d\": true   },   \"b\": [1, 2, 3 ],   \"a\": 1 }</p> <p>Using JavaScript objects</p> <p>There are situations when we need to convert JavaScript object or array into ClojureScript data structure. We can do this by using js-&gt;clj function that: \"Recursively transforms JavaScript arrays into ClojureScript vectors, and JavaScript objects into ClojureScript maps. With option \u2018:keywordize-keys true\u2019 will convert object fields from strings to keywords.</p> <p>(def my-array (js-&gt;clj (.-globalArray js/window))) (def first-item (get my-array 0)) ;; 1</p> <p>(def my-obj (js-&gt;clj (.-globalObject js/window))) (def a (get my-obj \"a\")) ;; 1</p> <p>as the function doc states we can use :keywordize-keys true to convert string keys of created map to keywords:</p> <p>(def my-obj-2 (js-&gt;clj (.-globalObject js/window) :keywordize-keys true)) (def a-2 (:a my-obj-2)) ;; 1</p> <p>Addition</p> <p>If all other methods of working with JavaScript failed, there is a js* that takes a string as an argument and emits it as a JavaScript code:</p> <p>(js* \"alert('my special JS code')\") ;; JS output: alert('my special JS code');</p> <p>Exposing ClojureScript functions</p> <p>It is worth noting that the exact form of JavaScript code generated from ClojureScript depends on compiler settings. Those settings can be defined in Leiningen project.clj file:</p> <p>Part of project.clj file:</p> <p>:cljsbuild {     :builds [{:id \"dev\"               :source-paths [\"src\"]               :compiler {                 :main your-namespace.core                 :output-to \"out/your-namespace.js\"                 :output-dir \"out\"                 :optimizations :none                 :cache-analysis true                 :source-map true}}              {:id \"release\"               :source-paths [\"src\"]               :compiler {                 :main blog-sc-testing.core                 :output-to \"out-adv/your-namespace.min.js\"                 :output-dir \"out-adv\"                 :optimizations :advanced                 :pretty-print false}}]}</p> <p>As you can see above, there are two defined builds: dev and release. Please note the :optimizations parameter - for :advanced value the code will be truncated (not used code is removed) and renamed (shorter names are used).</p> <p>For example, this ClojureScript code:</p> <p>(defn add-numbers [a b]   (+ a b))</p> <p>will be compiled to such JavaScript code in :advanced mode:</p> <p>function yg(a,b){return a+b}</p> <p>The function name is completely \u201crandom\u201d, so you can\u2019t use it from JavaScript file. To be able to use defined in ClojureScript functions (with their original names) you should mark them with the :export metadata:</p> <p>(defn ^:export add-numbers [a b]   (+ a b))</p> <p>The :export keyword tells compiler to export given function name to the outside world. (This is done by exportSymbol function from Google Closure Compiler - but I won\u2019t go into the details). Then in your external JavaScript code you can invoke this function:</p> <p>your_namespace.core.add_numbers(1,2);</p> <p>Please, notice that all dashes were replaced by underscors. Using external JavaScript libraries</p> <p>The :advanced mode affects also invocation of the external libreries, because all functions/methods names are changed to minimal form. Lets take a ClojureScript code, that invokes PolarArea function form the Chart object:</p> <p>(defn ^:export creat-chart []   (let [ch (js/Chart.)]     (. ch (PolarArea []))))</p> <p>after compilation this code will look similar to this one:</p> <p>function(){return(new Chart).Bc(zc)}</p> <p>As you can see, the PolarArea method was changed to Bc name, which of course will cause runtime error. To prevent this, we need to tell compiler which names shouldn\u2019t be changed. Those names should be defined in external JavaScript file (i.e. externs.js) and provided to the compiler. For our example the externs.js file should look like this one:</p> <p>var Chart = {}; Chart.PolarArea = function() {};</p> <p>The compiler should be informed about this file by :externs setting in project.clj file:</p> <p>{:id \"release\"               :source-paths [\"src\"]               :compiler {                          :main blog-sc-testing.core                          :output-to \"out-adv/your-namespace.min.js\"                          :output-dir \"out-adv\"                          :optimizations :advanced                          :externs [\"externs.js\"]                          :pretty-print false}}</p> <p>If we do all those things, created JavaScript code will contain correct invocation of PolarArea function:</p> <p>function(){return(new Chart).PolarArea(Ec)}</p> <p>To get more details about using external JavaScript libraries in ClojureScript I recommend you to read excellent blog post by Luke VanderHart about this.</p>"},{"location":"clojurescript-code/#interop","title":"Interop","text":"<p>(. js/document (getElementById \"app\"))</p> <p>(.-value input)</p>"},{"location":"clojurescript-code/#coreasync-communicating-sequential-processes","title":"core.async - communicating sequential processes","text":"<ul> <li>processes</li> <li>channels</li> <li>coordination</li> </ul> <p>using core.async allows you to write sequential logic that avoids the need for callback hell of hand-crafting asyncronous coding.</p> <p>;; sudo code (str \"do something\") (send-to-channel) (str \"keep doing something\")</p> <p>;; put something on the channel (put!) (&gt;!)</p> <p>;; get something from the channel (take!) (&lt;!)</p> <p>;; go (go   (println \"Waiting...\")   (&lt;! events)   (show! \"Got an event\"))</p>"},{"location":"clojurescript-examples/","title":"Clojurescript Examples","text":""},{"location":"clojurescript-examples/buttons/","title":"Buttons","text":"<p>A button is created using the hiccup syntax.  A button is a type of input.</p> <p>TODO: what are all the button options?</p> <pre><code>(defn on-click-function []\n,,,)\n(defn reagent-component-funciton\n,,,\n  [:input {:type \"button\"\n:value \"Thumbs Up!\"\n:on-click (on-click-function)}]\n</code></pre> <p>When this button is clicked on the function <code>on-click</code> is called.</p> <p>The <code>on-click</code> function should be called after the data you are creating or changing.</p>"},{"location":"clojurescript-examples/buttons/#on-click-in-line-anonymous-function","title":":on-click in-line anonymous function","text":"<p>Instead of calling a named function, you can define an anonymous function.  The longer this anonymous function becomes, the more it should be changed to a named function.</p> <pre><code>  [:input {:type \"button\"\n:value \"Thumbs Up!\"\n:on-click (fn [] ,,,) ])\n</code></pre> <p>Or using the syntax sugar for an anonymous function you can use <code>#()</code></p> <pre><code>  [:input {:type \"button\"\n:value \"Thumbs Up!\"\n:on-click #(,,,)])\n</code></pre>"},{"location":"clojurescript-examples/buttons/#hint-use-syntax-sugar-and-anonymous-functions-sparingly","title":"Hint:: Use syntax sugar and anonymous functions sparingly","text":"<p>To keep the code as readable as possible, use named functions as the default approach for click handlers. If the on-click function is very short then its more acceptable to use an anonymous function instead.</p>"},{"location":"clojurescript-examples/forms/","title":"Forms","text":""},{"location":"clojurescript-examples/javascript-alerts/","title":"JavaScript Alerts","text":"<p>Using javascript interop you can display alert messages</p> <pre><code>(js/alert \"Alert message\")\n</code></pre>"},{"location":"clojurescript-examples/writing-to-javascript-console/","title":"Writing to the JavaScript console","text":""},{"location":"create-a-project/","title":"Create a project","text":"<p>Lets create a project called <code>todo-list</code> using Leiningen, the build automation tool for Clojure.  This project will run the simplest possible webserver.</p> <p>On the command line:</p> <pre><code>lein new todo-list\n</code></pre> <p></p>"},{"location":"create-a-project/#take-a-look-at-the-project-structure","title":"Take a look at the project structure","text":"<p>To see how our project is layed out, change into the <code>todo-list</code> directory created by this command and see the project structure that has been created.</p> <ul> <li><code>project.clj</code> - the project definition, written in Clojure </li> <li><code>src</code> for all the source code</li> <li><code>test</code> for unit test code</li> </ul> <p>Here is an example of what our project looks like using the <code>tree</code> command (you could use <code>ls -R</code> or a graphical file browser if you wish)</p> <p></p> <p>Hint Look closer at the directory hierachy and you will see something has happend to our <code>todo-list</code> name.  Unfortunately Java does not like dashes '-' in directory or file names, so Leiningen changes the directory names to <code>src/todo_list/co</code> &amp; <code>test/todo_list</code> and the initial test to <code>src/todo_list/core_test.clj</code>.</p>"},{"location":"create-a-project/add-a-webserver-function/","title":"Add a webserver","text":"<p>Use the Ring Library to create the simplest possible web server, one that will simply return a message regardless of the web page we ask for.</p> <p></p>"},{"location":"create-a-project/add-a-webserver-function/#including-ring-in-the-namespace","title":"Including Ring in the namespace","text":"<p>First make the ring library functions accessible in the namespace.  Using <code>:require</code> we can add one or more libraries to our namespace.  We can also use the <code>:as</code> keyword to specify a short-hand way of refering to a library.</p> <p>Note Delete all the code in <code>src/todo_list/core.clj</code> and replace it with the following code, adding the ring adaptor for Jetty to our project.</p> <pre><code>(ns todo-list.core\n(:require [ring.adapter.jetty :as jetty]))\n</code></pre> <p>This expression defines the current namespace as <code>todo-list.core</code>, providing a scope for all the functions and data structures we define within it.</p> <p>The <code>:require</code> expression makes the <code>ring.adaptor.jetty</code> namespace accessible within the <code>todo-list.core</code> namespace.  We can now call any of the public functions in the <code>ring.adaptor.jetty</code> namespace.  We defined an alias called <code>jetty</code> so to call the <code>run-jetty</code> function we use <code>jetty/run-jetty</code> rather than the fully qualified namespace of <code>ring.adaptor.jetty/run-jetty</code> </p> <p>You can specify any valid Clojure name for a namespace alias, however please consider the readability of your code and choose a meaningful alias.  Later in the workshop we will show other options for including functions from other namespaces.</p>"},{"location":"create-a-project/add-a-webserver-function/#add-a-main-function-to-run-jetty","title":"Add a main function to run Jetty","text":"<p>Note  Add a function called <code>-main</code> to the  <code>src/todo_list/core.clj</code> file.</p> <p>The <code>-main</code> function takes a port number as an argument which we pass when running the application.  The Ring Jetty adaptor is used to run an instance of Jetty.  The <code>-main</code> function contains an anonymous function (lambda) that takes any request and returns a response map.</p> <p>A response map contains the following key / value pairs   * <code>:status</code> - the result of the request, eg. 200 OK, 401 Not Found, etc    * <code>:body</code> - the content to be returned (web page, json, etc)   * <code>:headers</code> - a map of standard headers included in any web browser response </p> <pre><code>(defn -main\n\"A very simple web server using Ring &amp; Jetty\"\n[port-number]\n(jetty/run-jetty\n(fn [request] {:status 200\n:body \"&lt;h1&gt;Hello, Clojure World&lt;/h1&gt;  &lt;p&gt;Welcome to your first Clojure app.  This message is returned regardless of the request, sorry&lt;/p&gt;\"\n:headers {}})\n{:port (Integer. port-number)}))\n</code></pre> <p>Hint Using a <code>-</code> at the start of the <code>-main</code> function is a naming convention, helping you see which function is the entry point to your program.  Leiningen also looks for this -main function by default when running your application.</p> <p>The <code>Integer.</code> function is a call to <code>java.lang.Integer</code>.  The <code>.</code> is a special form that tells Clojure to treat this name as a call to Java.  See coersing types and java.lang</p> <p>The <code>jetty/run-jetty</code> function takes two arguments.  In our example, the first argument is an anonymous function that returns a map (the response to the browser request);  the second argument is a port number to run the jetty server on expressed as a Java Integer object.</p>"},{"location":"create-a-project/add-a-webserver-function/#the-complete-code-for-the-web-server","title":"The complete code for the web server","text":"<p>The code in <code>src/todo_list/core.clj</code> should now look like this:</p> <pre><code>(ns todo-list.core\n(:require [ring.adapter.jetty :as jetty]))\n(defn -main\n\"A very simple web server using Ring &amp; Jetty\"\n[port-number]\n(jetty/run-jetty\n(fn [request] {:status 200\n:body \"&lt;h1&gt;Hello, Clojure World&lt;/h1&gt;  &lt;p&gt;Welcome to your first Clojure app.  This message is returned regardless of the request, sorry&lt;p&gt;\"\n:headers {}})\n{:port (Integer. port-number)}))\n</code></pre>"},{"location":"create-a-project/add-ring-dependency/","title":"Add Ring Dependency","text":"<p>As we are using the Ring library for our Clojure project we need to add that library as a dependency.  Just like other build tools (i.e. Maven, Gradle) we include this dependency in our build file, <code>project.clj</code></p> <p>Note Edit the <code>project.clj</code> file and add the ring dependency.  For bonus points write a simple description of the project</p> <pre><code>(defproject todo-list \"0.1.0-SNAPSHOT\"\n:description \"A simple webapp using Ring\"\n:url \"http://example.com/FIXME\"\n:license {:name \"Eclipse Public License\"\n:url \"http://www.eclipse.org/legal/epl-v10.html\"}\n:dependencies [[org.clojure/clojure \"1.7.0\"]\n[ring \"1.4.0\"]])\n</code></pre> <p>Hint Read the dependencies secion of the Leiningen documentation to learn more about adding libraries.</p>"},{"location":"create-a-project/add-ring-dependency/#looking-up-libraries-current-versions","title":"Looking up Libraries &amp; current versions","text":"<p>There are a large number of Clojure libraries available via Clojars.org, an online repository similar to Maven Central.  </p> <p>To look up the latest version of a library, visit the Clojars.org website and search for the library name.</p> <p></p> <p>The dependency notation for Leiningen and Maven are documented for each library.</p>"},{"location":"create-a-project/coersing-types-and-java-lang/","title":"Theory: Specifying Types &amp; java.lang","text":"<p>Clojure has types that are created dynamically when the code is compiled, with everything being represented by Java objects as its compiled to Java bitecode.   However you do not need to specify any specific types as Clojure simply infers the type and handles most type collision gracefully.  The built in collections (list, map, vector &amp; set) also support mixed types too.</p> <p>In our project we are using Jetty, a web application server written in Java.  As its Java it needs a specific type of object passed as an argument for the port number, in this case an Integer.  However, when we run the Clojure project, the argument we supply for the port number on the command line is treated as a String object.  Therefore we need to change the port number from a Java String type to an Java Integer type.</p> <p>The <code>java.lang.</code> library is part of all Clojure projects, so as we are going to create a Java Integer it makes sense to simply use the <code>Integer</code> constructor with a String argument which returns a new Integer object.</p> <p>The <code>Integer. port-number</code> Clojure code is a short-hand for calling the <code>java.lang.Integer</code> constructor.  The <code>.</code> is actually a macro in Clojure that provides a simple way to work with Java, allowing you to call Java objects as if they were Clojure functions.  In Java you would have to use the form <code>Type instance-name = new Type(argument)</code>.  In our example you would write this in Java as <code>String port = new String(port-number)</code></p> <p>Hint  From the Java 8 docs for Integer class:  <code>Integer(String s)</code> - constructs a newly allocated Integer object that represents the int value indicated by the String parameter.</p>"},{"location":"create-a-project/coersing-types-and-java-lang/#theory-its-java-objects-underneath-strings-numbers","title":"Theory: Its Java Objects underneath strings &amp; numbers","text":"<p>Strings and numbers are represented by Java objects underneath, so its convienient to use Java Classes to manipulate these simple data structures on the rare occasion you need a specific type.  </p> <p>You can see the underlying Java types in Clojure using the <code>type</code> or <code>class</code> function.  In the following example you can see the Java types for strings and numbers</p> <p></p>"},{"location":"create-a-project/configure-main-namespace/","title":"Configure main namespace","text":"<p>Note Set the default namespace for your Clojure project.</p> <p>Edit the <code>project.clj</code> file and add <code>:main todo-list.core</code> configuration option.</p> <p>Setting the default namespace will automatically call a function called <code>-main</code> when the Clojure project is run, i.e. via <code>lein run</code></p> <pre><code>(defproject todo-list \"0.1.0-SNAPSHOT\"\n:description \"A simple webapp using Ring\"\n:url \"http://example.com/FIXME\"\n:license {:name \"Eclipse Public License\"\n:url \"http://www.eclipse.org/legal/epl-v10.html\"}\n:dependencies [[org.clojure/clojure \"1.7.0\"]\n[ring \"1.4.0\"]]\n:main todo-list.core)\n</code></pre> <p>Now you are ready to run your web server.</p>"},{"location":"create-a-project/configure-main-project-function/","title":"Configure main project function","text":""},{"location":"create-a-project/namespaces/","title":"Namespace","text":"<p>A namespace in Clojure is used to manage the logical seperation of code, usually along features of the application, service or library you are developing.  A namespace contains data structures and functions, limiting their scope to that function.</p> <p>Unless otherwise defined, any function can call any other function in the namespace by just the function name.  The same is true for any naed data structures, they can be called from anywhere in the namespace with just their name.</p> <p>Hint Remember that Clojure is evaluated from top to bottom, so if you are calling a named function or data structure, it must have had its definition evaluated first.</p>"},{"location":"create-a-project/namespaces/#including-another-namespace","title":"Including another namespace","text":"<p><code>require</code> or <code>:require</code> is used to enable access to the functions &amp; named datastructures in another namespace than the current one.  </p> <pre><code>(ns my-namespace.core :require [clojure.java.io])\n(defn read-the-file [filename]\n(line-seq (clojure.java.io/reader filename)))\n(read-the-file \"project.clj\")\n</code></pre> <p>The <code>reader</code> funciton can be accessed, however, we still need to include the fully qualified namespace path, <code>clojure.java.io</code>.</p> <p>If the namespace has a long name, you can provide an alias (please use names that keep the code readable)</p> <pre><code>(ns my-namespace.core :require [clojure.java.io :as java-io])\n(defn read-the-file [filename]\n(line-seq (java-io/reader filename)))  (read-the-file \"project.clj\")\n</code></pre> <p>Or if you are going to use the function multiple times in the current namespace, you could also include that function directly, no longer requiring any kind of namespace qualifier</p> <pre><code>(ns my-namespace.core :require [clojure.java.io :as [reader]])\n(defn read-the-file [filename]\n(line-seq (reader filename)))  (read-the-file \"project.clj\")\n</code></pre> <p>Hint You may see <code>use</code> or <code>:use</code> as an alternative approach.  While this will work, it also includes everything from the other namespace into your current one.  This is seen as a bad practice, especially when writing libraries, as you can end up including a great many unused functions into the namespace.  </p> <p>As Clojure is typically composed of many libraries, its prudent to only include the specific things you need from another namespace.  This also helps reduce conflicts when including multiple libraries in your project.</p>"},{"location":"create-a-project/namespaces/#external-libraries","title":"External libraries","text":"<p>To use a library that is not part of your project you also need to include it as a dependency.  You can do this using the <code>:dependencis</code> section of the  Leiningen project file.</p> <pre><code>;; include and example dependency - eg ring, compujure\n</code></pre>"},{"location":"create-a-project/run-webserver/","title":"Run webserver","text":"<p>Note Run the webserver we use Leiningen, the Clojure build automation tool.  In the root of your Clojure project, the directory that contains <code>project.clj</code></p> <p>In a command line terminal, navigate to the root of your project and type the following command</p> <pre><code>lein run 8000\n</code></pre> <p>This command should start up a Jetty web server that listens on http://localhost:8000.</p> <p></p> <p>Note Open http://localhost:8000 in your browser and try out different pages, such at /hello,  /goodbye or  /complete-indifference.  It should not matter what page you visit, you should get the same response.</p> <p></p>"},{"location":"create-a-project/run-webserver/#the-project-so-far","title":"The project so far","text":"<p>The code and configuration we have created so far are in the clojure-webapps-example github repository, specifically the branch called <code>01-create-a-webserver</code></p> <p>If something is not working or you want to speed up, simply clone the project into a new directory using the command:</p> <p><pre><code>git clone https://github.com/practicalli/clojure-webapps-example </code></pre> Once you have cloned the project, checkout the <code>01-create-a-webserver</code> branch</p> <pre><code>git checkout 01-create-a-webserver\n</code></pre>"},{"location":"css/bulma/","title":"Bulma CSS library","text":"<p>A simple and clean Cascading Style Sheet (CSS) library used to create professional looking websites.</p> <p>Bulma is a CSS only framework (no JavaScript) that provides a range of easy to apply styles using meaningful style names.  Its quite lightweight and therefore fast to load along with your website.</p> <p>Bulma is compatible with all icon font libraries, eg. Font Awesome, Material Design, Ionicons, etc.  Practicalli uses FontAwesome icon library to add common logos such at GitHub.</p> <p>The Bulma library can be included via static html files, templates or via ClojureScript code.</p>"},{"location":"css/bulma/#hintuse-a-content-delivery-network","title":"Hint::Use a Content Delivery Network","text":"<p>Bulma start documentation shows how to use the Bulma library from a Content Deliver Network (CDN).  A CDN avoids the need to download and update a local copy of the Bulma CSS code.</p> <p>Downloading Bulma is only useful if editing or extending Bulma itself or need to use Bulma with a custom CSS or Sass development workflow (or there is a limited network connection)</p>"},{"location":"css/bulma/#including-in-static-html-file","title":"Including in static html file","text":"<p>Add Bulma CSS and FontAwesome icons to a Figwheel-main template project web page using a Content Deliver Network (CDN) hosted file</p> <p>Edit the <code>resources/public/index.html</code> file</p> <p>Add the following line of code inside the <code>&lt;head&gt;</code> tag:</p> <pre><code>&lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css\"&gt;\n&lt;script defer src=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css\"&gt;&lt;/script&gt;\n</code></pre> <p>The Practicalli Landing page index.html file is a complete example, including a totally unnecessary page loading indicator, as well as more useful JavaScript function to activate the Bulma CSS 'burger' menu displayed on smaller screens (tablets, smartphones, etc.).</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=\"UTF-8\"&gt;\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n&lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css\"&gt;\n&lt;script defer src=\"https://use.fontawesome.com/releases/v5.8.1/js/all.js\"&gt;&lt;/script&gt;\n&lt;link href=\"css/style.css\" rel=\"stylesheet\" type=\"text/css\"&gt;\n&lt;link rel=\"icon\" href=\"https://clojurescript.org/images/cljs-logo-icon-32.png\"&gt;\n&lt;!-- &lt;link rel=\"stylesheet\" href=\"css/debug.css\" /&gt; --&gt;\n&lt;/head&gt;\n&lt;!-- Fix navigation menu to top of page --&gt;\n&lt;body class=\"has-navbar-fixed-top\"&gt;\n&lt;div id=\"app\"&gt;\n&lt;div class=\"container\"&gt;\n&lt;h1 class=\"title is-1\"&gt;Loading the application, hold on tight!&lt;/h1&gt;\n&lt;!-- Totally redundant page loading progress indicator --&gt;\n&lt;progress class=\"progress is-large is-primary\" max=\"100\"&gt;&lt;/progress&gt;\n&lt;/div&gt;\n&lt;/div&gt; &lt;!-- end of app div --&gt;\n&lt;script src=\"cljs-out/dev-main.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n&lt;!-- Script for Bulma hamburger menu --&gt;\n&lt;!-- https://www.adam-bray.com/2018/04/03/responsive-bulma-css-navigation-bar/ --&gt;\n&lt;script&gt;\n(function() {\nvar burger = document.querySelector('.burger');\nvar nav = document.querySelector('#'+burger.dataset.target);\nburger.addEventListener('click', function(){\nburger.classList.toggle('is-active');\nnav.classList.toggle('is-active');\n});\n})();\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"css/bulma/#bulma-via-clojure-hiccup-code","title":"Bulma via Clojure Hiccup code","text":"<p>Generate html code from ClojureScript using the hiccup style syntax.</p> <pre><code>[:link {:rel \"stylesheet\"\n:href \"https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css\"}]\n[:script {:defer true\n:src \"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css\"}]\n</code></pre>"},{"location":"figwheel/client-side-config/","title":"Client-side Config","text":"<p>Make sure you have setup an html file to host your cljs. For example you can create this <code>resources/public/index.html</code> file:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=\"main-area\"&gt;\n&lt;/div&gt;\n&lt;script src=\"js/example.js\" type=\"text/javascript\"&gt;&lt;/script&gt;   \n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"figwheel/client-side-config/#client-side-configuration-options","title":"Client side configuration options","text":"<p>Instead of setting <code>:figwheel true</code> in your cljsbuild configuration you can pass a map of options as below:</p> <pre><code>:cljsbuild {\n:builds [ { :id \"example\" :source-paths [\"src/\"]\n;; put client config options in :figwheel\n:figwheel { :websocket-host \"localhost\" :on-jsload \"example.core/fig-reload\"}\n:compiler {  :main \"example.core\"\n:asset-path \"js/out\"\n:output-to \"resources/public/js/example.js\"\n:output-dir \"resources/public/js/out\"\n:optimizations :none } } ]\n}\n</code></pre> <p>The following configuration options are available:</p> <pre><code>;; configure a websocket host, figwheel already knows the port\n;; this is helpful if you want to broadcast to devices\n:websocket-host \"localhost\" ;; or \"www.myhost.com\", \"192.168.0.112\"\n;; An important configuration option for :websocket-host\n;; if you set it to :js-client-host it will set the host based on the\n;; js/location.host param of the browser\n;; This is helpful for multiple device settings where you are using\n;; fighweel to serve your app.\n;; :websocket-host :js-client-host\n;; optional callback\n:on-jsload \"example.core/fig-reload\"\n;; if you want to do REPL based development and not have\n;; have compiled files autoloaded into the client env\n:autoload false\n;; The heads up display is enabled by default to disable it: \n:heads-up-display false\n;; when the compiler emits warnings figwheel blocks the loading of files.\n;; To disable this behavior:\n:load-warninged-code true\n</code></pre> <p>Whole files will be reloaded on change so we have to make sure that we write reloadable code.</p> <p>Please check out the example project in the <code>example</code> directory.</p> <p>To see all the client side config options look here.</p>"},{"location":"figwheel/client-side-use/","title":"Client-side use","text":""},{"location":"figwheel/clojurescript-repl/","title":"ClojureScript REPL","text":""},{"location":"figwheel/configure-build/","title":"Configure Build","text":"<p>You also need to have your <code>:cljsbuild</code> configuration set up in your <code>project.clj</code>.</p> <p>Here is an example:</p> <pre><code>:cljsbuild {\n:builds [ { :id \"example\" :source-paths [\"src/\"]\n:figwheel true\n:compiler {  :main \"example.core\"\n:asset-path \"js/out\"\n:output-to \"resources/public/js/example.js\"\n:output-dir \"resources/public/js/out\" } } ]\n}\n</code></pre> <p>The important part here is that you have to have at least one <code>build</code> that has <code>:optimizations</code> set to <code>:none</code> or <code>nil</code>.</p> <p>If you leave out the <code>:optimizations</code> key the ClojureScript compiler will default to <code>:none</code>.</p> <p>Setting <code>:figwheel true</code> or <code>:figwheel { :on-jsload \"example.core/reload-hook\" }</code> will automagically insert the figwheel client code into your application.  If you supply <code>:on-jsload</code> the name of a function, that function will be called after new code gets reloaded.</p> <p>Hint If you want to serve the HTML file that will host your application from figwheel's built in server, then the output directory has to be in a directory that can be served by the static webserver. The default for the webserver root is \"resources/public\" so your output files need to be in a subdirectory \"resources/public\" unless you change the webserver root. For now the webserver root has to be in a subdirectory of <code>resources</code>.</p> <p>If you are serving your application HTML from your own server you can configure <code>:output-to</code> and <code>:output-dir</code> as you like.</p> <p>Start the figwheel server. (This will get the first <code>:optimizations</code> <code>:none</code> build)</p> <pre><code>$ lein figwheel\n</code></pre> <p>or optionally give the name of the build</p> <pre><code>$ lein figwheel example\n</code></pre> <p>This will start a server at <code>http://localhost:3449</code> with your resources being served via the compojure <code>resources</code> ring handler.</p> <p>So you can load the HTML file thats hosting your ClojureScript app by going to <code>http://localhost:3449/&lt;yourfilename&gt;.html</code></p> <p>If you are using your own server please load your app from that server.</p>"},{"location":"figwheel/editor-repls-nrepl/","title":"Editor REPLs &amp; nREPL","text":"<p>You may want a REPL in your editor. This makes it much easier to ship code from your buffer to be evaluated.</p> <p>If you use <code>lein repl</code> or something that invokes it like CIDER, you are using nREPL. A ClojureScript REPL will not just run over an nREPL connection without Piggieback.</p> <p>If you are just starting out I would use the Figwheel console REPL because it's aready set up and ready to go, complexity conquered!</p> <p>If you want to integrate a REPL into your editor, here are my top recommendations:</p> <p>Emacs: * use <code>inf-clojure</code> as described on the wiki page * alternatively use Cider and nREPL. Using the ClojureScript REPL over an nREPL connection is considered advanced</p> <p>Cursive: use the instructions on the wiki page</p> <p>Vi: use <code>tmux</code> mode to interact with the figwheel REPL, still trying to get a wiki page for this if you can help that would be great</p> <p>If you are going to use nREPL with Figwheel please see:</p> <p>Using Figwheel within NRepl</p>"},{"location":"figwheel/features/","title":"Features","text":""},{"location":"figwheel/features/#broadcasting-to-multiple-repls","title":"Broadcasting to multiple REPLs","text":"<p>Figwheel broadcasts changes to all connected clients. This means you can see code and CSS changes take place in real time on your phone and in your laptop</p> <p>Its possible to run multiple browser REPLs by connecting a new browser to figwheel, by visiting http://localhost:3449/</p> <p>This allows you to run dev and test repl's side by side.</p> <p>For the test repl, Figwheel shows a test results indicator in the browser tab.  If all the tests pass, a green square is shown.  If one or more tests fail, a red square is shown.</p>"},{"location":"figwheel/file-reloads/","title":"File Reloads","text":"<p>Figwheel normally reloads any file that has changed. If you want to prevent certain files from being reloaded by figwheel, you can add meta-data to the namespace declaration like so:</p> <pre><code>(ns ^:figwheel-no-load example.core)\n</code></pre> <p>Figwheel will not load or reload files that haven't been required by your application. If you want to force a file to be loaded when it changes add the follwoing meta-data the namespace declaration of the file:</p> <pre><code>(ns ^:figwheel-load example.core)\n</code></pre> <p>It can be very helpful to have a file reload every time a file changes in your ClojureScript source tree. This can facilitate reloading your main app and running tests on change.</p> <p>To force a file to reload on every change:</p> <pre><code>(ns ^:figwheel-always example.test-runner)\n</code></pre>"},{"location":"figwheel/file-reloads/#using-the-clojurescript-repl","title":"Using the ClojureScript REPL","text":"<p>When you run <code>lein figwheel</code> a REPL will be launched into your application.</p> <p>You will need to open your application in a browser in order for the REPL to connect and show its prompt.</p> <p>This REPL is a little different than other REPLs in that it has live compile information from the build process. This effectively means that you will not have to call <code>(require</code> or <code>(load-namesapce</code> unless it is a namespace that isn't in your loaded application's required dependencies. In many cases you can just <code>(in-ns 'my.namespace)</code> and everything you need to access will be there already.</p> <p>The REPL doesn't currently have built-in readline support. To have a better experience please install rlwrap. You can do this on OSX using brew: <code>brew install rlwrap</code>.</p> <p>When <code>rlwrap</code> is installed you can now execute lein figwheel as so:</p> <pre><code>$ rlwrap lein figwheel\n</code></pre> <p>This will give you a much nicer REPL experience with history and line editing.</p>"},{"location":"figwheel/flappy-birds-demo/","title":"Figwheel Demo","text":"<p>Clone the flappy bird demo from Github:</p> <pre><code>git clone https://github.com/bhauman/flappy-bird-demo.git\n</code></pre> <p>Change into the <code>flappy-bird-demo</code> directory on the command line and run:</p> <pre><code>lein figwheel\n</code></pre> <p>In your browser, open <code>http://localhost:3449/index.html</code> and once flappy birds has loaded, open your browsers development tools / console </p> <p>In your editor, open <code>src/flappy_bird_demo/core.cljs</code> and make changes to the code.</p> <p>As soon as you save your code you see the changes in the browser window.  You will also see the ClojureScript logo briefly display in the browser window, to indicate that the new changes have been added</p> <p></p> <p>Make sure you open your browser's development console so you can get feedback about code reloads.</p> <p>Hint Place your browser window and code editor window side by side so you can see the changes as you save them.  The changes should apply instantly.</p>"},{"location":"figwheel/flappy-birds-demo/#notediscover-the-basic-concept-of-figwheel-by-experimenting-with-the-flappy-birds-demo-project","title":"Note::Discover the basic concept of Figwheel by experimenting with the flappy birds demo project","text":""},{"location":"figwheel/flappy-birds-demo/#suggested-changes","title":"Suggested changes","text":"<p>Try and change some of the following aspects of the game</p> <ul> <li>the Start and Restart button names</li> <li>remove the start button</li> <li>the size and speed of the birds bounce (based on a sine wave)</li> <li>the jump velocity of the bird</li> <li>turn off collision detection</li> <li>stop the rendering of the pillars</li> <li>the gap between the pillars</li> </ul> <p>Some suggested changes have been added to a Github Gist of the ClojureScript code.</p>"},{"location":"figwheel/re-loadable-code/","title":"Re-loadable Code","text":"<p>This plugin starts a ClojureScript auto builder, opens a websocket and starts static file server. When you save a ClojureScript file, Figwheel will detect that and compile it and other affected files. It will then pass a list of those changed files off to the figwheel server. The figwheel server will in turn push the paths of the relevant compiled javascript files through a websocket so that the browser can reload them.</p> <p>The main motivation for lein-figwheel is to allow for the interactive development of ClojureScript. Figwheel doesn't provide this out of the box, the developer has to take care to make their code reloadable. </p>"},{"location":"figwheel/re-loadable-code/#writing-reloadable-code","title":"Writing reloadable code","text":"<p>Figwheel relies on having files that can be reloaded. </p> <p>Reloading works beautifully on referentially transparent code and code that only defines behavior without bundling state with the behavior. </p> <p>If you are using React or Om it's not hard to write reloadable code, in fact you might be doing it already.</p> <p>There are several coding patterns to look out for when writing reloadable code. </p> <p>One problematic pattern is top level definitions that have local state.</p> <pre><code>(def state (atom {}))\n</code></pre> <p>The <code>state</code> definition above is holding an atom that has local state. Every time the file that holds this definition gets reloaded the state definition will be redefined and the state it holds will be reset back to the original state. But with figwheel we are wanting to change our programs while maintaining the state of the running program.</p> <p>The way to fix this is to use <code>defonce</code></p> <pre><code>(defonce state (atom {}))\n</code></pre> <p>This will fix most situations where you have code that is relying on a definition that has local state. Keep in mind though that if you change the code that is wrapped in a <code>defonce</code> you won't see the changes, because the identifier won't be redefined.</p> <p>Complicated object networks wired together with callbacks (Backbone, Ember, etc.) are also problematic. Instantiating these object callback networks and then storing them in a global var is yet another version of this problem.</p> <p>Functions that maintain local state like counters and such are also definitions with local state, and as such are problematic.</p> <p>You also need to look out for common setup code that hooks into the browser.</p> <p>Often you will see statements like this at the bottom of a file.</p> <pre><code>(.click ($ \"a.button\") (fn [e] (print \"clicked button\")))\n</code></pre> <p>Every time this file gets loaded a new listener will get added to all the anchor tags with a \"button\" class. This is obviously not what we want to happen.</p> <p>This code is very problematic and points to the why using the browser APIs directly has always been really difficult. For instance if we make it so that these hooks are only executed once, like so:</p> <pre><code>(defonce setup-stuff (do \n(.click ($ \"a.button\") (fn [e] (print \"clicked button\")))))\n</code></pre> <p>When you are live editing code, this doesn't work very well. If you alter your HTML template any new \"a.button\" elements aren't going to have the listener bound to them.</p> <p>You can fix this by using an event delegation strategy as so:</p> <pre><code>(defonce setup-stuff (do \n(.on ($ \"div#app\") \"click\" \"a.button\" (fn [e] (print \"clicked button\")))))\n</code></pre> <p>But even with the above strategy you won't be able to edit any of the code in the setup up block and see your changes take affect.</p> <p>If you are not using React and you want to build things this way and have reloadable code we need to create <code>setup</code> and <code>teardown</code> functions to be invoked on code reload.  </p> <pre><code>(defn setup []\n(.on ($ \"div#app\") \"click\" \"a.button\" (fn [e] (print \"clicked button\"))))\n(defn teardown []\n(.off ($ \"div#app\") \"click\" \"a.button\")\n;; define a reload hook in the\n(defn fig-reload-hook []\n(teardown)\n(setup))\n</code></pre> <p>Now you can edit the code in the setup and teardown functions and see the resulting changes in your application.</p> <p>In a way you can think of the previous definitions of <code>setup-stuff</code> as functions that have local state of sorts. They are altering and storing callbacks in the DOM directly and this is why it is so problematic.</p> <p>This is one of the reasons React is so damn brilliant. You never end up storing things directly in the DOM. State is mediated and managed for you. You just describe what should be there and then React takes care of making the appropriate changes. For this reason React is a prime candidate for writing reloadable code. React components already have a lifecycle protocol that embeds <code>setup</code> and <code>teardown</code> in each component and invokes them when neccessary.</p> <p>It is worth repeating that React components don't have local state, it just looks like they do. You have to ask for the local state and React in turn looks this state up in a larger state context and returns it, very similar to a State Monad.</p> <p>Reloadable code is easy to write if we are very conscious and careful about the storage of state, state transitions and side effects. Since a great deal of programming complexity stems from complex interactions (side effecting events) between things that have local state, it is my belief that reloadable code is often simply better code.</p>"},{"location":"figwheel/repl-control/","title":"REPL Control","text":"<p>The Figwheel REPL has the following control functions:</p> <pre><code>Figwheel Controls:\n (stop-autobuild)            ;; stops Figwheel autobuilder\n (start-autobuild [id ...])  ;; starts autobuilder focused on optional ids\n (switch-to-build id ...)    ;; switches autobuilder to different build\n (reset-autobuild)           ;; stops, cleans, and starts autobuilder\n (build-once [id ...])       ;; builds source one time\n (clean-builds [id ..])      ;; deletes compiled cljs target files\n (fig-status)                ;; displays current state of system\n</code></pre> <p>These functions are special functions that poke through the ClojureScript env into the underlying Clojure process. As such you can't compose them.</p> <p>You can think of these functions having an implicit set of build ids that they operate on.</p> <p>If you call <code>(reset-autobuild)</code> it will stop the figwheel autobuilder, clean the builds, reload the build configuration from your <code>project.clj</code> and then restart the autobuild process.</p> <p>If you call <code>(stop-autobuild)</code> it will stop the figwheel autobuilder.</p> <p>If you call <code>(start-autobuild)</code> it will start the figwheel autobuilder with the current implicit build ids.</p> <p>If you call <code>(start-autobuild example)</code> it will start the figwheel autobuilder on the provided build id <code>example</code>. It will also make <code>[example]</code> the implicit set of build ids.</p> <p><code>start-autobuild</code> and <code>switch-to-build</code> are the only functions that update the build-id set.</p> <p><code>clean-builds</code> and <code>build-once</code> both allow you to do one off builds and cleans.  They do not alter the implicit build ids.</p> <p><code>fig-status</code> displays information on the current Figwheel system state, including whether the autobuilder is running, which build ids are in focus, and the number of client connections.</p>"},{"location":"figwheel/scripting-figwheel/","title":"Scripting Figwheel","text":"<p>As your development workflow grows in complexity, the declarative approach of <code>lein</code> can be limiting when you want to launch and control different services (ie. SASS compilation). It is really helpful to use Clojure itself to script whatever workflow services you want.</p> <p>Figwheel has a Clojure API that makes it easy to start, stop and control Figwheel from Clojure.</p> <p>In order for the following examples to work, you will need to have <code>[figwheel-sidecar \"0.5.0-2\"]</code> in your dependencies.</p> <p>To start Figwheel from a script, you will need to require the <code>figwheel-sidecar.repl-api</code> and provide your build configuration to <code>figwheel-sidecar.repl-api/start-figwheel!</code> like so:</p> <pre><code>(require '[figwheel-sidecar.repl-api :as ra])\n;; this will start figwheel and will start autocompiling the builds specified in `:builds-ids`\n(ra/start-figwheel!\n{:figwheel-options {} ;; &lt;-- figwheel server config goes here \n:build-ids [\"dev\"]   ;; &lt;-- a vector of build ids to start autobuilding\n:all-builds          ;; &lt;-- supply your build configs here\n[{:id \"dev\"\n:figwheel true\n:source-paths [\"src\"]\n:compiler {:main \"example.core\"\n:asset-path \"out\"\n:output-to \"resources/public/main.js\"\n:output-dir \"resources/public/out\"\n:verbose true}}]})\n;; you can also just call (ra/start-figwheel!)\n;; and figwheel will do its best to get your config from the\n;; project.clj or a figwheel.edn file\n;; start a ClojureScript REPL\n(ra/cljs-repl)\n;; you can optionally supply a build id\n;; (ra/cljs-repl \"dev\")\n</code></pre> <p>Build config notes</p> <p>It's important to remember that figwheel can autobuild and reload  multiple builds at the same time. It can also switch between builds  and focus on autobuilding one at a time. For this reason you need  to supply the initial <code>:build-ids</code> to tell figwheel which builds  you want to start building. It's also really helpful to supply your  <code>:advanced</code> builds because while you can't autobuild them you can  call <code>build-once</code> on them</p> <p>Assuming the above script is in <code>script/figwheel.clj</code> you can invoke it as follows:</p> <pre><code>$ rlwrap lein run -m clojure.main script/figwheel.clj\n</code></pre> <p>The above command will start figwheel and it will behave just like running <code>lein figwheel</code>.</p> <p>Please note that the above command is not running the script in the same environment as <code>lein repl</code> or <code>cider-jack-in</code>. Both of these start an nREPL session. I am intentionally not using nREPL in order to remove a lot of complexity from ClojureScript REPL communication.</p> <p>If you are using nREPL, launching the ClojureScript REPL requires that you have Piggieback installed. Please see the section above titled \"Editor REPLs and nREPL\"</p> <p>Let's make a small helper library and then initialize a Clojure REPL with it:</p> <pre><code>(require\n'[figwheel-sidecar.repl-api :as ra])\n(defn start []\n(ra/start-figwheel!\n{:figwheel-options {} ;; &lt;-- figwheel server config goes here \n:build-ids [\"dev\"]   ;; &lt;-- a vector of build ids to start autobuilding\n:all-builds          ;; &lt;-- supply your build configs here\n[{:id \"dev\"\n:figwheel true\n:source-paths [\"src\"]\n:compiler {:main \"example.core\"\n:asset-path \"out\"\n:output-to \"resources/public/main.js\"\n:output-dir \"resources/public/out\"\n:verbose true}}]}))\n;; Please note that when you stop the Figwheel Server http-kit throws\n;; a java.util.concurrent.RejectedExecutionException, this is expected\n(defn stop []\n(ra/stop-figwheel!))\n(defn repl []\n(ra/cljs-repl))\n</code></pre> <p>The next line will call <code>clojure.main</code> and initialize it with our script and then continue on to launch a REPL.</p> <pre><code>$ rlwrap lein run -m clojure.main --init script/figwheel.clj  -r\n</code></pre> <p>After the Clojure REPL has launched, you will now have the ability to call <code>(start)</code>, <code>(repl)</code> and <code>(stop)</code> as you need.</p> <p>You can also call all of the functions in the figwheel-sidecar.repl-api.</p> <p>This is a powerful way to work, as you now have the interactivity and generality of the Clojure programming language available.</p> <p>Need to start a server? Go for it.Need to watch and compile SASS files? No problem.</p>"},{"location":"figwheel/scripting-with-component/","title":"Scripting with Component","text":"<p>I highly recommend Stuart Sierra's component library to compose all the services you will need in your development process.</p> <p>Here is an example of creating a Figwheel component and composing it with a Ring server component to serve your application.</p> <pre><code>(require\n'[figwheel-sidecar.repl-api :as ra]\n'[com.stuartsierra.component :as component]\n'[ring.component.jetty :refer [jetty-server]])\n(def figwheel-config\n{:figwheel-options {} ;; &lt;-- figwheel server config goes here \n:build-ids [\"dev\"]   ;; &lt;-- a vector of build ids to start autobuilding\n:all-builds          ;; &lt;-- supply your build configs here\n[{:id \"dev\"\n:figwheel true\n:source-paths [\"src/main\"]\n:compiler {:main \"example.core\"\n:asset-path \"/out\"\n:output-to \"resources/public/main.js\"\n:output-dir \"resources/public/out\"\n:verbose true}}]})\n(defrecord Figwheel []\ncomponent/Lifecycle\n(start [config]\n(ra/start-figwheel! config)\nconfig)\n(stop [config]\n;; you may want to restart other components but not Figwheel\n;; consider commenting out this next line if that is the case\n(ra/stop-figwheel!)\nconfig))\n(defn handler [request]\n{:status  200\n:headers {\"Content-Type\" \"text/plain\"}\n:body    \"Hello World\"})\n(def system\n(atom\n(component/system-map\n:app-server (jetty-server {:app {:handler handler}, :port 3000})\n:figwheel   (map-&gt;Figwheel figwheel-config))))\n(defn start []\n(swap! system component/start))\n(defn stop []\n(swap! system component/stop))\n(defn reload []\n(stop)\n(start))\n(defn repl []\n(ra/cljs-repl))\n</code></pre> <p>Again you can run this script as so:</p> <pre><code>$ rlwrap lein run -m clojure.main --init script/figwheel.clj  -r\n</code></pre> <p>As you can see with humble beginnings you can build up arbitrary functionality.</p> <p>Please see Daniel Szmulewicz's excellent system which is a set of helpful components</p> <p>If you are using nREPL, launching the ClojureScript REPL requires that you have Piggieback installed. Please see the section above titled \"Editor REPLs and nREPL\"</p> <p>Please note that when you stop the Figwheel server, http-kit throws a <code>java.util.concurrent.RejectedExecutionException</code>, this is expected</p> <p>Read more about the <code>clojure.main</code> command line options</p> <p>Read more about component</p>"},{"location":"figwheel/server-side-config/","title":"Server-side Config","text":"<p>This is not neccessary but you can configure the figwheel system. At the root level of your <code>project.clj</code> you can add the following server side configuration parameters:</p> <pre><code>:figwheel {\n:http-server-root \"public\" ;; this will be in resources/\n:server-port 3449          ;; default\n:server-ip   \"0.0.0.0\"     ;; default\n;; CSS reloading (optional)\n;; :css-dirs has no default value \n;; if :css-dirs is set figwheel will detect css file changes and\n;; send them to the browser\n:css-dirs [\"resources/public/css\"]\n;; Server Ring Handler (optional)\n;; if you want to embed a ring handler into the figwheel http-kit\n;; server\n:ring-handler example.server/handler\n;; Clojure Macro reloading\n;; disable clj file reloading\n; :reload-clj-files false\n;; or specify which suffixes will cause the reloading\n; :reload-clj-files {:clj true :cljc false}\n;; To be able to open files in your editor from the heads up display\n;; you will need to put a script on your path.\n;; that script will have to take a file path and a line number\n;; ie. in  ~/bin/myfile-opener\n;; #! /bin/sh\n;; emacsclient -n +$2 $1\n;;\n:open-file-command \"myfile-opener\"\n;; if you want to disable the REPL\n;; :repl false\n;; to configure a different figwheel logfile path\n;; :server-logfile \"tmp/logs/figwheel-logfile.log\" \n;; Start an nREPL server into the running figwheel process\n;; :nrepl-port 7888\n;; Load CIDER, refactor-nrepl and piggieback middleware\n;;  :nrepl-middleware [\"cider.nrepl/cider-middleware\"\n;;                     \"refactor-nrepl.middleware/wrap-refactor\"\n;;                     \"cemerick.piggieback/wrap-cljs-repl\"]\n} </code></pre>"},{"location":"figwheel/using-figwheel/","title":"Using Figwheel","text":"<p>If you are new to Figwheel here is a Quick Start tutorial. Working through this Quick Start will probably save you a tremendous amount of time.</p>"},{"location":"figwheel/using-figwheel/#usage","title":"Usage","text":"<p>Make sure you have the latest version of leiningen installed.</p> <p>Then include the following <code>:dependencies</code> in your <code>project.clj</code> file.</p> <pre><code>[org.clojure/clojure \"1.7.0\"]\n[org.clojure/clojurescript \"1.7.170\"]\n</code></pre> <p>Then include <code>lein-figwheel</code> in the <code>:plugins</code> section of your project.clj.</p> <pre><code>[lein-figwheel \"0.5.0-3\"]\n</code></pre>"},{"location":"figwheel-main/","title":"Figwheel","text":"<p>Figwheel-main build tool and Rebel rich terminal UI is a simple way to get started with ClojureScript development</p> <p>The figwheel-main template creates a project with Clojure CLI configuration, providing example code and build configurations for development, testing and deployment workflows which are explored in some detail.</p>"},{"location":"figwheel-main/#overview","title":"Overview","text":"<p>Using Figwheel provides an simple way to develop, test and deploy ClojureScript projects, providing instant feedback as you develop to see exactly what the code does and help minimise bugs and avoid inappropriate design choices.</p> <p>Add aliases and build configurations customise the workflows for greater flexibility.  The configuration files are EDN, so are Clojure maps that are simple to work with and understand.</p> <p>There are more examples of options for figwheel-main projects on the https://figwheel.org/ website.</p> <p>lambdaisland/kaocha-cljs enables using kaocha test runner with ClojureScript project, although I am still working on an example once I've resolved an issue with the configuration</p> <p></p>"},{"location":"figwheel-main/build-project/","title":"Running figwheel and building the project","text":"<p>Calling figwheel with a build configuration compiles the project ClojureScript code into JavaScript as figwheel starts.  The JavaScript code is sent to the JavaScript engine in the browser window that figwheel opened.</p> <p>Saved changes to the project ClojureScript files will automatically generate updates to the JavaScript code and send them to the JavaScript engine in the browser.</p> <p>The <code>:build</code> alias is used during development of a ClojureScript project</p> <pre><code>clojure -M:fig:build\n</code></pre> <p></p> <p>The <code>:build</code> alias defines <code>figwheel.main</code> as the main namespace and the arguments passed to the <code>-main</code> function in that namespace. <code>\"-b\" \"dev\"</code> will used <code>dev.cljs.edn</code> as the configuration, <code>-r</code> option to run a REPL prompt (in this case using Rebel)</p> <p><code>:build {:main-opts [\"-m\" \"figwheel.main\" \"-b\" \"dev\" \"-r\"]}</code></p> <p>This configuration is the equivalent of running the command <code>clojure -M:fig -m figwheel.main -b dev -r</code></p>"},{"location":"figwheel-main/check-configuration/","title":"Check figwheel configuration","text":"<p>Ensure figwheel is configured correctly by calling <code>figwheel.main</code> without a build configuration.  The ClojureScript code for the project is not compiled so cannot be the cause of any failure or warnings.</p> <p>This is quick way to identify if issues are from figwheel configuration or from ClojureScript code.</p> <pre><code>clojure -M:fig -m figwheel.main\n</code></pre> <p>A web browser window will open showing the figwheel website, contains the fundamental documentation for developing with Figwheel.</p> <p></p>"},{"location":"figwheel-main/continuous-testing/","title":"Continuous testing during development","text":"<p>Running a figwheel-main build includes continuous testing service, so you can instantly see the results of your tests once the application has started.</p> <pre><code>clojure -M:fig:build\n</code></pre> <p>http://localhost:9500/figwheel-extra-main/auto-testing will show the live results of running the tests.</p> <p></p> <p>You may see the auto-testing host page display before showing the test results, or if the web page is reloaded (or if your tests take a long time to run or there are no tests to run)</p> <p></p>"},{"location":"figwheel-main/create-project/","title":"Create figwheel projects","text":"<p>clj-new uses the Leiningen template format and some template developers will include project configuration for Clojure CLI. Each template designer is responsibility as to which project and build tools it supports.</p> <p>The figwheel-main template provides an option to create a Leiningen or Clojure CLI project and clj-new will create a Clojure CLI configuration by default.</p> <p>Where a template only provides a Leiningen configuration, dependencies listed in <code>project.clj</code> should be added to the <code>:deps</code> section of <code>deps.edn</code>. <code>dev-dependencies</code> in <code>project.clj</code> should be satisfied by aliases in the project or user-level <code>deps.edn</code> configuration.</p>"},{"location":"figwheel-main/create-project/#clojurescript-project-using-figwheel","title":"ClojureScript project using figwheel","text":"<p>Use the figwheel-main template to create a ClojureScript project that uses figwheel-main to manage the build.</p> <p>In a terminal, use the following command:</p> <pre><code>clojure -M:project/new figwheel-main practicalli/hello-world -- --reagent\n</code></pre> <p>The <code>:project/new</code> alias is defined in practicalli/clojure-deps-edn user-level configuration and supports <code>-M</code>, <code>-X</code> and <code>T</code> execution flags. The <code>-X</code> and <code>-T</code> flags use a command with key value arguments</p> <p><code>clojure -T:project/new :template figwheel-main :name practicalli/landing-page :args '[\"+reagent\"]'</code></p> <p>The <code>practicalli/hello-world</code> defines the main application namespace as <code>hello-world</code> and <code>practicalli</code> as the domain.</p> <p><code>--</code> after the name tells clj-new to pass the following text to the template.</p> <p><code>--reagent</code> is a template option to add reagent React-style library dependencies to the generated project. <code>--rum</code> and <code>--react</code> are other React-style libraries that could be used instead of <code>--reagent</code></p>"},{"location":"figwheel-main/package-project/","title":"Packaging the project","text":"<p>Building ClojureScript applications with Figwheel generates lots of files under <code>target/public</code>, as this is the most efficient way to push changes to the JavaScript engine application during development.  Using only a single file when deploying your application to the live system makes your application website faster to load (only one http request).</p> <p>The ClojureScript compiler has four :optimizations modes :none, :whitespace, :simple and :advanced.</p> <p>The <code>figwheel-main</code> template provides a <code>:min</code> alias to generate a single minified file that has been run through the Google Closure compiler to eliminate any uncalled code.  This generates a single file called <code>target/public/cljs-out/dev-main.js</code></p> <p>Publish the application by manually copying the file to a suitable deployment directory (or write a script to do so) when you publish your application live.</p>"},{"location":"figwheel-main/pages-deploy/","title":"Deploying to GitHub and GitLab pages","text":"<p>GitHub pages and GitLab pages provide fast and free service for running an HTML website, serving HTML, CSS and JavaScript files.</p> <p>By placing all the web pages and asset files in a <code>docs</code> directory, these services can be configured to serve those assets publicly.</p> <p>Create a new build configuration to output the single JavaScript file to the <code>docs</code> directory, typically in a <code>js</code> sub-folder or any preferred directory structure.</p> <p>Create a file called <code>pages.cljs.edn</code> to represent a new build and add the following configuration</p> <pre><code>{:main practicalli.hello-world\n:output-to \"docs/js/hello-world.js\"}\n</code></pre> <p>Edit the project <code>deps.edn</code> file and add a new alias to deploy to GitHub/GitLab pages directory</p> <pre><code>:pages {:main-opts [\"-m\" \"figwheel.main\" \"-O\" \"advanced\" \"-bo\" \"pages\"]}\n</code></pre> <p>Create the deployable JavaScript file using the following command:</p> <pre><code>clojure -M:fig:pages\n</code></pre> <p>Copy the <code>/resources/public/index.html</code> and any other web assets to the <code>/docs</code> directory and update the <code>/docs/index.html</code> to refer to the correct location of the JavaScript file generated by Figwheel.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=\"UTF-8\"&gt;\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n&lt;link href=\"css/style.css\" rel=\"stylesheet\" type=\"text/css\"&gt;\n&lt;link rel=\"icon\" href=\"https://clojurescript.org/images/cljs-logo-icon-32.png\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=\"app\"&gt;\n&lt;/div&gt; &lt;!-- end of app div --&gt;\n&lt;script src=\"js/hello-world.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>See package a single file for production for more details.</p>"},{"location":"figwheel-main/project-configuration/","title":"Project configuration","text":"<p>A new project is created in the <code>hello-world</code> directory and contains a <code>deps.edn</code> configuration</p> <pre><code> {:deps {org.clojure/clojure {:mvn/version \"1.10.0\"}\norg.clojure/clojurescript {:mvn/version \"1.11.4\"}\ncljsjs/react {:mvn/version \"17.0.2-0\"}\ncljsjs/react-dom {:mvn/version \"17.0.2-0\"}\nreagent/reagent {:mvn/version \"1.1.1\" }}\n:paths [\"src\" \"resources\"]\n:aliases {:fig {:extra-deps\n{com.bhauman/rebel-readline-cljs {:mvn/version \"0.1.4\"}\norg.slf4j/slf4j-nop {:mvn/version \"1.7.30\"}\ncom.bhauman/figwheel-main {:mvn/version \"0.2.17\"}}\n:extra-paths [\"target\" \"test\"]}\n:build {:main-opts [\"-m\" \"figwheel.main\" \"-b\" \"dev\" \"-r\"]}\n:min   {:main-opts [\"-m\" \"figwheel.main\" \"-O\" \"advanced\" \"-bo\" \"dev\"]}\n:test  {:main-opts [\"-m\" \"figwheel.main\" \"-co\" \"test.cljs.edn\" \"-m\" \"practicalli.test-runner\"]}}}\n</code></pre> <p>Aliases were added by the template to run figwheel and build the ClojureScript code:</p> <ul> <li><code>:fig</code> adds figwheel-main and rebel-readline libraries as dependencies, slf4j-nop provides a no-operation logger (suppresses default logger warning)</li> <li><code>:build</code> runs figwheel-main which generates JavaScript from the ClojureScript code in the project</li> <li><code>:min</code> creates a minified single JavaScript file for deployment</li> <li><code>:test</code> runs all tests under <code>tests/practicalli</code> directory using the figwheel-main test-runner</li> </ul> <p><code>dev.cljs.edn</code> is the build configuration referred to by the <code>:build</code> and <code>:min</code> aliases using the <code>dev</code> name</p> <pre><code>^{:watch-dirs [\"test\" \"src\"]\n:css-dirs [\"resources/public/css\"]\n:auto-testing true\n}\n{:main practicalli.hello-world}\n</code></pre> <ul> <li><code>:watch-dirs</code> defines the directories to monitor files for saved changes</li> <li><code>:css-dirs</code> defines the location of the CSS configuration</li> <li><code>:auto-testng</code> to automatically discover and run tests</li> <li><code>:main</code> defines the main namespace for the application</li> </ul>"},{"location":"figwheel-main/rebel/","title":"Rich REPL UI with Rebel","text":"<p>Figwheel will run Rebel readline to start the REPL, as the <code>:fig</code> alias includes <code>com.bhauman/rebel-readline-cljs</code> as an extra dependency.</p> <p>Rebel provides syntax highlighted code, auto-completion, commands to manage the REPL and Clojure documentation help, all within its rich command line.</p> <p></p> <p>Typing <code>:repl/help</code> as a command at the Rebel prompt shows characters are syntax highlighted. The command provides a quick reference for Rebels capabilities.</p> <p></p> <p>Evaluate expressions by typing them at the Rebel prompt and pressing <code>RET</code>, e.g. <code>(map inc [2 4 6 8])</code></p> <p>JavaScript interop code also works from the Rebel prompt, e.g. <code>(js/alert \"Notification from the command line\")</code> will display an alert in the browser.</p> <p>Practicalli Clojure provides examples of using Rebel as a rich terminal UI for the Clojure REPL</p> <p>The <code>clojure</code> command should be used to run Rebel.  The <code>clj</code> wrapper script calls <code>rlwrap</code> which conflicts with Rebel, as they are both readline tools.</p>"},{"location":"figwheel-main/run-figwheel-from-cider/","title":"Run Figwheel-main from Emacs Cider","text":"<p>Figwheel-main projects can be run from Emacs with CIDER using the <code>cider-jack-in-cljs</code> command.  The user is prompted for the build name to use.</p> <p>Emacs CIDER Jack-in with Clojure CLI projects benefits from a <code>.dir-locals.el</code> file to set the <code>:fig</code> alias (and any other aliases) and the figwheel build configuration when starting the Clojure REPL.</p> <pre><code>((clojure-mode . ((cider-preferred-build-tool          . clojure-cli)\n(cider-clojure-cli-aliases           . \":fig\")\n(cider-default-cljs-repl             . figwheel-main)\n(cider-figwheel-main-default-options . \"dev\")\n(cider-repl-display-help-banner      . nil))))\n</code></pre> <p>Use <code>cider-connect-cljs</code> to connect Emacs to a REPL (nREPL) process that is already running, i.e. via the <code>clojure -M:fig:build</code> command in the terminal.</p>"},{"location":"figwheel-main/run-tests/","title":"Running tests once","text":"<p>The <code>test</code> directory contains source code for unit tests, using a directory path matching the namespace they are testing from the <code>src</code> directory.  <code>-test</code> is added to the end of the test namespaces.  For example, if we have a source namespace of <code>practicalli.hello-world</code>, the tests would be in <code>practicalli.hello-world-test</code>.</p> <p></p> <p>Use the <code>:test</code> alias with the <code>:fig</code> alias to run the Figwheel test runner</p> <pre><code>clojure -M:fig:test\n</code></pre> <p>This will open a browser and connect to its JavaScript REPL and run the tests.</p> <p></p> <p>The results of the test run are printed to the terminal</p> <p></p> <p>Running tests this way may not be as fast as using the continuous testing approach (covered next)</p>"},{"location":"figwheel-main/run-tests/#test-configuration","title":"Test configuration","text":"<p>The <code>:test</code> alias uses the <code>test.cljs.edn</code> build configuration to start the Figwheel test runner and runs all the test namespaces under the <code>test</code> directory.</p> <p><code>:test  {:main-opts [\"-m\" \"figwheel.main\" \"-co\" \"test.cljs.edn\" \"-m\" practicalli.test-runner]}</code></p> <p>The <code>test.cljs.edn</code> build configuration defines a separate URL to open the test host page, to avoid clashing with the URL to connect to the ClojureScript application itself.</p> <pre><code>^{\n;; alternative landing page for the tests to avoid launching the application\n:open-url \"http://[[server-hostname]]:[[server-port]]/test.html\"\n;; launch tests in a headless environment - update path to chrome on operating system\n;; :launch-js [\"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\" \"--headless\" \"--disable-gpu\" \"--repl\" :open-url]\n}\n{:main practicalli.test-runner}\n</code></pre>"},{"location":"figwheel-main-projects/","title":"Figwheel Projects","text":"<p>A ClojureScript project should contain dependencies for the Clojure and ClojureScript libraries, which are managed by the build tool (Clojure CLI tools or Leiningen) just like any other dependency.</p> <p>figwheel-main provides additional tooling for REPL driven development, including live updates to the browser REPL and test runner.</p> <p>Use the <code>figwheel-main</code> template to generate a working ClojureScript project with Figwheel-main, optionally including reagent and other react.js style libraries.</p>"},{"location":"figwheel-main-projects/#figwheel-main","title":"Figwheel-main","text":"<p>Figwheel Main compiles the project when first run and creates a JavaScript application that is launched in the browser.</p> <p>On every save of ClojureScript code figwheel-main automatically compiles the changes and injects them into the JavaScript application running in the browser, providing instant feedback as the project developers.</p> <p> </p> figwheel and figwheel-main <p>figwheel is the original tool that has been replaced by figwheel-main.  The configuration between the two tools is incompatible, however, the ClojureScript code should work when migrated to a figwheel-main project configuration.</p>"},{"location":"figwheel-main-projects/#figwheel-template","title":"Figwheel template","text":"<p><code>figwheel-main</code> template creates a Clojurescript project with configuration to run the Figwheel-main build tool.</p> <p>The figwheel-main template takes several options, <code>--reagent</code>, <code>--rum</code> and <code>--om</code>, each of which creates a basic project with the respective libraries.</p> <p>The <code>--</code> between the project name and <code>--reagent</code> option ensures this option is passed to the template, rather than being passed to Leiningen itself.</p> Practicalli Clojure CLI Config <p>With Practicalli Clojure CLI config installed, a ClojureScipt project with figwheel and reagent is created with the follwoign command in a terminal <pre><code>clojure -T:project/new :template figwheel-main :name practicalli/landing-page :args '[\"--reagent\"]'\n</code></pre></p>"},{"location":"figwheel-main-projects/#working-with-editors","title":"Working with Editors","text":"<p>Clojure aware editors support ClojureScript too.</p> Run project via terminal if issues using an editor <p>Running a ClojureScript project on the command line is a quick way to ensure the ClojureScipt project works, should there be issues with the configuration of an Editor</p>"},{"location":"figwheel-main-projects/#reference","title":"Reference","text":"<ul> <li>Interactive programming Flappy Birds in ClojureScript</li> <li>Clojure West 2015 - Developing ClojureScript with Figwheel</li> </ul> Google Closure Compiler <p>ClojureScript uses the Google Closure compiler and build tools that require a Java Virtual machine.  The Google Clojure tools provide highly optimal JavaScript code and eliminates and code not called from the final build.</p> <p>Self-hosted options include Plank and Lumo.  ClojureScript Next and Bootstrapped ClojureScript FAQ elaborate on the advantages and challenges for self-hosted ClojureScript.</p>"},{"location":"figwheel-main-projects/nrepl-editors/","title":"Editor support with ClojureScript Figwheel-main projects","text":"<p>Using an editor provides the full REPL driven development experience,</p> <p>Clojure aware editors can connect to an existing REPL or start a REPL for a ClojureScript project and then connect, referred to as jack-in.</p>"},{"location":"figwheel-main-projects/nrepl-editors/#jack-in","title":"Jack-in","text":"<p>The editor will inject the required libraries as dependencies, start the REPL and connect the editor to the REPL process</p> <p>Open the ClojureScript project in the editor, a <code>.cljs</code> or <code>.edn</code> file.</p> <p>{% tabs spacemacs=\"spacemacs\", calva=\"VSCode Calva\" %}</p> <p>{% content \"spacemacs\" %}</p> <p><code>, '</code> to run the <code>sesman-start</code> command</p> <p>Select <code>cider-jack-in-cljs</code></p> <p>Select <code>figwheel-main</code></p> <p>Select the <code>dev</code> build</p> <p>{% content \"lein\" %} <code>, '</code> to run the <code>sesman-start</code> command</p> <p>Select <code>cider-jack-in-cljs</code></p> <p>Select <code>Leiningen</code></p> <p>Select the <code>dev</code> build</p> <p>{% endtabs %}</p>"},{"location":"figwheel-main-projects/nrepl-editors/#connect","title":"Connect","text":"<p>Run the project from the command line, adding in an alias that includes the libraries needed to run</p> <p><code>practicalli/clojure-deps-edn</code></p> <pre><code>clojure -M:figwheel:build:middleware/cider-cljs\n</code></pre> <p>Not sure if the :build alias is required</p> <p>Open the ClojureScript project in the editor</p> <p>Run the connect command (Cider: <code>cider-connect-cljs</code>, Calva: )</p> <p>Select <code>figwheel-main</code></p> <p>Select <code>dev</code> build</p> <p>Conjure should connect automatically when it detects a <code>.nrepl-port</code> file in the root of the project</p> <p>I've been tidying up the Practicalli ClojureScript book and deprecating much of the content (which might still work but needs reviewing).  The focus of the book over the next few months will be building websites with reagent (maybe some simple reframe) using figwheel-main.</p>"},{"location":"figwheel-main-projects/reagent/","title":"Reagent project","text":"<p>Adding <code>reagent</code> to the project is a common way to create react.js style applications, usually to create a Single Page App (SPA).  Rum and Om-next are other libraries that are used for the same type of app.</p> <p>The figwheel-main template takes several options, one of which defines if react, rum or om is added to a project.</p> <p>{% tabs deps=\"Clojure CLI project\", lein=\"Leiningen project\" %}</p> <p>{% content \"deps\" %} Create a Clojure CLI tools <code>deps.edn</code> project using the <code>:project/new</code> alias from practicalli/clojure-deps-edn  configuration, including the <code>--reagent</code> template option which adds a common library for reactive web page development</p> <p>Run this command in a terminal window</p> <pre><code>clojure -X:project/new :template figwheel-main :name practicalli/landing-page :args '[\"--reagent\"]'\n</code></pre> <p>The older form of the command to create a project is <code>clojure -M:project/new figwheel-main practicalli/landing-page -- --reagent</code></p> <p>The command will create a new directory with the project name and include the reagent library and sample code to form a simple react-style application.</p> <p>{% content \"lein\" %} Create a Leiningen <code>project.clj</code> project using the following command, including <code>--reagent</code> which is a common library for reactive web page development</p> <pre><code>lein new figwheel-main practicalli/landing-page -- --reagent\n</code></pre> <p>{% endtabs %}</p>"},{"location":"figwheel-main-projects/reagent/#run-a-clojurescript-project","title":"Run a ClojureScript project","text":"<p>Run the ClojureScript project from the command line initially to ensure that everything is working.</p> <p>The project will start a REPL and figwheel-main will launch a connected browser REPL in the default web browser.</p> <p>In the terminal window used to create the project, change into the project directory</p> <pre><code>cd landing-page\n</code></pre> <p>{% tabs depsrepl=\"Clojure CLI project\", leinrepl=\"Leiningen project\" %}</p> <p>{% content \"depsrepl\" %} Use the Clojure CLI tools to run the project using the <code>:fig</code> alias and the <code>:build</code> build task.</p> <p>Also use <code>:repl/rebel</code> alias from practicalli/clojure-deps-edn to run the ClojureScript REPL with rebel readline for a richer REPL experience.  Using the <code>:repl/rebel</code> alias before <code>:fig</code> adds the rebel-readline library dependency</p> <pre><code>clojure -M:repl/rebel:fig:build\n</code></pre> <p></p> <p>{% content \"leinrepl\" %}</p> <p>Use Leiningen to run the ClojureScript project using the <code>:fig</code> alias and the <code>:build</code> build task.</p> <pre><code>lein fig:build\n</code></pre> <p>{% endtabs %}</p> <p>A window or tab should automatically open once the project starts.  This takes a few moments, so take a few deep breaths.</p> <p></p>"},{"location":"figwheel-main-projects/reagent/#check-the-browser-connection","title":"Check the browser connection","text":"<p>Check the browser REPL is connected by evaluating a ClojureScript expression in the ClojureScript REPL.</p> <p>First create a simple altert in the browser window using JavaScript interoperability</p> <p>In the terminal at the ClojureScript REPL prompt, swap in a new value into <code>app-state</code></p> <pre><code>(js/alert \"Hello from the ClojureScript REPL\")\n</code></pre> <p>Another interesting test is to update the live state of the application. The web page title is generated from the project state, held in an atom called <code>app-state</code>.  If the value held by <code>app-state</code> is updated, then the page should automatically update.</p> <p>In the terminal at the ClojureScript REPL prompt, require the <code>practicalli.landing-page</code> namespace to load the ClojureScript code.  Then switch in to the <code>practicalli.landing-page</code> namespace and finally swap a new value into the <code>app-state</code></p> <pre><code>(require 'practicalli.landing-page)\n(in-ns 'practicalli.landing-page)\n(swap! app-state assoc :text \"Hello from the REPL\")\n</code></pre> <p></p> <p>As soon as the <code>swap!</code> expression is evaluated, the web page for the project is automatically updated.</p> <p></p> <p>Add the <code>swap!</code> expression as a rich comment block to the <code>src/practicalli/landing_page.cljs</code> source code file.</p> <pre><code>(comment\n(swap! app-state assoc :text \"Hello from the REPL\")\n)\n</code></pre>"},{"location":"figwheel-main-projects/simple/","title":"Simple project","text":"<p>This is a simple ClojureScript project with no additional application dependencies.  The project uses figwheel-main as a ClojureScript development tool, for live loading of changes into the browser and also for building the projects with different configurations.</p> <p>{% tabs deps=\"Clojure CLI project\", lein=\"Leiningen project\" %}</p> <p>{% content \"deps\" %} Create a Clojure CLI tools <code>deps.edn</code> project using the <code>:project/new</code> alias from practicalli/clojure-deps-edn  configuration.</p> <p>Run this command in a terminal window</p> <pre><code>clojure -X:project/new :template figwheel-main :name practicalli/landing-page\n</code></pre> <p>The command will create a new directory with the project name</p> <p></p> <p>{% content \"lein\" %} Create a Leiningen <code>project.clj</code> project using the following command, including <code>--reagent</code> which is a common library for reactive web page development</p> <pre><code>lein new figwheel-main practicalli/landing-page\n</code></pre> <p>{% endtabs %}</p>"},{"location":"figwheel-main-projects/simple/#run-a-clojurescript-project","title":"Run a ClojureScript project","text":"<p>Run the ClojureScript project from the command line initially to ensure that everything is working.</p> <p>The project will start a REPL and figwheel-main will launch a connected browser REPL in the default web browser.</p> <p>In the terminal window used to create the project, change into the project directory</p> <pre><code>cd landing-page\n</code></pre> <p>{% tabs depsrepl=\"Clojure CLI project\", leinrepl=\"Leiningen project\" %}</p> <p>{% content \"depsrepl\" %} Use the Clojure CLI tools to run the project using the <code>:fig</code> alias and the <code>:build</code> build task.</p> <p>Also use <code>:repl/rebel</code> alias from practicalli/clojure-deps-edn to run the REPL with rebel readline for a richer REPL experience.</p> <pre><code>clojure -M:fig:build\n</code></pre> <p>{% content \"leinrepl\" %}</p> <p>Use Leiningen to run the ClojureScript project using the <code>:fig</code> alias and the <code>:build</code> build task.</p> <pre><code>lein fig:build\n</code></pre> <p>{% endtabs %}</p> <p>A window or tab should automatically open once the project starts.  This takes a few moments, so take a few deep breaths.</p> <p></p>"},{"location":"figwheel-main-projects/simple/#check-the-browser-connection","title":"Check the browser connection","text":"<p>Check the browser REPL is connected by evaluating a ClojureScript expression in the ClojureScript REPL.</p> <p>In the terminal at the ClojureScript REPL prompt, show an alert box in the browser. <pre><code>(js/alert \"Hello from the ClojureScript REPL\")\n</code></pre></p> <p></p> <p>The web page updates and shows a dialog box with the message.</p> <p></p> <p>Add the <code>js/alert</code> expression as a rich comment block to the <code>src/practicalli/landing_page.cljs</code> source code file.  This provides a convenient way to test the figwheel-main connection to the browser without being part of the main code.</p> <pre><code>(comment\n(js/alert \"Hello from the ClojureScript REPL\")\n)\n</code></pre>"},{"location":"figwheel-project/","title":"Figwheel Project","text":"<p>In this section we will create a ClojureScript project using Figwheel to manage the build and auto-reloading of changes into the project</p> <ul> <li>Create Project</li> <li>ClojureScript file</li> <li>Project Build file</li> <li>Run Figwheel</li> <li>Web Page</li> <li>Run Figwheel again</li> <li>Add a counter</li> <li>Auto Reloading</li> <li>Serving assets</li> <li>Using the REPL</li> </ul> <p>Hint Once you have understood the basics of figwheel, you can use a Leinigen template to automatically create a project structure and build configuration file.</p> <p>It is important to understand how Figwheel works, so its easy to change the project build file should you need to.</p>"},{"location":"figwheel-project/add-a-counter/","title":"Add a counter","text":"<p>Let's create a simple program for demonstration purposes. This is going to be a bare bones program that uses the sablono ClojureScript interface to React.js.</p> <p>First add <code>[sablono \"0.3.6\"]</code> to the <code>:dependencies</code> list in your <code>project.clj</code>.</p> <p>You will need to restart Figwheel to pick up the new dependency.</p> <p>Add a place for us to mount our app in your <code>index.html</code>.</p> <p><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=\"app\"&gt;&lt;/div&gt; &lt;!-- add this line --&gt;\n&lt;script src=\"main.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> Now, edit your <code>src/hello_seymore/core.cljs</code> file:</p> <pre><code>(ns hello-seymore.core\n(:require [sablono.core :as sab]))\n(def app-state (atom { :likes 0 }))\n(defn like-seymore [data]\n(sab/html [:div\n[:h1 \"Seymore's quantified popularity: \" (:likes @data)]\n[:div [:a {:href \"#\"\n:onClick #(swap! data update-in [:likes] inc)}\n\"Thumbs up\"]]]))\n(defn render! []\n(.render js/React\n(like-seymore app-state)\n(.getElementById js/document \"app\")))\n(add-watch app-state :on-change (fn [_ _ _ _] (render!)))\n(render!)\n</code></pre> <p>Since Figwheel is running, once you save this file you should see the application running in the browser.</p> <p>Let's talk about the reloadability of this tiny React app.</p> <p>First, try the program out by clicking the Thumbs up link several times.  You will see Seymore's popularity increase. Popularity should really be measured by how many times people are willing to click a thumbs up eh?</p> <p>Now, if you change the source files by simply adding a blank line and saving it (something I actually do pretty often), the code will reload and you will see the popularity count go to zero. This is because we are redefining the <code>app-state</code> atom on every code load.  This is not what we want. You can fix this by using <code>defonce</code> instead of <code>def</code> on <code>app-state</code> as follows:</p> <pre><code>(defonce app-state (atom {:likes 0}))\n</code></pre> <p>After you make this change you will see that the state of the program will persist through reloads.</p> <p>Something else to notice is that the call to <code>add-watch</code> is getting called over and over again on reload. But this is OK because it is just replacing the current <code>:on-change</code> listener, making this top level side-effect reloadable.</p> <p>Also, you will notice that we have a top level call to <code>render!</code> at the end of the file. This forces a re-render every time the file is loaded. This is helpful so that we will render app changes as we edit the file.</p> <p>Remove the <code>like-seymore</code> function from the <code>core.cljs</code> file and add it to its own file <code>src/hello_symore/components.cljs</code>.</p> <p>Updated <code>core.cljs</code>: <pre><code>(ns hello-seymore.core\n(:require [sablono.core :as sab]\n[hello-seymore.components :refer [like-seymore]]))\n(defonce app-state (atom { :likes 0 }))\n(defn render! []\n(.render js/React\n(like-seymore app-state)\n(.getElementById js/document \"app\")))\n(add-watch app-state :on-change (fn [_ _ _ _] (render!)))\n(render!)\n</code></pre></p> <p>New <code>src/hello_seymore/components.cljs</code>: <pre><code>(ns hello-seymore.components\n(:require [sablono.core :as sab]))\n(defn like-seymore [data]\n(sab/html [:div\n[:h1 \"Seymore's quantified popularity: \" (:likes @data)]\n[:div [:a {:href \"#\"\n:onClick #(swap! data update-in [:likes] inc)}\n\"Thumbs up\"]]]))\n</code></pre></p> <p>As long as Figwheel was running this whole time your refactor should have been live loaded into the browser. After reflecting on the coolness of this, go ahead and edit the <code>components.cljs</code> file and remove the word \"quantified\" and save it. You will see your changes show up as expected.</p>"},{"location":"figwheel-project/add-a-counter/#pro-tip-use-lein-clean","title":"Pro-tip: use <code>lein clean</code>","text":"<p>Whenever you add new dependencies and restart Figwheel, also run <code>lein clean</code>. It will reduce the  chances of working with old code</p>"},{"location":"figwheel-project/auto-reloading/","title":"Auto Reloading","text":"<p>Figwheel will autoreload css as well. You will need to add some server level configuration to get this feature.</p> <p>First create a CSS file <code>css/style.css</code>.</p> <pre><code>body {\nbackground-color: yellow;\n}\n</code></pre> <p>Edit the <code>project.clj</code></p> <pre><code>(defproject hello-seymore \"0.1.0-SNAPSHOT\"\n:dependencies [[org.clojure/clojure \"1.7.0\"]\n[org.clojure/clojurescript \"1.7.170\"]\n[sablono \"0.3.6\"]]\n:plugins [[lein-figwheel \"0.5.0-1\"]]\n:clean-targets [:target-path \"out\"]\n:cljsbuild {\n:builds [{:id \"dev\"\n:source-paths [\"src\"]\n:figwheel { :on-jsload \"hello-seymore.core/render!\" }\n:compiler {:main hello-seymore.core } }]\n}\n:figwheel { ;; &lt;-- add server level config here\n:css-dirs [\"css\"]\n}\n)\n</code></pre> <p>And of course don't forget to add a link to your css in the <code>index.html</code>:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;!-- add link here --&gt;\n&lt;link href=\"css/style.css\" rel=\"stylesheet\" type=\"text/css\"&gt; \n&lt;/head&gt;\n&lt;body&gt;\n&lt;script src=\"main.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Now restart Figwheel and edit the <code>style.css</code>:</p> <pre><code>body {\nbackground-color: green;\n}\n</code></pre> <p>Your page in the browser should now be green and not yellow. Without reloading the page!</p>"},{"location":"figwheel-project/auto-reloading/#opting-out-of-autoreloading","title":"Opting out of autoreloading","text":"<p>You may not want to have your code auto-reloaded but still want to benefit from Figwheel's auto-building and its REPL.  All you have to do is add <code>:autoload false</code> to the <code>:figwheel</code> entry in your build config. </p> <p>In this case your build config would look like this:</p> <pre><code>(defproject hello-seymore \"0.1.0-SNAPSHOT\"\n:dependencies [[org.clojure/clojure \"1.7.0\"]\n[org.clojure/clojurescript \"1.7.170\"]\n[sablono \"0.3.6\"]]\n:plugins [[lein-figwheel \"0.5.0-1\"]]\n:clean-targets [:target-path \"out\"]\n:cljsbuild {\n:builds [{:id \"dev\"\n:source-paths [\"src\"]\n:figwheel { :autoload false } ;; &lt;&lt;- add this\n:compiler {:main hello-seymore.core } }]\n})\n</code></pre>"},{"location":"figwheel-project/clojurescript-file/","title":"ClojureScript file","text":"<p>Create the file <code>src/hello_figwheel/core.cljs</code> and add the following ClojureScript code:</p> <pre><code>(ns hello-figwheel.core)\n(.log js/console \"Hello Figwheel, you compile me!\")\n</code></pre>"},{"location":"figwheel-project/create-project/","title":"Create Project","text":"<p>Create the following directory structure</p> <pre><code>hello_figwheel\n|_ src\n  |_ hello_figwheel\n</code></pre> <p>In the the top-level <code>hello_figwheel</code> directory we will create a ClojureScript source file, a project build file and a web page.</p> <p>Hint Once you have a grasp of the basics you can use the figwheel leiningen template to create projects</p> <pre><code>lein new figwheel hello-figwheel\n</code></pre> <p>The figwheel template can also add react libraries such as om and reagent <pre><code>    lein new figwheel hello-world -- --om       ;; for an om based project\n    lein new figwheel hello-world -- --reagent  ;; for a reagent based project \n</code></pre></p>"},{"location":"figwheel-project/create-project/#notecreate-a-simple-clojurescript-project-called-hello_figwheel","title":"Note::Create a simple ClojureScript project called <code>hello_figwheel</code>.","text":""},{"location":"figwheel-project/project-build-file/","title":"Project Build file","text":"<p>Create a file called <code>project.clj</code> and add the following Clojure code:</p> <pre><code>(defproject hello-figwheel \"0.1.0-SNAPSHOT\"\n:dependencies [[org.clojure/clojure \"1.7.0\"]\n[org.clojure/clojurescript \"1.7.170\"]]\n:plugins [[lein-figwheel \"0.5.0-1\"]]\n:clean-targets [:target-path \"out\"]\n:cljsbuild {\n:builds [{:id \"dev\"\n:source-paths [\"src\"]\n:figwheel true\n:compiler {:main \"hello-figwheel.core\"}\n}]\n})\n</code></pre>"},{"location":"figwheel-project/run-figwheel-again/","title":"Run Figwheel again","text":"<p>Now run Figwheel again:</p> <pre><code>$ lein figwheel\n</code></pre> <p>and load the <code>index.html</code> in the browser from the filesystem. The location bar in your browser should have a <code>file://&lt;...&gt;/hello_seymore/index.html</code> url in it.</p> <p>Change back to the terminal where Figwheel is starting and when it finishes you should see a REPL prompt.  </p> <p>Go ahead and type some ClojureScript at the REPL prompt: <pre><code>=&gt; (+ 1 2 3)\n6\n</code></pre></p> <p>If you get <code>6</code> as a response then you have successfully set up Figwheel!!!</p> <p>You can also see that the REPL is connected to the browser:</p> <pre><code>=&gt; (js/alert \"Am I connected to Figwheel?\")\nnil\n</code></pre> <p>You should see the alert in the browser window. Only after you click on \"Ok\" there, will the REPL return <code>nil</code>.</p> <p>Also, go ahead and open up the browser's dev tools so you can see the messages from Figwheel. You should see something like this (in Chrome):</p> <p></p> <p>Now go back to your <code>src/hello_seymore/core.cljs</code> file and change the line that looks like:</p> <p><pre><code>(.log js/console \"Hey Seymore sup?!\")\n</code></pre> to <pre><code>(.log js/console \"Hey Seymore! wts goin' on?\")\n</code></pre> and save the file. You should now see <code>Hey Seymore! wts goin' on?</code> printed in the dev console of your browser.</p> <p>Congratulations!! You have set up Figwheel and your code is getting loaded into the browser as you save it.</p> <p>As you can see, side-effects from print functions happen on every reload. This might not be desirable for all side-effects. Code that only triggers desired side-effects is called \"reloadable code\". We will discuss how to write such code later. Please remember that you are responsible for writing reloadable code! :)</p>"},{"location":"figwheel-project/run-figwheel-again/#pro-tip-tail-the-figwheel_serverlog","title":"Pro-tip: tail the figwheel_server.log","text":"<p>When working with Figwheel you should really have a separate terminal open to watch the <code>figwheel_server.log</code>. This can be immensely helpful when things aren't working correctly.</p> <p>So open another terminal and type: <code>$ tail -f figwheel_server.log</code></p>"},{"location":"figwheel-project/run-figwheel/","title":"Run Figwheel","text":"<p>At this point make sure you are in the project root directory <code>hello_figwheel</code> and run Figwheel as follows:</p> <pre><code>lein figwheel\n</code></pre> <p>You should see a bunch of clojure libraries get downloaded and installed into your local maven repository (which happens to be in <code>~/.m2</code> on my Mac).</p> <p>After that Figwheel will start up, compile your <code>hello-seymore.core</code> library and try to start a repl, BUT THE REPL WILL NOT START. Sorry for the caps, but this behavior is expected.</p> <p>Type Ctrl-C to quit the Figwheel process.</p> <p>If you list your project directory you should see this: <pre><code>$ ls\nfigwheel_server.log\nindex.html\nmain.js\nout\nproject.clj\nsrc\ntarget\n</code></pre></p> <p>Some new files have been created. The <code>main.js</code> file and the <code>out</code> directory contain your compiled ClojureScript code.</p> <p>If you look at the contents of <code>main.js</code> you will see:</p> <pre><code>if(typeof goog == \"undefined\") document.write('&lt;script src=\"out/goog/base.js\"&gt;&lt;/script&gt;');\ndocument.write('&lt;script src=\"out/cljs_deps.js\"&gt;&lt;/script&gt;');\ndocument.write('&lt;script&gt;if (typeof goog != \"undefined\") { goog.require(\"hello_seymore.core\"); } else { console.warn(\"ClojureScript could not load :main, did you forget to specify :asset-path?\"); };&lt;/script&gt;');\n\ndocument.write(\"&lt;script&gt;if (typeof goog != \\\"undefined\\\") { goog.require(\\\"figwheel.connect\\\"); }&lt;/script&gt;\");\n</code></pre> <p>The last line of <code>main.js</code> loads the code that will connect to the Figwheel server. This is what enables the Figwheel server to communicate with the application, which is running in the browser.</p>"},{"location":"figwheel-project/serving-assets/","title":"Serving assets","text":"<p>It is recommended that if you start needing a server to serve your ClojureScript assets that you just bite the bullet and write your own. But for convenience Figwheel has a built-in webserver. In order to use it you will have to place your assets in <code>resources/public</code>.</p> <p>Following the example we are using you would need to make these changes:</p> <p>Move your assets into <code>resources/public</code>:</p> <pre><code>mkdir -p resources/public\n$ mv index.html css resources/public\n</code></pre> <p>Now you need to change your build config to output your compiled ClojureScript to <code>resources/public</code> as well. For good measure we will place them in a <code>cljs</code> directory.</p> <pre><code>(defproject hello-seymore \"0.1.0-SNAPSHOT\"\n:dependencies [[org.clojure/clojure \"1.7.0\"]\n[org.clojure/clojurescript \"1.7.170\"]\n[sablono \"0.3.6\"]]\n:plugins [[lein-figwheel \"0.5.0-1\"]]\n:clean-targets [:target-path \"out\" \"resources/public/cljs\"] ;; Add \"resources/public/cljs\"\n:cljsbuild {\n:builds [{:id \"dev\"\n:source-paths [\"src\"]\n:figwheel true\n:compiler {:main hello-seymore.core ;; add the following \n:asset-path \"cljs/out\"\n:output-to  \"resources/public/cljs/main.js\"\n:output-dir \"resources/public/cljs/out\"} }]\n}\n:figwheel {\n:css-dirs [\"resources/public/css\"]\n}\n)\n</code></pre> <p>So now we have changed where the compiler is placing the compiled assets. It's very important to get <code>:asset-path</code> correct otherwise <code>main.js</code> will have code that doesn't point to your compiled assets and nothing will work. It is also important to add our new target path to the <code>:clean-targets</code>, otherwise <code>lein clean</code> won't work.</p> <p>Since we changed the location of <code>main.js</code>, we need to reflect that in <code>index.html</code>:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;link href=\"css/style.css\" rel=\"stylesheet\" type=\"text/css\"&gt; \n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=\"app\"&gt;&lt;/div&gt;\n&lt;script src=\"cljs/main.js\" type=\"text/javascript\"&gt;&lt;/script&gt; ;; &lt;-- changed to \"cljs/main.js\"\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Now you can restart Figwheel.</p> <p>You can now find your application at <code>http://localhost:3449/index.html</code></p>"},{"location":"figwheel-project/using-the-repl/","title":"Using the REPL","text":"<p>Since all code evaluated in the REPL actually runs on the browser, we have some powerful tools at our disposal. For example, we can take our <code>app-state</code> to places our UI interface can't easily reach to test for edge cases. Imagine that there might be a problem when the counter displays a 5 digit number after a number of things happened. Would you do those things and then click 10000 times on \"Thumbs up\"?</p> <p>Start the REPL and go to the <code>hello-seymore.core</code> namespace</p> <pre><code>&gt; (in-ns 'hello-seymore.core)\nnil\n</code></pre> <p>Then change <code>app-state</code> to whatever number you want to test and check it on the browser:</p> <pre><code>&gt; (reset! app-state {:likes 10000})\n{:likes 10000}\n</code></pre>"},{"location":"figwheel-project/using-the-repl/#pro-tip-use-rlwrap","title":"Pro-tip: use rlwrap","text":"<p>You'll get a much better REPL experience if you install rlwrap and run <code>rlwrap lein figwheel</code></p> <p>you can install <code>rlwrap</code> on OSX with <code>brew install rlwrap</code></p>"},{"location":"figwheel-project/web-page/","title":"Web Page","text":"<p>In order to run the hello figwheel project, we will need an HTML file to load the compiled JavaScript code into in the browser.</p> <p>Edit the <code>index.html</code> file to look like this:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Hello Figwheel&lt;/h1&gt;\n&lt;p&gt;Dont look for answers in this webpage, seek out the JavaScript console in your browsers dev tools...&lt;/p&gt;\n&lt;script src=\"main.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"functional-reactive-programming/","title":"Functional Reactive Programming","text":"<p>Presentation on Functional Reactive Programming with Clojurescript, React &amp; Reagent</p>"},{"location":"install/","title":"Installing ClojureScript development tools","text":"<p>Follow the Practicalli Clojure - install Clojure tools guide to create a ClojureScript, which requires Java, Clojure and a ClojureScript aware editor.</p> <p>ClojureScript is specified as a dependency in projects, which contains the language and basic tools for building projects.</p> <p>Figwheel-main is used to provide a comprehensive tool for building ClojureScript applications and supports REPL driven development and hot-loading of changes in the browser as the code is developed.</p> <p>practicalli/clojure-deps-edn GitHub repository contains the Clojure CLI user level configuration used in this guide and issues and pull requests can also be made there.</p> Requirement Description Java ClojureScript tooling is predominantly written in Java Clojure CLI Tools for running and working with Clojure &amp; ClojureScript projects Figwheel-main Build and hot-loading environment for ClojureScript (add library as project dependency) ClojureScript editor An editor that connects to the ClojureScript REPL and provides language support Web Browser (Firefox, Chrome, chromium) Host platform for JavaScript <p>HINT: shadow-cljs can be used instead of Figwheel to manage a ClojureScript projects.  Read the Shadow CLJS user guide in detail to understand how to manage projects with this tool.</p> <p></p> <p>ClojureScript uses the Google Closure tools to compile ClojureScript to JavaScript which will run on a wide range of web browsers.</p> <p>The Google Closure tools removes any code that is never called (dead code) and minimises the remaining code to optimise download speed.  The compiler also checks syntax, variable references, and types, and warns about common JavaScript pitfalls.</p> <ul> <li>Can I use JavaScript ?</li> <li>Browser support for JavaScript APIs</li> <li>Hello ClojureScript! - example project for testing dev tool support in browser</li> </ul>"},{"location":"install/browser-devtools/","title":"Browser developer tools","text":"<p>Developer tools included in browsers (FireFox, Google Chrome, etc.) allow examination of what is happening when you run the JavaScript code created from your ClojureScript code.</p> <ul> <li>Firefox Developer Tools</li> <li>Google Chrome DevTools</li> </ul> Feature Description Page Inspector view / edit the source code of the page Web Console see log messages and interact with current page via code JavaScript debugger stop, step through, examine, and modify the JavaScript running on a page Source Maps format the original ClojureScript code in the browser Network monitor Network requests when a page is loaded Performance Tools Analyze a pages responsiveness, JavaScript and layout performance Application panel Inspect and debug progressive apps, service workers and app manifests Responsive design mode UI look and behavior of page on different devices and network types Accessibility Inspector Report on accessibility support of a page"},{"location":"install/browser-devtools/#supporting-tools","title":"Supporting tools","text":"<ul> <li>cljs-dev-tools</li> </ul>"},{"location":"install/browser-devtools/#learning-resources","title":"Learning Resources","text":"<ul> <li>What are browser developer tools</li> <li>15 must know Chrome DevTools tips by Tutorialzine.com</li> </ul>"},{"location":"install/browser-devtools/#source-maps","title":"Source Maps","text":"<p>Source Maps show you what ClojureScript code created the running JavaScript to aid with debugging.</p> <p>Ensure source maps are enabled in the browser developer tools.</p> <p></p>"},{"location":"install/browser-devtools/#chrome-devtools-extensions-for-clojurescript-developers","title":"Chrome DevTools Extensions for ClojureScript developers","text":"<p>DevTool Extensions add more better presentation of ClojureScript values in Chrome DevTools using custom formatters, more informative exceptions with sanity hints) and support for Dirac DevTools - a fork of the Chrome DevTools.</p> <p></p>"},{"location":"install/browser-devtools/#install-devtools-extensions","title":"Install DevTools Extensions","text":"<p>Add devtools dependency into your Leiningen's project.clj using the details on the Clojars.org website</p> <p>Add the DevTools extensions to the startup part of your ClojureScript using the <code>(:require [devtools.core :as devtools])</code> expression.  Then call <code>install!</code> function from <code>devtools.core</code> namespace.</p> <p>Here is an example of adding the DevTools extension library and calling it with several options</p> <pre><code>(ns your-project.core\n(:require [devtools.core :as devtools]))\n; this enables additional features, :custom-formatters is enabled by default\n(devtools/enable-feature! :sanity-hints :dirac)\n(devtools/install!)\n(.log js/console (range 200))\n</code></pre> <p>For more details, visit the DevTools Extensions website and clone the sample project.</p>"},{"location":"install/browser-devtools/#dirac-devtools-a-fork-of-chrome-devtools","title":"Dirac DevTools (a fork of Chrome DevTools)","text":"<p>Dirac DevTools is a fork of the Chrome DevTools.</p> <p></p>"},{"location":"install/browser-devtools/#references","title":"References","text":"<ul> <li>Write a Firefox add-on in ClojureScript</li> </ul>"},{"location":"install/chestnut/","title":"Chestnut","text":"<p>Chestnut is a Leiningen template for a ClojureScript app based on Om, featuring a great dev setup, and easy deployment.</p> <p>For smooth development you get instant reloading of Clojure, ClojureScript, and CSS. A browser-connected REPL is also included.</p> <p>For deployment you get uberjar support, meaning you can get all your code compiled, optimized, and packaged in a single executable JAR file. It also contains the necessary artifacts to work on Heroku out of the box.</p> <p>Need help? Ask on the mailing list</p>"},{"location":"install/chestnut/#hinttodo-review-if-chestnut-is-still-a-valid-approach","title":"HINT::TODO: Review if Chestnut is still a valid approach","text":"<p>Deprecate the content if no longer relevant</p>"},{"location":"install/chestnut/#chestnut-090-snapshot","title":"Chestnut 0.9.0-SNAPSHOT","text":"<p>A major update is in the works. To try it out, use <code>lein new chestnut my-project --snapshot</code>.</p> <ul> <li>Use Figwheel for REPL and Ring server</li> <li>Remove boilerplate that's no longer needed</li> <li>Drop Enlive and simplify the dev setup</li> <li>Drop CLJX support</li> <li>Better inline documentation</li> </ul>"},{"location":"install/chestnut/#usage","title":"Usage","text":"<pre><code>lein new chestnut &lt;name&gt;\n</code></pre> <p>After that open the README of your generated project for detailed instructions.</p>"},{"location":"install/chestnut/#command-line","title":"Command line","text":"<pre><code>$ lein repl\n\n(run)\n(browser-repl)\n</code></pre> <p>Wait a bit, then browse to http://localhost:10555.</p>"},{"location":"install/chestnut/#lighttable","title":"Lighttable","text":"<p>Lighttable provides a tighter integration for live coding with an inline browser-tab. Rather than evaluating cljs on the command line with weasel repl, evaluate code and preview pages inside Lighttable.</p> <p>Steps: After running <code>(run)</code>, open a browser tab in Lighttable. Open a cljs file from within a project, go to the end of an s-expression and hit Cmd-ENT. Lighttable will ask you which client to connect. Click 'Connect a client' and select 'Browser'. Browse to http://localhost:10555</p> <p>View LT's console to see a Chrome js console.</p> <p>Hereafter, you can save a file and see changes or evaluate cljs code (without saving a file). Note that running a weasel server is not required to evaluate code in Lighttable.</p>"},{"location":"install/chestnut/#emacscider","title":"Emacs/Cider","text":"<p>Start a repl in the context of your project with <code>M-x cider-jack-in</code>.</p> <p>Switch to repl-buffer with <code>C-c C-z</code> and start web and figwheel servers with <code>(run)</code>, and weasel server with <code>(browser-repl</code>). Load http://localhost:10555 on an external browser, which connects to weasel, and start evaluating cljs inside Cider.</p>"},{"location":"install/chestnut/#list-of-contents","title":"List of Contents","text":"<p>This template gives you everything you need to start developing Clojure/ClojureScript apps effectively. It comes with</p> <ul> <li>Figwheel Automatically   reload your ClojureScript and CSS as soon as you save the file, no   need for browser refresh.</li> <li>Om ClojureScript interface to   Facebook's React.</li> <li>Ring Clojure's de facto HTTP   interface. Chestnut uses a Jetty or HttpKit server to serve the   Clojurescript app. This way you already have an HTTP server running   in case you want to add server-side functionality. Chestnut also   inserts a Ring middleware to reload server-side Clojure files.</li> <li>Heroku support. Chestnut apps have all the bits and pieces to be   deployable to Heroku. Getting your app on the web is as simple as   <code>git push</code>.</li> <li>Unit tests for both Clojure and CLJS. Or you can decide to use Speclj instead, both for CLJ and CLJS.   Both specs and CLJS tests can be run in \"auto\" mode.</li> </ul>"},{"location":"install/chestnut/#options","title":"Options","text":"<ul> <li><code>--http-kit</code> Use HTTP Kit instead   of Jetty</li> <li><code>--site-middleware</code> Use the <code>ring.middleware.defaults.site-defaults</code> middleware   (session, CSRF), instead of <code>ring.middleware.defaults.api-defaults</code> (see   ring.defaults documentation)</li> <li><code>--om-tools</code> Use Prismatic's   om-tools.dom instead of   <code>om.dom</code></li> <li><code>--less</code> Use less for   compiling Less CSS files.</li> <li><code>--speclj</code> Use speclj test runner for clj and cljs, and disable the core cljs.test tests.</li> </ul> <p>Use <code>--</code> to separate these options from Leiningen's options, e.g. <code>lein new chestnut foo -- --om-tools --http-kit</code></p>"},{"location":"install/chestnut/#local-copy","title":"Local copy","text":"<p>If you want to customize Chestnut, or try unreleased features, you can run directly from master like this:</p> <pre><code>git clone https://github.com/plexus/chestnut.git\ncd chestnut\nlein install\n</code></pre> <p>Note that master may be partially or wholly broken. I try to do extensive manual testing before releasing a new stable version, so if you don't like surprises then stick to the version on Clojars. Issue reports and pull requests are very welcome.</p>"},{"location":"install/cider/","title":"CIDER","text":"<p>You can use CIDER, the Emacs client for Clojure, with Clojurescript projects.</p> <p>In the current version of CIDER you can have both a Clojure and ClojureScript REPL active at the same time, so forms evaluated from a CLJ or CLJS file automatically go to the right place.</p> <p>Run the command <code>cider-jack-in-clojurescript</code> to start two nREPL sessions.</p> <p>For a more detailed background to how this works, see the LambdaIsland article \"Using Figwheel With Emacs, part 2: CIDER\" (account required for access)</p>"},{"location":"install/cider/#clojurescript-environments","title":"Clojurescript environments","text":"<p>You can choose from one of several REPL's to use with CIDER.  By default CIDER is configured to use the Java Rhino REPL, however most people will use Figwheel instead.</p> <p>CIDER use Rhino, the JavaScript engine bundled with Java. Rhino is useful if you want to use Java classes straight from ClojureScript.</p> <p>Figwheel is the most common approach for Clojurescript websites.</p>"},{"location":"install/cider/#setting-the-environment","title":"Setting the environment","text":"<p>CIDER can be configured by customizing the <code>cider-cljs-lein-repl</code> variable. </p> <p>This variable is set to <code>(cemerick.piggieback/cljs-repl (cljs.repl.rhino/repl-env))</code>so we need to change it for other environments. CIDER makes this easy by providing a list to choose from.</p> <p>Lets change the setting to use Figwheel:</p> <ol> <li> <p>Open the customize interface with <code>M-x customize-variable cider-cljs-lein-repl</code>. </p> </li> <li> <p>Tab your way to the button that reads \u201cValue Menu\u201d and press Enter. </p> </li> <li> <p>A buffer is displayed with a list of choices, the second of which is \u201cFigwheel sidecar\u201d.  Press 1, and then press the \"Apply and Save\" button.</p> </li> </ol> <p>Now if you look at <code>cider-cljs-lein-repl</code> you\u2019ll see it\u2019s switched to a Figwheel REPL. </p> <p>Use Directory Local Variables to change this on a per project basis.</p> <pre><code>(do\n(require 'figwheel-sidecar.repl-api)\n(figwheel-sidecar.repl-api/start-figwheel!)\n(figwheel-sidecar.repl-api/cljs-repl))\n</code></pre> <p>A more elaborate snippet that tries to detect the type of project and run the appropriate environment.</p> <pre><code>(setq cider-cljs-lein-repl\n\"(cond\n  (and (resolve 'user/run) (resolve 'user/browser-repl)) ;; Chestnut projects\n  (eval '(do (user/run)\n             (user/browser-repl)))\n  (try\n    (require 'figwheel-sidecar.repl-api)\n    (resolve 'figwheel-sidecar.repl-api/start-figwheel!)\n    (catch Throwable _))\n  (eval '(do (figwheel-sidecar.repl-api/start-figwheel!)\n             (figwheel-sidecar.repl-api/cljs-repl)))\n  (try\n    (require 'cemerick.piggieback)\n    (resolve 'cemerick.piggieback/cljs-repl)\n    (catch Throwable _))\n  (eval '(cemerick.piggieback/cljs-repl (cljs.repl.rhino/repl-env)))\n  :else\n  (throw (ex-info \\\"Failed to initialize CLJS repl. Add com.cemerick/piggieback and optionally figwheel-sidecar to your project.\\\" {})))\")\n</code></pre>"},{"location":"install/clojurescript-project/","title":"Clojurescript projects","text":"<p>A ClojureScript project should contain dependencies for the Clojure and ClojureScript libraries, which are managed by the build tool (Clojure CLI tools or Leiningen) just like any other dependency.</p> <p>figwheel-main provides additional tooling for REPL driven development, including live updates to the browser REPL and test runner.</p> <p>Use the <code>figwheel-main</code> template to generate a working ClojureScript project with Figwheel-main.</p> <p>{% tabs deps=\"Clojure CLI project\", lein=\"Leiningen project\" %}</p> <p>{% content \"deps\" %} Create a Clojure CLI tools <code>deps.edn</code> project using the <code>:project/new</code> alias from practicalli/clojure-deps-edn  configuration, including the <code>--reagent</code> template option which adds a common library for reactive web page development</p> <p>Run this command in a terminal window</p> <pre><code>clojure -X:project/new :template figwheel-main :name practicalli/landing-page -- --reagent\n</code></pre> <p>The command will create a new directory with the project name</p> <p></p> <p>{% content \"lein\" %} Create a Leiningen <code>project.clj</code> project using the following command, including <code>--reagent</code> which is a common library for reactive web page development</p> <pre><code>lein new figwheel-main hello-world.core -- --reagent\n</code></pre> <p>{% endtabs %}</p>"},{"location":"install/clojurescript-project/#run-a-clojurescript-project","title":"Run a ClojureScript project","text":"<p>Run the ClojureScript project from the command line initially to ensure that everything is working.</p> <p>The project will start a REPL and figwheel-main will launch a connected browser REPL in the default web browser.</p> <p>In the terminal window used to create the project, change into the project directory</p> <pre><code>cd landing-page\n</code></pre> <p>{% tabs depsrepl=\"Clojure CLI project\", leinrepl=\"Leiningen project\" %}</p> <p>{% content \"depsrepl\" %} Use the Clojure CLI tools to run the project using the <code>:fig</code> alias and the <code>:build</code> build task.</p> <p>Also use <code>:repl/rebel</code> alias from practicalli/clojure-deps-edn to run the REPL with rebel readline for a richer REPL experience.</p> <pre><code>clojure -M:fig:build\n</code></pre> <p>{% content \"leinrepl\" %}</p> <p>Use Leiningen to run the ClojureScript project using the <code>:fig</code> alias and the <code>:build</code> build task.</p> <pre><code>lein fig:build\n</code></pre> <p>{% endtabs %}</p> <p>A window or tab should automatically open once the project starts.  This takes a few moments, so take a few deep breaths.</p> <p></p>"},{"location":"install/clojurescript-project/#check-the-browser-connection","title":"Check the browser connection","text":"<p>Check the browser REPL is connected by evaluating a ClojureScript expression in the ClojureScript REPL.</p> <p>In the terminal at the ClojureScript REPL prompt, show an alert box in the browser. <pre><code>(js/alert \"Hello from the ClojureScript REPL\")\n</code></pre></p> <p></p> <p></p>"},{"location":"install/clojurescript-project/#hintensure-project-runs-locally-before-running-from-an-editor","title":"Hint::Ensure project runs locally before running from an editor","text":"<p>Running a ClojureScript project on the command line is a quick way to ensure everything is working before considering running the project via an editor.</p>"},{"location":"install/clojurescript-project/#reference","title":"Reference","text":"<ul> <li>Interactive programming Flappy Birds in ClojureScript</li> <li>Clojure West 2015 - Developing ClojureScript with Figwheel</li> </ul> <p>Hint ClojureScript uses the Google Closure compiler and build tools that require a Java Virtual machine.  However, work is in progress to make ClojureScript self hosting.  See articles such as ClojureScript Next and Bootstrapped ClojureScript FAQ for pro's and con's of this approach.</p>"},{"location":"install/leiningen/","title":"Leiningen Build tool","text":"<p>Leiningen (pronounced line-ing) is the build automation tool used to manage Clojure projects.  Features include:</p> <ul> <li>Creating Clojure Projects</li> <li>Dependency Management</li> <li>Running browser-REPL interactive environment (figwheel plugin)</li> </ul>  ![Leiningen - build automation for Clojure](../images/leiningen-repl-custom-prompt.png)"},{"location":"install/leiningen/#install-leiningen","title":"Install Leiningen","text":"<p>Install Leiningen by saving the Leiningen install script to somewhere on your operating system path, eg <code>~/bin</code>and then running that script from the command line.</p> <ul> <li>Install script for Linux &amp; MacOSX</li> <li>Install script for Microsoft Windows</li> </ul> <p>On Linux and MacOSX, make the script executable first and then run the <code>lein</code> script</p> <pre><code>chmod a+x ~/bin/lein\nlein\n</code></pre> <p>hint I create a <code>~/bin</code> directory and add it to my operating system execution path ($PATH), placing the <code>lein</code> script in <code>~/bin</code> so I can call it from anywhere on the filesystem.</p> <p>The first time you run this script it downloads a Java archive file (JAR) of the latest version of Leiningen.  When you run the script again, you have a working Leiningen build tool.</p>"},{"location":"install/leiningen/#testing-leiningen","title":"Testing Leiningen","text":"<p>Test that Leiningen is installed with the following command</p> <pre><code>lein version\n</code></pre> <p>Output should look similar to:</p> <pre><code>Leiningen 2.7.1 on Java 1.8.0 Java HotSpot(TM) 64-Bit Server VM\n</code></pre>"},{"location":"install/lighttable/","title":"LightTable","text":"<p>This workshop will use LightTable to help you discover Clojure.</p> <p>I have found LightTable to be one of the best tools to help you learn Clojure, especially the highly interactive Instarepl that evaluates your Clojure code as you type.</p> <p>LightTable is a modern development tool that supports Clojure, ClojureScript, JavaScript and Python languages.  The tool is open source and written in Clojure &amp; ClojureScript (with a little JavaScript &amp; CSS)</p> <p></p> <p>Note Install Lighttable from lighttable.com</p> <p>Linux    Extract the contents of the downloaded lighttable file to a suitable directory (<code>/usr/local</code> or <code>/opt</code> or <code>~/apps</code>).  Make sure the <code>LightTable</code> file in the extracted folder is accessible via the system <code>$PATH</code>.</p> <p>MacOSX   Install the <code>lighttable.dmg</code> file just as any other MacOSX package</p> <p>Windows   Download the windows zip file for LightTable and extract the installer, following the instructions inside the installer.</p>"},{"location":"install/lighttable/#using-lighttable","title":"Using LightTable","text":"<p>LightTable has an online tutorial entitled Getting started with LightTable</p> <p>Comment I mainly use the Instarepl in LightTable.  I create a project first with Leiningen, open the project directory in the LightTable workspace and oopen any files I want to work with.  I then connect the open editor window for the file to an Instarepl.</p> <p>fixme my approach is documented in the quick demo section of my Clojure &amp; LightTable slides from JAXLondon 2013.  This should be pulled into this workshop into its own section</p>"},{"location":"install/lumo/","title":"Lumo - Fast, cross-platform, standalone ClojureScript environment","text":"<p>Read the announcement blog post.</p>"},{"location":"install/lumo/#contents","title":"Contents","text":"<ul> <li>Installation</li> <li>Using Lumo</li> <li>Building</li> <li>Copyright &amp; License</li> </ul>"},{"location":"install/lumo/#installation","title":"Installation","text":""},{"location":"install/lumo/#via-npm","title":"Via NPM","text":"<pre><code>$ npm install -g lumo-cljs\n</code></pre> <p>Note: the installed binary will be named <code>lumo</code> rather than <code>lumo-cljs</code>_</p>"},{"location":"install/lumo/#via-homebrew-macos","title":"Via Homebrew (macOS)","text":"<pre><code>$ brew install lumo\n</code></pre> <p>Note: If you want to install a binary built from master, run <code>brew install --HEAD lumo</code> (at your own responsibility).</p>"},{"location":"install/lumo/#manual","title":"Manual","text":"<ol> <li>Download the latest release.</li> <li>Move it to somewhere in your <code>$PATH</code>.</li> </ol>"},{"location":"install/lumo/#using-lumo","title":"Using Lumo","text":"<p>Enter <code>lumo</code> at the command line to launch it.</p> <p>Check out <code>lumo -h</code> for usage instructions and supported command line options.</p>"},{"location":"install/lumo/#building","title":"Building","text":"<p>To build Lumo from source:</p> <ol> <li>Make sure you have installed Boot and Yarn.</li> <li>At the root of the repository, run: <code>boot release</code>.</li> <li>The resulting binary can be found in <code>build/lumo</code> (or <code>build\\lumo.exe</code> if you're on Windows).</li> </ol>"},{"location":"install/plank/","title":"Plank - stand-alone ClojureScript REPL for macOS and Linux","text":"<p>Planck launches instantly and is useful for scripting.</p> <p>Setup</p> <p>Get it: On macOS brew install planck, on Ubuntu install using apt-get.</p> <p>Read the Planck User Guide.</p> <p>Planck is free and open source.</p>"},{"location":"introduction/clojurescript/","title":"ClojureScript Overview","text":"<p>ClojureScript is an implementation of the Clojure programming language for the JavaScript platform (JavaScript browsers and node.js)</p> <p>The main difference of course between Clojure &amp; ClojureScript is the host (Java or JavaScript) and the type of applications &amp; services built with each language.</p> <p>ClojureScript is predominately used for front-end applications, although can also be used as full stack solutions.</p> Minor Language differences <p>Due to limitations of the host JavaScript platform, some language features of Clojure are not available in ClojureScipt</p> <p> ClojureScipt differences from Clojure</p>"},{"location":"introduction/clojurescript/#learning-clojurescipt","title":"Learning ClojureScipt","text":"<p>As Clojure &amp; ClojureScript language are almost identical, any good Clojure book or exercises can also help to learn ClojureScript</p> <p>ClojureScript language reference</p> <p>ClojureScript unraveled</p> <p>Practicalli Clojure Coding Challenges</p>"},{"location":"introduction/clojurescript/#development-tools","title":"Development Tools","text":"<p>There are many Clojure aware Editors available, use an editor most familiar with to minimize the initial learning requriements.</p> <p>Clojure aware editors have the same core functionality, so initial choice is not that important.  As additional features become more important, then a review of editor tooling can be done with more insight.</p>"},{"location":"introduction/clojurescript/#build-automation","title":"Build Automation","text":"<p>ClojureScript is trans-piled into JavaScript before running in a JavaScript browser engine or on node.js.</p> <p>The main tools to support this workflow:</p> <ul> <li>Figwheel - ClojureScript focused with the ability to bundle JavaScript npm packages (typically the simplest approach)</li> <li>Shadow-cljs - implmentation of ClojureScipt for node.js and therefore deeply integrated into the npm infrastructure (initially more complex but potential simpler if managing a large amount of npm packages and dependencies)</li> </ul>"},{"location":"introduction/clojurescript/#fighweel","title":"Fighweel","text":"<p>Figwheel is a simple approach and doesn't require node.js. ClojureScript applications can be built without JavaScript.  Figwheel does enabled use of npm packages via bundle though, should JavaScript packages be valuable to add.</p> <p> figwheel-template creates ClojureScript projects with figwheel configuration and optionally react, reagent, rum and bundle (webpack) options.</p> <p>Figwheel  Figwheel Template</p> Figwheel-main is library to use for Figwheel <p>Fighweel-main has replaced the figwheel library (now considered deprecated) and is a large rewrite of the tooling, providing a greatly enhanced experience.</p>"},{"location":"introduction/clojurescript/#shadow-cljs","title":"Shadow-cljs","text":"<p>Shadow-cljs is effectively built on top of node.js and therefore more integrated.  Assumes that node.js is well understood and significant use of JavaScript npm packages will be used</p> <p>Read the user guide in detail to avoid common issues when starting</p> <p>Shadow-cljs User Guide</p>"},{"location":"introduction/clojurescript/#common-libraries","title":"Common Libraries","text":"<p>As with any language, there are a wide range of choice for libraries to help build apps and many types of apps that can be built (UI / full-stacl / backend).</p> <p>reagent is the most commonly used ClojureScript library for front-end apps, especially single page applications.  reagent takes a react.js like approach.</p> <p>re-frame builds upon reagent and supports the building of more complex UIs and stateful workflows.</p> <p>reagent reframe rum</p>"},{"location":"introduction/contributing/","title":"Contributing to Practicalli Clojure","text":"<p>practicalli/clojure is written in markdown and uses GitBook to generate the website via a GitHub action.</p> <p>By submitting content ideas and corrections you are agreeing they can be used in this workshop under the Creative Commons Attribution ShareAlike 4.0 International license.  Attribution will be detailed via GitHub contributors.</p> <p>All content and interaction with any persons or systems must be done so with respect and within the Practicalli Code of Conduct.</p>"},{"location":"introduction/contributing/#book-status","title":"Book status","text":""},{"location":"introduction/contributing/#submit-and-issue-or-idea","title":"Submit and issue or idea","text":"<p>If something doesnt seem quite right or something is missing from the book, please raise an issue via the GitHub repository explaining in as much detail as you can.</p>"},{"location":"introduction/contributing/#considering-a-pull-request","title":"Considering a Pull request?","text":"<p>Before investing any time in a pull request, please raise an issue explaining the situation.  This can save you and the maintainer time and avoid rejected pull requests.</p> <p>Please keep pull requests small and focused, as they are much quicker to review and easier to accept.  Ideally PR's should be for a specific page or at most a section.</p> <p>A PR with a list of changes across different sections will not be merged, it will be reviewed eventually though.</p>"},{"location":"introduction/contributing/#thank-you-to-everyone-that-has-contributed","title":"Thank you to everyone that has contributed","text":"<p>A huge thank you to Rich Hickey and the team at Cognitect for creating and continually guiding the Clojure language.  Special thank you to Alex Miller who has provided excellent advice on working with Clojure and the CLI tooling.</p> <p>The Clojure community has been highly supportive of everyone using Clojure and I'd like to thank everyone for the feedback and contributions.  I would also like to thank everyone that has joined in with the London Clojurins community, ClojureBridgeLondon, Clojurians Slack community, Clojurians Zulip community and Clojureverse community.</p> <p>Thank you to everyone who sponsors the Practicalli websites and videos and for the Clojurists Together sponsorship, it helps me continue the work at a much faster pace.</p> <p>Special thanks to Bruce Durling for getting me into Cloure in the first place.</p> <p></p>"},{"location":"introduction/figwheel/","title":"Figwheel","text":"<p>Figwheel builds your ClojureScript code and hot loads it into the browser as you are coding!</p> <ul> <li>A 6 minute flappy bird demo of figwheel</li> <li>A more detailed 45 minute talk on Figwheel given at ClojureWest 2015.</li> <li>An introductory blog post.</li> </ul> <p>Current version</p> <pre><code>com.bhauman/figwheel-main {:mvn/version \"0.2.18\"}\n</code></pre> <p></p> Figwheel-main superseds Figwheel <p>New projects should use <code>figwheel-main</code> library as figwheel is no longer developed.  Clojure application code should be largely the same between the two tools, so should be relatively easy to migrate.</p> <p>Any content refering to the original version of Figwheel should be replaced by figwheel-main</p>"},{"location":"introduction/figwheel/#live-code-reloading","title":"Live code reloading","text":"<p>Write reloadable code to ensure figwheel can facilitate automated live interactive programming. Every time a ClojureScript source file is saved the changes are sent to the browser to show the effects of modifying your code in real time.</p> <p>This live code reloading also applies to CSS &amp; JavaScript.</p>"},{"location":"introduction/figwheel/#heads-up-display","title":"Heads up display","text":"<p>Figwheel has a non-intrusive heads up display that gives you feedback on how well your project is compiling. By writing a shell script you can click on files in the heads up display and they will open in your editor!</p>"},{"location":"introduction/figwheel/#built-in-clojurescript-repl","title":"Built-in ClojureScript REPL","text":"<p>When you launch figwheel it not only starts a live building/reloading process but it also optionally launches a CLJS REPL into your running application. This REPL shares compilation information with the figwheel builder, so as you change your code the REPL is also aware of the code changes. The REPL also has some special built-in control functions that allow you to control the auto-building process and execute various build tasks without having to stop and rerun lein-figwheel.</p>"},{"location":"introduction/figwheel/#robust-connection","title":"Robust connection","text":"<p>Figwheel's connection is fairly robust with sessions that can last for days through multiple OS sleeps. You can also use figwheel like a REPL if you are OK with using <code>print</code> to output the evaluation results to the browser console.</p>"},{"location":"introduction/figwheel/#message-broadcast","title":"Message broadcast","text":"<p>Figwheel broadcasts changes to all connected clients. This means you can see code and CSS changes take place in real time on your phone and in your laptop browser simultaneously.</p>"},{"location":"introduction/figwheel/#respects-dependencies","title":"Respects dependencies","text":"<p>Figwheel will not load a file that has not been required. It will also respond well to new requirements and dependency tree changes.</p>"},{"location":"introduction/figwheel/#calculates-minimal-reload-set","title":"Calculates minimal reload set","text":"<p>Figwheel does its best to only reload what needs to be reloaded. This minimizes the surface area of dynamically reloaded code, which in turn should increase the stability of the client environment.</p> <p>ClojureScript code that generates compiler warnings is not loaded into the browser by Figwheel, keeping the client environment stable. This behaviour is optional and can be turned off.</p>"},{"location":"introduction/figwheel/#nodejs-support","title":"Node.js Support","text":"<p>You can use figwheel to live code ClojureScript in Node.js!</p>"},{"location":"introduction/figwheel/#static-file-server","title":"Static file server","text":"<p>Figwheel includes a static file server</p> <p><code>:ring-handler</code> option allows loading of a Clojure ring handler into the figwheel server.</p> <p>appreciation of ClojureScript for design</p>"},{"location":"introduction/hiccup-style-syntax/","title":"Hiccup style syntax for generating HTML","text":"<p>Rather that write HTML code, you can use Clojure to write it for you.  This provides a simpler to type syntax based on the vector in Clojure.</p> <p>Instead of angle bracket <code>&lt; &gt;</code> and tags like <code>p</code>. you can define section using vectors <code>[ ]</code> and <code>:keywords</code>.</p>"},{"location":"introduction/hiccup-style-syntax/#examples","title":"Examples","text":"<pre><code>\n(require '[reagent.core :as r])\n</code></pre> <p>So for a header you would write</p> <pre><code>[:div\n[:h1 \"I am a header\"]]\n</code></pre> <p>A simple piece of HTML (for web pages)</p> <pre><code>[:div\n  [:h1 \"This is HTML code generated by Clojure\"]\n  [:p \"Hiccup is a simple way to write HTML in Clojure, without all those angle brackets\"]\n  [:a {:href \"https://github.com/weavejester/hiccup\"}\n  \"Read more about Hiccup at its Github repository\"]]\n</code></pre> <p>We can also create HTML for displaying images</p> <pre><code>[:img\n {:src \"https://avatars1.githubusercontent.com/u/9254615?v=3&amp;s=150\"}]\n</code></pre>"},{"location":"introduction/reloadable-code/","title":"Reloadable Code","text":"<p>Writing reloadable code in Clojure and ClojureScript is highly recommended to support the REPL workflow and reload code without adversely affecting the behavior of the system.</p> <p>Reagent and similar ClojureScript libraries strongly encourage a code design conducive to code reloading,</p> <p>Reloadable code by nature is more robust and maintainable.</p> <p>Three key concepts:</p> <ul> <li>idempotent functions</li> <li>define initial state once</li> <li>logical code segregation.</li> </ul>"},{"location":"introduction/reloadable-code/#idempotent-functions","title":"Idempotent Functions","text":"<p>An Idempotent function has the same effect whether it is called once or many times.</p> <p>All functions that are reloaded should be idempotent, otherwise unpredictable side effects may occur on every reload</p> <p>For instance, a function that sets the innerHTML property of a DOM element is idempotent, but a function that appends a child to some other element is not:</p> <p>Idempotent vs Non-Idempotent Functions</p> <pre><code>(defn append-element [parent child]   ;; (1)!\n(.appendChild parent child))\n(defn set-content [element content]      ;; (2)!\n(set! (.-innerHTML element) content))\n</code></pre> <ol> <li>Non-idempotent function</li> <li>Idempotent function</li> </ol> <p><code>append-element</code> function is not idempotent as the <code>parent</code> value is modified by the <code>child</code> each time.</p> <p><code>set-content</code> function is idempotent as <code>element</code> is set each time so the result is going to be the same.</p> <p>Idempotent append-element function</p> <pre><code>(defn append-element [parent child]\n(when-not (.contains parent child)\n(.appendChild parent child)))\n</code></pre>"},{"location":"introduction/reloadable-code/#define-initial-state-once","title":"Define Initial State Once","text":"<p>State values that change whilst the application is running should define the initial start state values so they are evaluated only once (per REPL session)</p> <p><code>defonce</code> is a clojure.core macro that wraps the <code>def</code> behaviour to ensure its value is only evaluated if it has not yet been evaluated (has no root in the namespace)</p> <p>Figwheel-main templates that use Reagent typically use an atom to manage the state and this is defined using a <code>defonce</code> form.</p> <p>Using <code>defonce</code> for the app-state ensures the app-state is not reset to the initial state each time a change is saved and triggers Figwheel-main to reload the code.  Even if the value defined by <code>defonce</code> is changed and evaluated, the new value will not be used</p> <p>Figwheel-main app-state for Reagent</p> <pre><code>(defonce app-state (atom {:text \"Hello world!\"}))\n</code></pre> <p>Hack a change to the app-state</p> <p>Change <code>defonce</code> to <code>def</code> will allow the value of app-state to be evaluated again, if the initial app-state really needs to change.</p> <p><code>(swap! ,,,)</code> or <code>(reset!)</code> in a <code>(comment ,,,)</code> rich comment blog is the common approach to changing or resetting the app-state <pre><code>(comment\n(deref app-state)  ;; (1)! View the current app-state value\n(swap! app-state assoc :text \"Modified app-state value\") ;; (2)! Change the app-state value\n(reset! app-state {:text \"Reset app-state value\"}) ;; (3)! Change the app-state value\n)\n</code></pre> 1. View the contents of the app-state atom 2. Associate (add to) the value contained in the app-state atom. Use update instead of assoc to change an existing value 3. Reset the app-state value, typically to a known start state value</p>"},{"location":"introduction/reloadable-code/#define-initialisation-code-once","title":"Define Initialisation Code Once","text":"<p><code>defonce</code> can be used to protect initialization code from running repeatedly.</p> <p>A defonce expression takes the form: (defonce name expr) where name is a symbol that names the var to bind and expr is any ClojureScript expression. Not only does defonce prevent the var from being redefined, it also prevents expr from being re-evaluated when the var is bound. This means that we can wrap initialization code with a defonce to guarantee that it will only be evaluated once, regardless of how often the code is reloaded:</p> <p>Wrap Initialisation Code to run only once</p> <pre><code>(defonce initialised?\n(do                                                      ;; (1)!\n(.setItem js/localStorage \"init-at\" (.now js/Date))\n(js/alert \"Initialising System Configuration!\")\ntrue))                                                 ;; (2)!\n</code></pre> <ol> <li>do can evaluates multiple expressions in turn, returning the resutl of evaluating the last expression</li> <li><code>initialised?</code> uses the <code>?</code>predicate name form, so a boolean value is returned by convention</li> </ol> <p><code>initialised?</code> is only evaluated once and bound to the value <code>true</code> once initialisation is complete.</p> <p><code>do</code> evaluates each expression in turn and returns the value of the final expression.  The expressions before the last typically have side effect, e.g. setting local storage, logging, alerts, etc.</p>"},{"location":"introduction/reloadable-code/#logical-grouping","title":"Logical Grouping","text":"<p>New projects typically start with a single Clojure namespace and a few functions.  As the project grows, new namespaces can be defined to logically separate the different aspects of the application.</p> <p>Examples of logical namespace groups can include</p> <ul> <li>View of information</li> <li>data transformation</li> <li>domain (e.g. business) rules</li> <li>communication with the outside word (databases, message systems, UI, APIs, etc.)</li> </ul> <p>As code grows, its also important to ensure that function definitions do not become convoluted in their behaviour.  Each function should do one specific thing and where possible be pure and idempotent.</p> <p>In a messaging system (chat, email, social, etc), define a function to append a new message to a feed.</p> <p>Convoluted function to recieve and add message to feed</p> <p>The function design does not separate the logic of receiving a new message from displaying it: <pre><code>(defn message [text date-time]\n(let [node (.createElement js/document \"div\")]\n(set! (.- innerHTML node) (str \"[\" date-time \"]: \" text))\n(.appendChild messages-feed node)))\n</code></pre></p> <p>Should the user interface api no longer require the date-time information, the <code>message</code> function also requires a refactor.</p> <p>Refactor the code to hold the messages in an atom which is empty to start with.  Split the <code>message</code> function by its logical concerns.</p> <p>Separation of concerns</p> <pre><code>(defonce messages (atom []))           ;; (1)!\n(defn message [text timestamp]         ;; (2)!\n(swap! messages conj\n{:text text :timestamp timestamp}))\n(defn publish! [messages]              ;; (3)!\n(set! (.- innerHTML messages-feed) \"\")\n(doseq [message @messages]\n(let [node (.createElement js/document \"div\")]\n(set! (.-innerHTML node) (str \"[\" timestamp \"]: \" text))\n(.appendChild messages-feed node))))\n(comment\n(publish!))                          ;; (4)!\n</code></pre> <ol> <li>Incoming messages are stored in an atom which is defined once (per REPL sesison)</li> <li><code>message</code> is a business logic function</li> <li><code>publish!</code> is view logic function</li> <li>Use rich comment to publish messages to the feed</li> </ol> <p>Reagent and similar frameworks will automatically trigger publish! updates when the data being managed changes.</p>"},{"location":"introduction/repl-workflow/","title":"REPL Driven Development","text":"<p>Always be REPL'ing</p> <p>Coding without a REPL feels limiting. The REPL provides fast feedback from code as its crafted, testing assumptions and design choices every step of the journey to a solution  - John Stevenson, Practical.li</p> <p>REPL driven development is the foundation of working with Clojure effectively</p> <p>An effective Clojure workflow begins by running a REPL process.  Clojure expressions are written and evaluated immediately to provide instant feedback as design decisions are coded.</p> <p>The REPL feedback tests the assumptions driving design choices.  Important design choices provide data which can be codified into unit tests, optionally using spec and generative testing.</p> <ul> <li>Read - code is read by the Clojure reader, passing any macros to the macro reader which converts those macros into Clojure code.</li> <li>Evaluate - code is compiled into the host language (e.g. Java bytecode) and executed</li> <li>Print - results of the code are displayed, either in the REPL or as part of the application.</li> <li>Loop - the REPL is a continuous process that evaluates code, either a single expression or the whole application.</li> </ul>"},{"location":"introduction/repl-workflow/#evaluating-source-code","title":"Evaluating source code","text":"<p>A REPL connected editor is the primary tool for evaluating Clojure code from source code files, displaying the results inline.</p> <p>Source code is automatically evaluated in its respective namespace, removing the need to change namespaces in the REPL, (<code>in-ns</code>), or use fully qualified names to call functions.</p> <p> </p> Evaluate Clojure in a Terminal UI REPL <p>Entering expressions at the REPL prompt evaluates the expression immediately, returning the result directly underneath </p>"},{"location":"introduction/repl-workflow/#rich-comment-blocks-living-documentation","title":"Rich Comment blocks - living documentation","text":"<p>The <code>(comment ,,,)</code> function wraps code that is only run directly by the developer using a Clojure aware editor.</p> <p>Expressions in rich comment blocks can represent how to use the functions that make up the namespace API.  For example, starting/restarting the system, updating the database, etc.  Expressions provide examples of calling functions with typical arguments and make a project more accessible and easier to work with.</p> <p></p> <p>Rich comment blocks are very useful for rapidly iterating over different design decisions by including the same function but with different implementations.  Hide clj-kondo linter warnings for redefined vars (<code>def</code>, <code>defn</code>) when using this approach.</p> <pre><code>;; Rich comment block with redefined vars ignored\n#_{:clj-kondo/ignore [:redefined-var]}\n(comment\n(defn value-added-tax []\n;; algorithm design - first try)\n(defn value-added-tax []\n;; algorithm design - first try)\n) ;; End of rich comment block\n</code></pre> <p>The \"Rich\" in the name is an honourary mention to Rich Hickey, the author and benevolent dictator of Clojure design.</p>"},{"location":"introduction/repl-workflow/#design-journal","title":"Design Journal","text":"<p>A journal of design decisions makes the code easier to understand and maintain.  Code examples of design decisions and alternative design discussions are captured, reducing the time spent revisiting those discussions.</p> <p>Journals simplify the developer on-boarding processes as the journey through design decisions are already documented.</p> <p>A Design Journal is usually created in a separate namespace, although it may start as a rich comment at the bottom of a namespace.</p> <p>A journal should cover the following aspects</p> <ul> <li>Relevant expressions use to test assumptions about design options.</li> <li>Examples of design choices not taken and discussions why (saves repeating the same design discussions)</li> <li>Expressions that can be evaluated to explain how a function or parts of a function work</li> </ul> <p>The design journal can be used to create meaningful documentation for the project very easily and should prevent time spent on repeating the same conversations.</p> <p>Example design journal</p> <p>Design journal for TicTacToe game using Reagent, ClojureScript and Scalable Vector Graphics</p>"},{"location":"introduction/repl-workflow/#viewing-data-structures","title":"Viewing data structures","text":"<p>Pretty print shows the structure of results from function calls in a human-friendly form, making it easier for a developer to parse and more likely to notice incorrect results.</p> <p>, e p on the Spacemacs Clojure menu has several commands to Pretty Print data structure results when evaluating code.</p> <p>, d v is the Cider Inspect menu for paging through very large data sets and navigate nested data structures in detail.</p> <p></p> <p>, d is the Cider debug menu which can inspect view intermediate values and data structures during the debugging of Clojure function calls.</p> <p>Cider inspector is an effective way to navigate nested data and page through large data sets.</p> <p>External data browsers can visualise data in many different forms.</p> <p></p>"},{"location":"introduction/repl-workflow/#code-style-and-idiomatic-clojure","title":"Code Style and idiomatic Clojure","text":"<p>Clojure aware editors should automatically apply formatting that follows the Clojure Style guide.</p> <p>Live linting with clj-kondo suggests common idioms and highlights a wide range of syntax errors as code is written, minimizing bugs and therefore speeding up the development process.</p> <p> </p> <p>Clojure Style Guide</p> <p>The Clojure Style guide provides examples of common formatting approaches, although the development team should decide which of these to adopt.  Emacs <code>clojure-mode</code> will automatically format code and so will Clojure LSP (via cljfmt).  These tools are configurable and should be tailored to the teams standard.</p>"},{"location":"introduction/repl-workflow/#test-driven-development-and-repl-driven-development","title":"Test Driven Development and REPL Driven Development","text":"<p>Test Driven Development (TDD) and REPL Driven Development (RDD) complement each other as they both encourage incremental changes and continuous feedback.</p> <p>Test Driven Development fits well with Hammock Time, as good design comes from deep thought</p> <ul> <li>RDD enables rapid design experiments so different approaches can easily and quickly be evaluated .</li> <li>TDD focuses the results of the REPL experiments into design decisions, codified as unit tests.  These tests guide the correctness of specific implementations and provide critical feedback when changes break that design.</li> </ul> <p>Unit tests should support the public API of each namespace in a project to help prevent regressions in the code.  Its far more efficient in terms of thinking time to define unit tests as the design starts to stabilize than as an after thought.</p> <p><code>clojure.test</code> library is part of the Clojure standard library that provides a simple way to start writing unit tests.</p> <p>Clojure spec can also be used for generative testing, providing far greater scope in values used when running unit tests.  Specifications can be defined for values and functions.</p> <p>Clojure has a number of test runners available.  Kaocha is a test runner that will run unit tests and function specification checks.</p> <p>Automate local test runner</p> <p>Use kaocha test runner in watch mode to run tests and specification check automatically (when changes are saved) <pre><code>clojure -X:test/watch\n</code></pre></p>"},{"location":"introduction/repl-workflow/#continuous-integration-and-deployment","title":"Continuous Integration and Deployment","text":"<p>Add a continuous integration service to run tests and builds code on every shared commit.  Spin up testable review deployments when commits pushed to a pull request branch, before pushing commits to the main deployment branch, creating an effective pipeline to gain further feedback.</p> <ul> <li>CircleCI provides a simple to use service that supports Clojure projects.</li> <li>GitHub Workflows and GitHub actions marketplace  to quickly build a tailored continuous integration service, e.g. Setup Clojure GitHub Action.</li> <li>GitLab CI</li> </ul> <p></p>"},{"location":"introduction/repl-workflow/#live-coding-with-data-stuart-halloway","title":"Live Coding with Data - Stuart Halloway","text":"<p>There are few novel features of programming languages, but each combination has different properties. The combination of dynamic, hosted, functional and extended Lisp in Clojure gives developers the tools for making effective programs. The ways in which Clojure's unique combination of features can yield a highly effective development process.</p> <p>Over more than a decade we have developed an effective approach to writing code in Clojure whose power comes from composing many of its key features. As different as Clojure programs are from e.g. Java programs, so to can and should be the development experience. You are not in Kansas anymore!</p> <p>This talk presents a demonstration of the leverage you can get when writing programs in Clojure, with examples, based on my experiences as a core developer of Clojure and Datomic.</p> <p> </p>"},{"location":"introduction/single-page-apps/","title":"Single Page Applications","text":""},{"location":"introduction/writing-tips/","title":"Writing tips for MkDocs","text":"<p>Making the docs more engaging using the mkdocs-material theme reference guide</p> Configuring Colors <p>Material for MkDocs - Changing the colors lists the primary and accent colors available.</p> <p>HSL Color Picker for codes to modify the theme style, overriding colors in <code>docs/assets/stylesheets/extra.css</code></p>"},{"location":"introduction/writing-tips/#hypertext-links","title":"Hypertext links","text":"<p>Links open in the same browser window/tab by default.</p> <p>Add <code>{target=_blank}</code> to the end of a link to configure opening in a new tab</p> <pre><code>[link text](url){target=_blank}\n</code></pre>"},{"location":"introduction/writing-tips/#buttons","title":"Buttons","text":"<p>Convert any link into a button by adding <code>{.md-button}</code> class names to end of the markdown for a link, which uses <code>.md-button-primary</code> by default.  Include <code>target=_blank</code> for buttons with links to external sites.</p> <pre><code>[link text](http://practical.li/blog){.md-button target=_blank}\n</code></pre> <p>Or specify a different class</p> <pre><code>[link text](http://practical.li/blog){.md-button .md-button-primary}\n</code></pre> <p>Add an icon to the button</p> <p> Practicalli Issues  Practicalli Blog</p> <pre><code>[:fontawesome-brands-github: Practicalli Issues](http://practical.li/blog){ .md-button .md-button-primary }\n[:octicons-heart-fill-24: Practicalli Blog](http://practical.li/blog){ .md-button .md-button-primary }\n</code></pre> <p>Search all supported icons</p>"},{"location":"introduction/writing-tips/#youtube-video","title":"YouTube video","text":"<p>Use an iframe element to include a YouTube video, wrapping in a paragraph tag with center alignment to place the video in a centered horizontal position</p> <pre><code>&lt;p style=\"text-align:center\"&gt;\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/rQ802kSaip4\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;\n&lt;/p&gt;\n</code></pre> <p>mkdocs material does not have direct support for adding a YouTube video via markdown.</p>"},{"location":"introduction/writing-tips/#admonitions","title":"Admonitions","text":"<p>Supported admonition types</p> <p>Note</p> <p>Use <code>!!!</code> followed by <code>NOTE</code></p> <p>Adding a title</p> <p>Use <code>!!!</code> followed by <code>NOTE</code> and a <code>\"title in double quotes\"</code></p> <p>Shh, no title bar just the text... Use <code>!!!</code> followed by <code>NOTE</code> and a <code>\"\"</code> empty double quotes</p> <p>Abstract</p> <p>Use <code>!!!</code> followed by <code>ABSTRACT</code></p> <p>Info</p> <p>Use <code>!!!</code> followed by <code>INFO</code></p> <p>Tip</p> <p>Use <code>!!!</code> followed by <code>TIP</code></p> <p>Success</p> <p>Use <code>!!!</code> followed by <code>SUCCESS</code></p> <p>Question</p> <p>Use <code>!!!</code> followed by <code>QUESTION</code></p> <p>Warning</p> <p>Use <code>!!!</code> followed by <code>WARNING</code></p> <p>Failure</p> <p>Use <code>!!!</code> followed by <code>FAILURE</code></p> <p>Danger</p> <p>Use <code>!!!</code> followed by <code>DANGER</code></p> <p>Bug</p> <p>Use <code>!!!</code> followed by <code>BUG</code></p> <p>Example</p> <p>Use <code>!!!</code> followed by <code>EXAMPLE</code></p> <p>Quote</p> <p>Use <code>!!!</code> followed by <code>QUOTE</code></p>"},{"location":"introduction/writing-tips/#collapsing-admonitions","title":"Collapsing admonitions","text":"Note <p>Collapse those admonitions using <code>???</code> instead of <code>!!!</code></p> Replace with a title <p>Use <code>???</code> followed by <code>NOTE</code> and a <code>\"title in double quotes\"</code></p> Expanded by default <p>Use <code>???+</code>, note the <code>+</code> character,  followed by <code>NOTE</code> and a <code>\"title in double quotes\"</code></p>"},{"location":"introduction/writing-tips/#inline-blocks","title":"Inline blocks","text":"<p>Inline blocks of text to make a very specific callout within text</p> <p>Info</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Adding something to then end of text is probably my favourite</p> <p>Info</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"introduction/writing-tips/#code-blocks","title":"Code blocks","text":"<p>Code blocks include a copy icon automatically</p> <p>Syntax highlighting in code blocks</p> <pre><code>(defn my-function  ; Write a simple function\n\"With a lovely doc-string\"\n[arguments]\n(map inc [1 2 3]))\n</code></pre> <p>Give the code block a title using <code>title=\"\"</code> after the backtics and language name</p> src/practicalli/gameboard.clj<pre><code>(defn my-function\n\"With a lovely doc-string\"\n[arguments]\n(map inc [1 2 3]))\n</code></pre> <p>We all like line numbers, especially when you can set the starting line</p> src/practicalli/gameboard.clj<pre><code>(defn my-function\n\"With a lovely doc-string\"\n[arguments]\n(map inc [1 2 3]))\n</code></pre> <p>Add <code>linenums=42</code> to start line numbers from 42 onward</p> <pre><code>clojure linenums=\"42\" title=\"src/practicalli/gameboard.clj\"\n</code></pre>"},{"location":"introduction/writing-tips/#annotations","title":"Annotations","text":"<p>Annotations in a code block help to highlight important aspects.  Use the comment character for the language followed by a space and a number in brackets</p> <p>For example, in a shell code block, use <code># (1)</code> where 1 is the number of the annotation</p> <p>Use a number after the code block to add the text for the annotation, e.g. <code>1.</code>. Ensure there is a space between the code block and the annotation text.</p> <pre><code>ls -la $HOME/Downloads  # (1)\n</code></pre> <ol> <li> I'm a code annotation! I can contain <code>code</code>, formatted text, images, ... basically anything that can be written in Markdown.</li> </ol> <p>Code blocks with annotation, add <code>!</code> after the annotation number to suppress the <code>#</code> character</p> <pre><code>(defn helper-function\n\"Doc-string with description of function purpose\" ; (1)!\n[data]\n(merge {:fish 1} data)\n)\n</code></pre> <ol> <li>Always include a doc-string in every function to describe the purpose of that function, identifying why it was added and what its value is.</li> </ol> <p>GitHub action example with multiple annotations</p> <pre><code>name: ci # (1)!\non:\npush:\nbranches:\n- master # (2)!\n- main\npermissions:\ncontents: write\njobs:\ndeploy:\nruns-on: ubuntu-latest\nsteps:\n- uses: actions/checkout@v3\n- uses: actions/setup-python@v4\nwith:\npython-version: 3.x\n- run: pip install mkdocs-material # (3)!\n- run: mkdocs gh-deploy --force\n</code></pre> <ol> <li> <p>You can change the name to your liking.</p> </li> <li> <p>At some point, GitHub renamed <code>master</code> to <code>main</code>. If your default branch     is named <code>master</code>, you can safely remove <code>main</code>, vice versa.</p> </li> <li> <p>This is the place to install further [MkDocs plugins] or Markdown     extensions with <code>pip</code> to be used during the build:</p> <pre><code>pip install \\\nmkdocs-material \\\nmkdocs-awesome-pages-plugin \\\n...\n</code></pre> </li> </ol>"},{"location":"introduction/writing-tips/#highlight-lines-in-code-blocks","title":"Highlight lines in code blocks","text":"<p>Add highlight line meta data to a code block after the opening backticks and code block language.</p> <p><code>hl_lines=\"2\"</code> highlights line 2 in the codeblock</p> <p>```clojure hl_lines=\"2,4\" (defn my-function   \"With a lovely doc-string\"   [arguments]   (map    inc    [1 2 3])) <pre><code>## Content tabs\n\nCreate in page tabs that can also be\n\nSetting up a project\n\n=== \"Clojure CLI\"\n    ```shell\n    clojure -T:project/new :template app :name practicalli/gameboard\n    ```\n\n=== \"Leiningen\"\n    ```shell\n    lein new app practicalli/gameboard\n    ```\n\nOr nest the content tabs in an admonition\n\n!!! INFO \"Run a terminal REPL\"\n\n    === \"Clojure CLI\"\n        ```shell\n        clojure -T:repl/rebel\n        ```\n\n    === \"Leiningen\"\n        ```shell\n        lein repl\n        ```\n\n## Diagrams\n\nNeat flow diagrams\n\n``` mermaid\ngraph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];\n</code></pre></p> <p>UML Sequence Diagrams</p> <pre><code>sequenceDiagram\n  Alice-&gt;&gt;John: Hello John, how are you?\n  loop Healthcheck\n      John-&gt;&gt;John: Fight against hypochondria\n  end\n  Note right of John: Rational thoughts!\n  John--&gt;&gt;Alice: Great!\n  John-&gt;&gt;Bob: How about you?\n  Bob--&gt;&gt;John: Jolly good!</code></pre> <p>state transition diagrams</p> <pre><code>stateDiagram-v2\n  state fork_state &lt;&lt;fork&gt;&gt;\n    [*] --&gt; fork_state\n    fork_state --&gt; State2\n    fork_state --&gt; State3\n\n    state join_state &lt;&lt;join&gt;&gt;\n    State2 --&gt; join_state\n    State3 --&gt; join_state\n    join_state --&gt; State4\n    State4 --&gt; [*]</code></pre> <p>Class diagrams - but dont need them.</p> <p>Entity relationship diagrams are handy though</p> <pre><code>erDiagram\n  CUSTOMER ||--o{ ORDER : places\n  ORDER ||--|{ LINE-ITEM : contains\n  CUSTOMER }|..|{ DELIVERY-ADDRESS : uses</code></pre>"},{"location":"introduction/writing-tips/#other-diagram-types","title":"Other diagram types","text":"<p>Besides the diagram types listed above, [Mermaid.js] provides support for pie charts, gantt charts, user journeys, git graphs and requirement diagrams, all of which are not officially supported by Material for MkDocs. Those diagrams should still work as advertised by [Mermaid.js], but we don't consider them a good choice, mostly as they don't work well on mobile.</p>"},{"location":"introduction/writing-tips/#keyboard-keys","title":"Keyboard keys","text":"<p>Represent key bindings with Keyboard keys. Each number and alphabet character has their own key.</p> <ul> <li>1 <code>++1++</code> for numbers</li> <li>l <code>++\"l\"++</code> for lowercase character</li> <li>U <code>++u++</code> for uppercase character or <code>++\"U\"++</code> for consistency</li> </ul> <p>Punctionation keys use their name</p> <ul> <li>Space <code>++spc++</code></li> <li>, <code>++comma++</code></li> <li>Left <code>++arrow-left++</code></li> </ul> <p>For key sequences, place a space between each keyboard character</p> <ul> <li>Space g s <code>++spc++ ++\"g\"++ ++\"s\"++</code></li> </ul> <p>For key combinations, use join they key identifies with a <code>+</code></p> <ul> <li>Meta+X <code>++meta+x++</code></li> <li>Ctrl+Alt+Del <code>++ctrl+alt+del++</code></li> </ul> <p>MkDocs keyboard keys reference</p>"},{"location":"introduction/writing-tips/#grids","title":"Grids","text":"<p>Useful for putting button links on the main page as quick links into the key parts of the book</p> <ul> <li> HTML for content and structure</li> <li> JavaScript for interactivity</li> <li> CSS for text running out of boxes</li> <li> Internet Explorer ... huh?</li> </ul> <p>Sponsor only feature</p>"},{"location":"introduction/writing-tips/#images","title":"Images","text":"<p>Markdown images can be appended with material tags to set the size of the image, whether to appear on light or dark theme and support lazy image loading in browsers</p> SizeLazy LoadingAlignTheme SpecificAll Image Attributes <p><code>{style=\"height:150px;width:150px\"}</code> specifies the image size <pre><code>![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png#only-dark){style=\"height:150px;width:150px\"}\n</code></pre></p> <p></p> <p><code>{loading=lazy}</code> specifies an image should lazily load in the browser <pre><code>![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png){loading=lazy}\n</code></pre></p> <p><code>{aligh=left}</code> or <code>{aligh=right}</code> specifies the page alignment of an image. <pre><code>![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png#only-dark){align=right}\n![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-dark.png#only-light){align=right}\n</code></pre></p> <p>  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p><code>![Kitty Logo](image/kitty-light.png#only-dark)</code> or <code>![Kitty Logo](image/kitty-light.png#only-light)</code>  specifies the theme the image should be shown, allowing different versions of images to be shown based on the theme. <pre><code>![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png#only-dark){style=\"height:150px;width:150px\"}\n![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-dark.png#only-light){style=\"height:150px;width:150px\"}\n</code></pre> Use the theme toggle in the top nav bar to see the icon change between light and dark.  </p> <p>Requires the color pallet toggle</p> <p>Alight right, lazy load and set image to 150x150</p> <pre><code>![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png#only-dark){align=right loading=lazy style=\"height:64px;width:64px\"}\n![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-dark.png#only-light){align=right loading=lazy style=\"height:64px;width:64px\"}\n</code></pre> <p>  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"introduction/writing-tips/#lists","title":"Lists","text":"<p>Task lists</p> <ul> <li> Lorem ipsum dolor sit amet, consectetur adipiscing elit</li> <li> Vestibulum convallis sit amet nisi a tincidunt<ul> <li> In hac habitasse platea dictumst</li> <li> In scelerisque nibh non dolor mollis congue sed et metus</li> <li> Praesent sed risus massa</li> </ul> </li> <li> Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque</li> </ul> <p>Task List example</p> <pre><code>- [x] Lorem ipsum dolor sit amet, consectetur adipiscing elit\n- [ ] Vestibulum convallis sit amet nisi a tincidunt\n    * [x] In hac habitasse platea dictumst\n    * [x] In scelerisque nibh non dolor mollis congue sed et metus\n    * [ ] Praesent sed risus massa\n- [ ] Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque\n</code></pre>"},{"location":"introduction/writing-tips/#tooltips","title":"Tooltips","text":"<p>The humble tool tip</p> <p>Hover me</p> <p>with references</p> <p>Hover me</p> <p>Icon tool tip with a title</p> <p></p>"},{"location":"introduction/writing-tips/#abreviations","title":"Abreviations","text":"<p>The HTML specification is maintained by the W3C.</p> <p>[HTML]: Hyper Text Markup Language [W3C]: World Wide Web Consortium</p>"},{"location":"introduction/writing-tips/#magic-links","title":"Magic links","text":"<p>MagicLink can auto-link HTML, FTP, and email links. It can auto-convert repository links (GitHub, GitLab, and Bitbucket) and display them in a more concise, shorthand format.</p> <p>Email Practicalli</p> <p>Practicalli Neovim</p>"},{"location":"lighttable/","title":"Lighttable","text":""},{"location":"lighttable/configure-keyboard-mappings/","title":"Configure Keyboard mappings","text":""},{"location":"om/","title":"Om","text":"<p>Om is a react framework for Clojurescript that models the React.js API very closely, as can be see in the Om documentation.</p>"},{"location":"om/overview/","title":"Om overview","text":""},{"location":"om/overview/#om-root","title":"Om root","text":"<p>om.core/root establishes an Om rendering loop on a specific element in the DOM. </p> <p><code>om.core/root</code> is idempotent (can be repeatedly called without affecting successive results). You may safely call it multiple times. </p> <p>Only one Om render loop is ever allowed on a particular DOM target.  You can of course create multiple DOM targets in an app with an Om root for each target.</p> <p><code>om.core/root</code> takes a function that creates a component, state in the form an associative data structure (map or vector) and the DOM element that defines where on the page the app is included.</p> <p><code>om.core/root</code> takes the following form:</p> <pre><code>(defn root\n([f value options] ...))\n</code></pre> <p><code>f</code> is a function returning an instance of IRender or IRenderState. f takes two arguments, a root cursor on the application state and the backing Om component for the root.</p> <p><code>value</code> is either a tree of associative ClojureScript data structures or an atom wrapping a tree of associative ClojureScript data structures.</p> <p><code>options</code> is a map containing any key allowed to <code>om.core/build</code>. Additionally the following keys are allowed/required:</p> <ul> <li> <p>:target (required)</p> </li> <li> <p>:shared (optional) in order to provide global services</p> </li> <li> <p>:tx-listen a function that will listen in on transactions, should take 2 arguments: a map containing the path, old and new state at path, old and new global state, and transaction tag if provided (:path, :old-value, :new-value, :old-state, :new-state and :tag). the root cursor.</p> </li> <li> <p>:path to specify the path of the cursor into app-state (see #72)</p> </li> <li> <p>:instrument a function of three arguments that if provided will intercept all calls to om.core/build. The function arguments correspond exactly to the three argument arity of om.core/build</p> </li> </ul> <pre><code>(om.core/root\n(fn [app-state owner]\n(reify\nom.core/IRender\n(render [_]\n(dom/h1 nil (:text app-state)))))\n{:text \"Hello world!\"}\n{:target (. js/document getElementById \"my-app\")})\n</code></pre>"},{"location":"om/overview/#app-state-atom","title":"App-state atom","text":"<p>One of the cornerstones of an Om app is the app state atom. Every application has state. Any web app framework has to deal with it. In Om, we manage state with an atom. The atom points at the current state of the application, which is that little map there in the white box. And every time the state changes, the components need to be re-rendered.</p> <p>In ClojureScript, we create an atom with a function called <code>atom</code>. The app state needs to be associative, which means either a map or a vector.</p> <p>We\u2019re going to be live reloading our code. Each time it loads, this line would redefine appstate to a new atom. We only want to load it once. So we use <code>defonce</code> instead of <code>def</code>.</p>"},{"location":"om/overview/#render","title":"Render","text":"<p>If you want to put HTML into the page, you do so in render. We use the om.dom namespace to create dom nodes. There are functions there for any kind of HTML tag you need to create.</p> <p>The first argument to each of them is always the HTML attributes, you know, the style, the class, all of the stuff that goes after the tag name in the HTML tag. We\u2019ll see how to do those later. Just remember to putnil there for now to mean \u201cno attributes\u201d.</p> <p>The rest of the arguments become the children (sub elements in the tree), and the tag is closed for you, if it needs to be. React knows which tags to close, so you don\u2019t have to remember all of that.</p>"},{"location":"om-project-clojurex/","title":"Om Project: ClojureX conference application","text":"<p>Creating a full stack clojurescript app with Om that will provide an interactive experience for conference attendees.</p> <ul> <li>Browse the schedule of sessions</li> <li>Star sessions that you want to attend</li> <li>Show your schedule (sessions you have stared)</li> <li>Show sessions by topic</li> </ul>"},{"location":"om-project-clojurex/#warningout-of-date","title":"WARNING::Out of date","text":"<p>This tutorial is probably out of date and may have bugs.</p> <p>Try the TicTacToe project with reagnent.  If you prefer the Om approach, then try Rum or Fulcro</p>"},{"location":"om-project-clojurex/add-a-container/","title":"Add A Container","text":"<p>You may have noticed that the text on the web page is right up against the left hand side of the browser.  This doesnt look great.</p> <p>Add the container style to the top-most <code>div</code> element as follows:</p> <pre><code>(dom/div #js {:className \"container\"} ,,,)\n</code></pre> <p>The most suitable div is the first one in the <code>render</code> function call of the <code>root-component</code> function.  This <code>div</code> effectively wraps the whole page.</p> <pre><code>(defn root-component [app owner]\n(reify\nom/IRender\n(render [_]\n(dom/div #js {:className \"container\"}\n(dom/h1 nil (:conference-name app))\n(for [session (:sessions app)]\n(dom/div nil\n(dom/h1 nil (:title session))\n(dom/h3 nil (str \"By \" (:speaker-name session)))\n(dom/p nil (:description session))\n(dom/hr nil)\n(dom/p nil (str \"About \" (:speaker-name session) \":\"))\n(dom/p nil (:speaker-biography session))\n(dom/p nil (:twitter-handle session))\n(dom/p nil (:github-handle session))\n(dom/p nil (:speakers-website session))))))))\n</code></pre> <p>After applying the comtainer, there is now a margin around the content</p> <p></p>"},{"location":"om-project-clojurex/add-a-container/#noteadd-div-with-a-container-style-around-our-whole-page","title":"Note::Add div with a <code>container</code> style around our whole page","text":"<p>Find or create a suitable <code>div</code> element and add the bootstrap className called <code>container</code></p>"},{"location":"om-project-clojurex/add-a-container/#hintreact-styles","title":"Hint::React Styles","text":"<p>We are writing style in Clojurescript using maps, however we need to convert those styles to Javascript so that react can process them correctly.</p> <p>Om provides the <code>#js</code> macro that will convert our Clojurescript maps to the Javascript equivalents.</p> <p><code>(dom/div #js {:className \"bootstrap-style-name\"})</code></p> <p>To minimise the conversion, we use the Javascript naming convention for the style names, eg. className</p> <p>You could also put the container style in the <code>index.html</code> page, especially if you were to have multiple roots in your om project.</p>"},{"location":"om-project-clojurex/add-cursor-to-local-state/","title":"Add Cursor To Local State","text":"<pre><code>    om/IInitState\n(init-state [this]\n{:title (:title cursor)\n:description (get cursor :description \"\")\n:speaker-name (get cursor :speaker-name \"\")\n:speaker-biography (get cursor :speaker-biography \"\")\n:twitter-handle (get cursor :twitter-handle \"\")\n:github-handle (get cursor :github-handle \"\")\n:speaker-website (get cursor :speakers-website \"\")}\n</code></pre>"},{"location":"om-project-clojurex/add-cursor-to-local-state/#noteadd-cursor-to-local-state-so-it-can-be-modified","title":"Note::Add Cursor to Local state so it can be modified","text":""},{"location":"om-project-clojurex/add-cursor-to-local-state/#hint","title":"Hint::","text":"<p>The <code>get</code> function can return a default value if no value for an element is found in the collection the get function is applied to.</p>"},{"location":"om-project-clojurex/add-header-style/","title":"Add Header Style","text":"<p>To make our conference name standout, we are going to add a style.  In Bootstrap a common header style is called Jumbotron</p> <p>The <code>jumbotron</code> style can be added to the <code>h1</code> element that displays the conference name:</p> <pre><code>(dom/h1 #js {:className \"jumbotron\"} (:conference-name app))\n</code></pre> <p>If the heading is going to contain more than one dom element, then you would introduce a new <code>div</code> element with the <code>jumbotron</code> style.  This new <code>div</code> element would contain the <code>h1</code> element and any others for the heading.</p> <pre><code>(dom/div #js {:className \"jumbotron\"}\n(dom/h1 (:conference-name app)))\n</code></pre> <p>Take a look at your page and the heading should stand out much more.</p> <p></p>"},{"location":"om-project-clojurex/add-header-style/#noteadd-the-jumbotron-style-to-the-heading","title":"Note::Add the Jumbotron style to the heading","text":"<p>Edit the <code>src/clojurex/cljs/core.cljs</code> file and update the <code>root-component</code> to include the <code>jumbotron</code> style for the conference name</p> <p>Include any additional <code>div</code> elements if neccessary</p>"},{"location":"om-project-clojurex/add-session-form/","title":"Add Session Form","text":"<pre><code>(defn session-add [session component]\n(reify\nom/IRender\n(render [_]\n(dom/div nil\n(dom/h3 nil \"New Session\")\n(dom/form #js {:className \"form-horizontal\"}\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:placeholder \"Session Title\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:placeholder \"Speaker Name\"})\n(dom/textarea #js {:className \"form-control\"\n:placeholder \"Session Description\"\n:rows \"5\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:placeholder \"Speaker Biography\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:placeholder \"Twitter Handle\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:placeholder \"Github Handle\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:placeholder \"Twitter Handle\"})\n(dom/button #js {:className \"btn btn-primary\"}\n\"Submit\"))))))\n(defn root-component [app owner]\n(reify\nom/IRender\n(render [_]\n(dom/div #js {:className \"container\"}\n(dom/h1 #js {:className \"jumbotron\"} (:conference-name app))\n(for [session (:sessions app)]\n(om/build session-details session))\n(dom/hr nil)\n(om/build session-add app)))))\n</code></pre>"},{"location":"om-project-clojurex/add-session-form/#notecreate-a-session-submission-form","title":"Note::Create a Session Submission Form","text":"<p>Create a <code>session-add</code> component with a <code>dom/form</code> that includes <code>dom/input</code> for all fields.  The session description can use a <code>dom/textarea</code>.</p>"},{"location":"om-project-clojurex/add-session-style/","title":"Add Session Style","text":"<p>To make it easier to read the individual sessions, add a style called panel.  To make it interesting use a <code>primary-panel</code> style or one of the other coloured panels.</p> <pre><code>(defn root-component [app owner]\n(reify\nom/IRender\n(render [_]\n(dom/div #js {:className \"container\"}\n(dom/h1 #js {:className \"jumbotron\"} (:conference-name app))\n(for [session (:sessions app)]\n(dom/div #js {:className \"panel panel-primary\"}\n(dom/h1 #js {:className \"panel-heading\"} (:title session))\n(dom/div #js {:className \"panel-body\"}\n(dom/h3 nil (str \"By \" (:speaker-name session)))\n(dom/div nil (:description session))\n(dom/hr nil)\n(dom/div nil (str \"About \" (:speaker-name session) \":\"))\n(dom/div nil (:speaker-biography session))\n(dom/div nil (:twitter-handle session))\n(dom/div nil (:github-handle session))\n(dom/div nil (:speakers-website session)))))))))\n</code></pre> <p>Take a look at your page and the sessions should all be wrapped by a panel.</p> <p></p>"},{"location":"om-project-clojurex/add-session-style/#noteadd-the-panel-prime-style-to-each-session","title":"Note::Add the Panel Prime style to each session","text":"<p>Edit the <code>src/clojurex/cljs/core.cljs</code> file and update the <code>root-component</code> to include the <code>panel</code> style for each session</p>"},{"location":"om-project-clojurex/adding-session-data-to-state/","title":"Adding Session Data to State","text":"<p>Use the sessions defined for <code>john</code>, <code>kris</code> and <code>bug</code> and add them to the state.</p> <pre><code>(swap! app-state update :sessions conj john)\n(swap! app-state update :sessions conj kris)\n(swap! app-state update :sessions conj bug)\n</code></pre>"},{"location":"om-project-clojurex/adding-session-data-to-state/#noteadd-sessions-to-the-state","title":"Note::Add sessions to the state","text":"<p>Using the names of the session we just defined, add the sessions to the state using the REPL or add to the <code>core.cljs</code> and evaluate the code.</p> <p>Use the swap! function to update the <code>app-state</code>.  See the section on interacting with the REPL</p> <p>The update function can be used to add values to an existing key.</p>"},{"location":"om-project-clojurex/adding-session-data-to-state/#hint","title":"Hint::","text":"<p>Using the comment reader macro, <code>#_</code>, you can add code to your Clojurescript file for test the application and avoid that code being evaluated each time the file is saved.</p> <p>Placing your cursor at the end of the expression will allow you to evaluate it in your editor, even though it is commented out.</p> <p>If the state gets messy or something goes wrong, then you can also reset the state:</p> <p><code>(reset! app-state {:conference-name \"ClojureX\" :sessions []})</code></p>"},{"location":"om-project-clojurex/connect-form-to-local-state/","title":"Connect Form To Local State","text":"<pre><code>(defn session-add [cursor component]\n(reify\nom/IInitState\n(init-state [this]\n{:title \"title placeholder\"\n:description \"description placeholder\"\n:speaker-name \"speaker name placeholder\"\n:speaker-biography \"speaker biography placeholder\"\n:twitter-handle \"twitter placeholder\"\n:github-handle \"github placeholder\"\n:speaker-website \"website placeholder\"})\nom/IRenderState\n(render-state [_ state]\n(dom/div nil\n(dom/h3 nil \"New Session\")\n(dom/form #js {:className \"form-horizontal\"}\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:value (:title state)\n:onChange (fn [e]\n(om/set-state! component :title (-&gt; e .-target .-value)))\n:placeholder \"Session Title\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:value (:speaker-name state)\n:onChange (fn [e]\n(om/set-state! component :speaker-name (-&gt; e .-target .-value)))\n:placeholder \"Speaker Name\"})\n(dom/textarea #js {:className \"form-control\"\n:value (:description state)\n:onChange (fn [e]\n(om/set-state! component :description (-&gt; e .-target .-value)))\n:placeholder \"Session Description\"\n:rows \"5\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:value (:speaker-biography state)\n:onChange (fn [e]\n(om/set-state! component :speaker-biography (-&gt; e .-target .-value)))\n:placeholder \"Speaker Biography\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:value (:twitter-handle state)\n:onChange (fn [e]\n(om/set-state! component :twitter-handle (-&gt; e .-target .-value)))\n:placeholder \"Twitter Handle\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:value (:github-handle state)\n:onChange (fn [e]\n(om/set-state! component :github-handle (-&gt; e .-target .-value)))\n:placeholder \"Github Handle\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:value (:speaker-website state)\n:onChange (fn [e]\n(om/set-state! component :speaker-website (-&gt; e .-target .-value)))\n:placeholder \"Speaker Website\"})\n(dom/button #js {:className \"btn btn-primary\"\n:onClick\n(fn [e]\n(.preventDefault e)\n(om/transact! cursor :sessions\n(fn [session]\n((fnil conj []) session\n{:title \"title placeholder\"\n:description \"description placeholder\"\n:speaker-name \"speaker name placeholder\"\n:speaker-biography \"speaker biography placeholder\"\n:twitter-handle \"twitter placeholder\"\n:github-handle \"github placeholder\"\n:speaker-website \"website placeholder\"}))))}\n\"Submit\"))))))\n</code></pre> <p>Inside the onChange event, we call om/set-state!. This, as the name indicates, sets the state. We\u2019ll see that in a minute, in more detail. We\u2019re taking the event\u2019s target (which is the dom element it relates to, in this case the input field) and getting its value.</p>"},{"location":"om-project-clojurex/connect-form-to-local-state/#noteuse-reacts-onclick-event-to-connect-form-to-local-state","title":"Note::Use React's onClick event to connect form to local state","text":"<p>Add the <code>:onChange</code> key and function to each part of the form, connecting that event to the local state</p> <p><code>:onChange (fn [e] (om/set-state! component :local-state-key (-&gt; e .-target .-value))</code></p>"},{"location":"om-project-clojurex/connect-form-to-local-state/#hint","title":"Hint::","text":"<p>React\u2019s <code>onChange</code> event will fire as it changes, instead of after you finish changing it. Therefore onChange will fire each time you type a key or paste something.</p>"},{"location":"om-project-clojurex/create-conference-title/","title":"Create A Conference Title","text":"<p>Our project already has application state, bound to the name <code>app-state</code>.</p> <pre><code>(defonce app-state (atom {:text \"Hello Chestnut\"}))\n</code></pre> <pre><code>(defonce app-state (atom {:conference-name \"ClojureX\"}))\n</code></pre> <p>Saving the file with this change will update the text on the website.</p>"},{"location":"om-project-clojurex/create-conference-title/#noterefactor-app-state-to-hold-a-conference-name","title":"Note::Refactor app-state to hold a conference name","text":"<p>Create a key called <code>:conference</code></p> <p>Add a value as a string that holds the tile of the conference</p> <p>The <code>:title</code> key is no longer needed in our state.</p>"},{"location":"om-project-clojurex/create-form-component/","title":"Create Form Component","text":"<pre><code>(defn form [cursor component options]\n(reify\nom/IInitState\n(init-state [this]\n{:title (:title cursor)\n:description (get cursor :description \"\")\n:speaker-name (get cursor :speaker-name \"\")\n:speaker-biography (get cursor :speaker-biography \"\")\n:twitter-handle (get cursor :twitter-handle \"\")\n:github-handle (get cursor :github-handle \"\")\n:speaker-website (get cursor :speakers-website \"\")}))\n</code></pre>"},{"location":"om-project-clojurex/create-form-component/#notecreate-a-new-component-for-a-more-generic-form","title":"Note::Create a new component for a more generic form","text":"<p>Move <code>IInitState</code> and <code>init-state</code> from the <code>session-add</code> component to the <code>form component</code></p> <p>Move the <code>render-state</code> to the <code>form</code> component</p>"},{"location":"om-project-clojurex/create-form-component/#hint","title":"Hint::","text":""},{"location":"om-project-clojurex/create-local-state-for-form/","title":"Create Local State For Form","text":"<pre><code>(defn session-add [cursor component]\n(reify\nom/IInitState\n(init-state [this]\n{:title \"title placeholder\"\n:description \"description placeholder\"\n:speaker-name \"speaker name placeholder\"\n:speaker-biography \"speaker biography placeholder\"\n:twitter-handle \"twitter placeholder\"\n:github-handle \"github placeholder\"\n:speaker-website \"website placeholder\"})\nom/IRender\n(render [_]\n(dom/div nil\n(dom/h3 nil \"New Session\")\n(dom/form #js {:className \"form-horizontal\"}\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:placeholder \"Session Title\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:placeholder \"Speaker Name\"})\n(dom/textarea #js {:className \"form-control\"\n:placeholder \"Session Description\"\n:rows \"5\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:placeholder \"Speaker Biography\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:placeholder \"Twitter Handle\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:placeholder \"Github Handle\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:placeholder \"Twitter Handle\"})\n(dom/button #js {:className \"btn btn-primary\"\n:onClick\n(fn [e]\n(.preventDefault e)\n(om/transact! cursor :sessions\n(fn [session]\n((fnil conj []) session\n{:title \"title placeholder\"\n:description \"description placeholder\"\n:speaker-name \"speaker name placeholder\"\n:speaker-biography \"speaker biography placeholder\"\n:twitter-handle \"twitter placeholder\"\n:github-handle \"github placeholder\"\n:speaker-website \"website placeholder\"}))))}\n\"Submit\"))))))\n</code></pre>"},{"location":"om-project-clojurex/create-local-state-for-form/#notecreate-local-state","title":"Note::Create local state","text":"<p>Use the <code>om/IInitState</code> interface to create a map containing the local state</p>"},{"location":"om-project-clojurex/create-project/","title":"Create the project","text":"<p>Create the project using the Leiningen Chestnut template</p> <pre><code>lein new chestnut om-clojurex\n</code></pre> <p>Lets quickly explore the key parts of this project</p>"},{"location":"om-project-clojurex/create-project/#dependencies","title":"Dependencies","text":"<pre><code>  :dependencies [[org.clojure/clojure \"1.8.0\"]\n[org.clojure/clojurescript \"1.9.89\" :scope \"provided\"]\n[com.cognitect/transit-clj \"0.8.285\"]\n[ring \"1.4.0\"]\n[ring/ring-defaults \"0.2.0\"]\n[bk/ring-gzip \"0.1.1\"]\n[ring.middleware.logger \"0.5.0\"]\n[compojure \"1.5.0\"]\n[environ \"1.0.3\"]\n[org.omcljs/om \"1.0.0-alpha36\"]]\n</code></pre> <ul> <li><code>org.clojure/clojure</code> - provides the Clojure language and tooling</li> <li><code>org.clojure/clojurescript</code> - adds the Clojurescript compiler</li> <li><code>ring</code> libraries &amp; <code>compojure</code> - server-side requests &amp; routing</li> <li><code>com.cognitect/transit-clj</code> - convey values between Clojure &amp; Javascript</li> <li><code>environ</code> - manage environment settings</li> <li><code>org.omcljs/om</code> - a React API based micro-framework</li> </ul>"},{"location":"om-project-clojurex/create-project/#notereview-project-dependencies","title":"Note::Review Project Dependencies","text":"<p>Open the <code>om-clojurex/project.clj</code> file to review the dependencies already added to the project.</p>"},{"location":"om-project-clojurex/create-project/#namespace-libraries","title":"Namespace Libraries","text":"<p>The Om libraries are included in the namespace with <code>:require</code>, giving the libraries aliases.</p> <pre><code>(ns om-clojurex.core\n(:require [om.core :as om :include-macros true]\n[om.dom :as dom :include-macros true]))\n</code></pre> <ul> <li><code>om.core</code> - functions that model the React API, such a <code>render</code> and <code>root</code></li> <li><code>om.dom</code> - create html code from Clojure code</li> </ul>"},{"location":"om-project-clojurex/create-project/#notereview-the-namespace","title":"Note::Review the Namespace","text":"<p>Open the <code>om-clojure/src/om-clojurex/cljs/core.cljs</code> file to see how the namespace and required libraries are defined in the sample code.</p>"},{"location":"om-project-clojurex/create-project/#om-state-components","title":"Om State &amp; Components","text":"<ul> <li>Enable printing of messages to the browsers javascript console log</li> </ul> <pre><code>(enable-console-print!)\n</code></pre> <ul> <li>Define the application state (the model) for the application.  This is a map (hash map with key value pairs) that contains a single key called <code>:text</code> and a string as its value.</li> </ul> <pre><code>(defonce app-state (atom {:text \"Hello Chestnut!\"}))\n</code></pre> <ul> <li>Define a component that returns a div element, containing an h1 element which contains a string taken from the <code>:text</code> part of the application state.</li> </ul> <pre><code>(defn root-component [app owner]\n(reify\nom/IRender\n(render [_]\n(dom/div nil (dom/h1 nil (:text app))))))\n</code></pre> <ul> <li>Define the root of the Clojurescript project and define where it will be included in the main html page.  The root contains one component, to which is passed the app-state</li> </ul> <pre><code>(om/root\nroot-component\napp-state\n{:target (js/document.getElementById \"app\")})\n</code></pre>"},{"location":"om-project-clojurex/create-project/#notereview-the-definitions-for-the-state-and-the-component-and-root-functions","title":"Note::Review the definitions for the state and the component and root functions","text":"<p>Open the <code>om-clojure/src/om-clojurex/cljs/core.cljs</code> file to review the sample code provided with the project.</p>"},{"location":"om-project-clojurex/create-project/#hintdef-or-defonce","title":"Hint::def or defonce","text":"<p>The <code>defonce</code> function is used to prevent the app-state being reset to the default value every time a change is saved to the file.  This enables you to evolve the code and state at the same time.</p>"},{"location":"om-project-clojurex/create-project/#hintconnecting-the-app-with-the-html-page","title":"Hint::Connecting the app with the html page","text":"<p>The \"app\" refers to a div with the same id in the main html file</p>"},{"location":"om-project-clojurex/create-project/#main-html-source-code-file","title":"Main HTML source code file","text":"<ul> <li>In the body of the HTML file is a <code>div</code> tag which defines where the generated Javascript code is to be included on the page.</li> </ul> <pre><code>  &lt;body&gt;\n&lt;div id=\"app\"&gt;&lt;/div&gt;\n&lt;script src=\"js/compiled/om_clojurex.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n</code></pre>"},{"location":"om-project-clojurex/create-project/#notereview-the-html-page","title":"Note::Review the HTML page","text":"<p>Open the <code>om-clojure/resources/public/index.html</code> file to review the sample HTML code provided with the project.</p>"},{"location":"om-project-clojurex/create-sessions-component/","title":"Create Sessions Component","text":"<p>To keep components simple, we can factor out the specifics of displaying the session into its own component.</p> <p><code>om/build</code> builds a new instance of a component. It takes two arguments: the component function and the data to render with that component.</p> <p>Whenever data changes, the built component will be rerendered. So if you call om/build a second time with different data, it will render again.</p> <pre><code>(defn session-details [session owner]\n(reify\nom/IRender\n(render [_]\n(dom/div #js {:className \"panel panel-primary\"}\n(dom/h1 #js {:className \"panel-heading\"} (:title session))\n(dom/div #js {:className \"panel-body\"}\n(dom/h3 nil (str \"By \" (:speaker-name session)))\n(dom/div nil (:description session))\n(dom/hr nil)\n(dom/div nil (str \"About \" (:speaker-name session) \":\"))\n(dom/div nil (:speaker-biography session))\n(dom/div nil (:twitter-handle session))\n(dom/div nil (:github-handle session))\n(dom/div nil (:speakers-website session)))))))\n(defn root-component [app owner]\n(reify\nom/IRender\n(render [_]\n(dom/div #js {:className \"container\"}\n(dom/h1 #js {:className \"jumbotron\"} (:conference-name app))\n(for [session (:sessions app)]\n(om/build session-details session))))))\n</code></pre> <p>There should be no difference in the look and feel of your application.  Your code is a little more modular now.</p>"},{"location":"om-project-clojurex/create-sessions-component/#notecreate-a-new-component-to-display-session-details","title":"Note::Create a new component to display session details","text":"<p>Create a new component called <code>session-details</code> and move the code inside the for iteration to this new component.</p>"},{"location":"om-project-clojurex/defining-session-data/","title":"Defining Session Data","text":"<p>Now we can display multiple sessions, lets define some more sessions so we have more test data to experiment with.</p> <p>Here is the full set of sample session data, with each session </p> <pre><code>(def john {:title \"My Spacemacs Obsession\"\n:description \"Feel the power of Emacs, without the RSI\"\n:speaker-name \"John Stevenson\"\n:speaker-biography \"There's a frood who really knows where his towel is.\"\n:twitter-handle \"jr0cket\"\n:github-handle \"jr0cket\"\n:speakers-website \"http://jr0cket.co.uk\"})\n(def kris {:title \"Opening Keynote\"\n:description \"Something very inspirational\"\n:speaker-name \"Kris Jenkins\"\n:speaker-biography \"The most fantastically dressed developer in the world\"\n:twitter-handle \"krisajenkins\"\n:github-handle \"krisajenkins\"\n:speakers-website \"http://krisajenkins.co.uk\"})\n(def bug {:title \"A Glass of CIDER\"\n:description \"Unleashing the power of Clojure with Emacs\"\n:speaker-name \"Bozhidar Batsov\"\n:speaker-biography\n\"Bozhidar is the maintainer of CIDER and the editor of the community Clojure style guide. Most people would probably describe him as an Emacs zealot (and they would be right). He's also quite fond of the Lisp family of languages, functional programming in general and Clojure in particular. Believe it or not, Bozhidar has hobbies and interests outside the realm of computers, but we won't bore with those here.\"\n:twitter-handle \"bbatsov\"\n:github-handle \"bbatsov\"\n:speakers-website \"http://batsov.com/\"})\n</code></pre>"},{"location":"om-project-clojurex/defining-session-data/#hint","title":"Hint::","text":"<p><code>clojure.spec</code> can be used to define your test data and functions that work on that data to give you a testable specification for your application.</p> <p>https://clojure.org/guides/spec</p>"},{"location":"om-project-clojurex/designing-session-model/","title":"Designing Session Model","text":"<p>The conference app is going to display a list of sessions, so we need to model the data for a session.</p> <p>A conference has the following pieces of information</p> <ul> <li>Title</li> <li>Description</li> <li>Speaker name</li> <li>Speaker biography</li> <li>Twitter handle</li> <li>Github handle</li> <li>Speakers website</li> </ul> <p>A map can be used to model a single schedule as follows:</p> <pre><code>{:title \"Opening Keynote\"\n:description \"Something very inspirational\"\n:speaker-name \"John Stevenson\"\n:speaker-biography \"There's a frood who really knows where his towel is.\"\n:twitter-handle \"jr0cket\"\n:github-handle \"jr0cket\"\n:speakers-website \"http://jr0cket.co.uk\"}\n</code></pre>"},{"location":"om-project-clojurex/designing-session-model/#notemodel-a-conference-session","title":"Note::Model a conference session","text":"<p>Add the session data to the existing <code>app-state</code></p> <p>Use an associative data structure (map or vector) to model a conference session</p>"},{"location":"om-project-clojurex/display-session-in-root-component/","title":"Add Session to root-component","text":"<p>The <code>root-component</code> currently displays the title from the <code>app-state</code> via the <code>render</code> function.</p> <pre><code>(defn root-component [app owner]\n(reify\nom/IRender\n(render [_]\n(dom/div nil (dom/h1 nil (:text app))))))\n</code></pre> <p>We have a data model for our sessions and sample data, so lets add some of that session data the page.</p> <p>Add a <code>div</code> element inside the first <code>div</code>, after the <code>h1</code> element.  In the new <code>div</code> add a paragraph element that will display the string extracted via <code>:session</code> <code>:title</code> from the app-state</p> <pre><code>(defn root-component [app owner]\n(reify\nom/IRender\n(render [_]\n(dom/div nil\n(dom/h1 nil (:conference-name app))\n(dom/div nil (:title (:session app)))))))\n</code></pre> <p>Saving the file with the code above show no additional information on the web page.  So now add a session to the state using the <code>swap!</code> function</p> <p><pre><code>(swap! app-state assoc :session {:title \"Opening Keynote\"})\n</code></pre> Or using the <code>john</code> name we bound to our session previously, adding the full session information to the app-state</p> <pre><code>(swap! app-state assoc :session john)\n</code></pre>"},{"location":"om-project-clojurex/display-session-in-root-component/#noteadd-a-single-session-to-our-root-component","title":"Note::Add a single session to our root-component","text":"<p>Use the session data we previously created to test the new version of the <code>root-component</code></p>"},{"location":"om-project-clojurex/display-session-in-root-component/#hint","title":"Hint::","text":"<p>React is very happy when you wrap elements in a <code>div</code> element.  If an element is not displaying, it may need to be wrapped in a div.</p>"},{"location":"om-project-clojurex/display-session-in-root-component/#using-reify-to-check-the-react-api-is-implemented","title":"Using <code>reify</code> to check the React API is implemented","text":"<p>reify is built-in to Clojure and ClojureScript. It\u2019s easy: you give it some protocols and it makes an object that satisfies those protocols.</p> <p>Each protocol has a number of methods, maybe one, maybe more. You tell reify which protocol to implement, then follow it by the method implementations.</p> <p>Om builds components that implement its lifecycle protocols. The Om lifecycle closely follows the underlying React lifecycle methods. It\u2019s complex, but luckily you only need to know a few to get started\u2013just the most common and important ones.</p> <p>Right now, we only need <code>om/IRender</code>.  Later we\u2019ll use <code>om/IInitState</code>.</p>"},{"location":"om-project-clojurex/form-click-handler/","title":"Form Click Handler","text":"<p>Our form doesn\u2019t do anything, but because we know about cursors, we can now add a click handler to our Save button.</p> <pre><code>(defn session-add [cursor component]\n(reify\nom/IRender\n(render [_]\n(dom/div nil\n(dom/h3 nil \"New Session\")\n(dom/form #js {:className \"form-horizontal\"}\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:placeholder \"Session Title\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:placeholder \"Speaker Name\"})\n(dom/textarea #js {:className \"form-control\"\n:placeholder \"Session Description\"\n:rows \"5\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:placeholder \"Speaker Biography\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:placeholder \"Twitter Handle\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:placeholder \"Github Handle\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:placeholder \"Twitter Handle\"})\n(dom/button #js {:className \"btn btn-primary\"\n:onClick\n(fn [e]\n(.preventDefault e)\n(om/transact! cursor :sessions\n(fn [session]\n((fnil conj []) session\n{:title \"title placeholder\"\n:description \"description placeholder\"\n:speaker-name \"speaker name placeholder\"\n:speaker-biography \"speaker biography placeholder\"\n:twitter-handle \"twitter placeholder\"\n:github-handle \"github placeholder\"\n:speaker-website \"website placeholder\"}))))}\n\"Save\"))))))\n</code></pre>"},{"location":"om-project-clojurex/form-click-handler/#noteadd-an-onclick-handler-for-the-form-button","title":"Note::Add an :onClick handler for the form button","text":"<p>call <code>preventDefault</code> on the event to prevent React from updating the state after each keypress in the form.  The state should only update when we press the Submit button.</p> <p>Add some dummy data in the form, or just press Submit to see a new session appear.</p>"},{"location":"om-project-clojurex/form-click-handler/#hint","title":"Hint::","text":"<p>You can double check the form is working by evaluating the <code>@app-state</code> in the REPL or your editor</p> <p><code>fnil</code> is a function that let\u2019s you define a default behaviour when the argument is nil.  So if the session data is nil in the above example, then we conjoin the empty vector</p>"},{"location":"om-project-clojurex/include-bootstrap/","title":"Include Bootstrap","text":"<p>Lets make our website look better by adding some styling to the page.  Rather than spend days creating the perfect design, lets simply use Bootstrap.</p> <p>Bootstrap has been added to the <code>resources/public/index.html</code> page, in the header section.  To simplify things we have copied the CDN settings from Getting Started with Bootstrap.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=\"UTF-8\"&gt;\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n&lt;!-- Latest compiled and minified CSS --&gt;\n&lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\"&gt;\n&lt;!-- Optional theme --&gt;\n&lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css\" integrity=\"sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp\" crossorigin=\"anonymous\"&gt;\n&lt;!-- Latest compiled and minified JavaScript --&gt;\n&lt;script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\" integrity=\"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;\n&lt;link href=\"css/style.css\" rel=\"stylesheet\" type=\"text/css\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=\"app\"&gt;&lt;/div&gt;\n&lt;script src=\"js/compiled/uswitch_conference_deux.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"om-project-clojurex/include-bootstrap/#noteinclude-bootstrap-css-theme-and-javascript-to-the-project","title":"Note::Include Bootstrap CSS, Theme and Javascript to the project","text":"<p>Edit the <code>resources/public/index.html</code> file and link the Bootstrap stylesheets and add the minified javascript.</p>"},{"location":"om-project-clojurex/include-bootstrap/#hint","title":"Hint::","text":"<p>Adding Bootstrap from CDN is quicker than downloading it locally</p> <p>If you want to develop offline, then download the bootstrap CSS and Javascript files and place them in the <code>om-clojure/resources/public/</code> folder </p>"},{"location":"om-project-clojurex/interact-with-project/","title":"Interact with the project","text":"<p>With a running REPL you can make changes instantly.</p> <p>Place your browser where you can see both it and the editor / repl you are using to make changes.  Then you can see just how fast Clojurescript development is.</p> <p>If all is well you now have a browser window saying 'Hello Chestnut', and a REPL prompt that looks like cljs.user=&gt;.</p>"},{"location":"om-project-clojurex/interact-with-project/#make-changes-from-the-repl","title":"Make changes from the REPL","text":"<p>Quickly experiment with your app by entering Clojurescript code into the repl.</p> <pre><code>(n-ns 'om-clojurex.core)\n\n(swap! app-state assoc :text \"I feel the power of the REPL\")\n</code></pre> <p>The first line changes the namespace to <code>om-clojurex.core</code>, giving you access to the functions and definitions of our project.</p> <p>The second line updates a value in the application data model, <code>app-state</code>.  Specifically this line runs the <code>assoc</code> function to update the value pointed to by <code>text</code> in the map that is referred to by the name <code>app-state</code>.  The <code>swap</code> function is used as the map is defined as an <code>atom</code>, a mutable container, providing a managed way to update the state.</p>"},{"location":"om-project-clojurex/interact-with-project/#noteuse-the-repl-to-change-the-message-in-the-browser-window","title":"Note::Use the REPL to change the message in the browser window","text":"<p>Enter the following lines of code in the REPL:</p>"},{"location":"om-project-clojurex/interact-with-project/#hint","title":"Hint::","text":"<p>Atoms are covered in more detail in section ..., you dont need to understand them just yet.</p>"},{"location":"om-project-clojurex/interact-with-project/#make-changes-in-the-clojurescript-file","title":"Make changes in the Clojurescript file","text":"<p>Make more permanent changes by editing the file and saving the changes.</p> <ol> <li> <p>Open <code>resources/public/css/style.css</code> and change some styling of the H1 element. Notice how it's updated instantly in the browser.</p> </li> <li> <p>Open <code>src/cljs/om-clojurex/core.cljs</code>, and change <code>dom/h1</code> to <code>dom/h2</code>. As soon as you save the file, your browser is updated.</p> </li> <li> <p>Open <code>src/cljs/om-clojurex/core.cljs</code> and add the following code: <pre><code>(swap! app-state assoc :text \"Updates from the Editor\")\n</code></pre> Evaluate this line of code and again to see how the browser updates.</p> </li> </ol>"},{"location":"om-project-clojurex/interact-with-project/#notechange-files-in-the-project-watch-the-saved-changes-update-the-browser","title":"Note::Change files in the Project &amp; watch the saved changes update the browser","text":"<p>Make the following changes to the CSS styles and main Clojurescript file, to see how quickly your changes are reloaded.</p>"},{"location":"om-project-clojurex/om-cursors/","title":"Om Cursors","text":"<p>Cursors are a fundamental part of Om. They let components refer to pieces of the app state without knowing where they are in the state tree.</p> <p>A cursor is an atom and a path to a specific part of the data structure inside that atom.  For example, a cursor would be:</p> <ul> <li>[app-state :sessions] - a cursor pointing to the whole of the session data</li> <li>[app-state :sessions 0] - a cursor pointing to the first session in the collection of sessions</li> <li>[app-state :sessions 2 :title] - a cursor pointing to the third session's title</li> </ul>"},{"location":"om-project-clojurex/om-cursors/#omupdate","title":"Om/update!","text":"<p>call om/update! with the cursor and the part of the model to update then the app-state will be updated in the correct place.</p>"},{"location":"om-project-clojurex/om-cursors/#omtransact","title":"om/transact!","text":"<p>A component doesn\u2019t know exactly where in the app state data tree its data comes from. It\u2019s the cursor\u2018s job to keep track of that. The cursor also lets you modify the data in the app state atom without knowing where it is. You do that with <code>om/transact!</code>.</p> <p><code>om/transact!</code> needs the cursor as the first argument. The second argument is a key to grab a subvalue from the cursor. So if the current value of the cursor is {:name \"Samantha\" :favourite-colour \"Green\"}, you can grab just the name by calling <code>transact!</code> with the key <code>:name</code>. That means the function will just be called with the string \"Samantha\" and work on only that part of the model.</p>"},{"location":"om-project-clojurex/refactor-root-component-for-sessions/","title":"Refactor Root Component for Multiple Sessions","text":"<p>There are now multiple sessions in the data model, so lets refactor  that holds multiple sessions</p> <p>After the h1 for conference name, add a <code>div</code> element.  Inside this <code>div</code> the <code>for</code> function is used to iterate over the vector of sessions.  Each session creates a <code>h1</code> for <code>:title</code> and <code>p</code> for <code>:description</code> and <code>:twitter-handle</code></p> <pre><code>(defn root-component [app owner]\n(reify\nom/IRender\n(render [_]\n(dom/div nil\n(dom/h1 nil (:conference-name app))\n(for [session (:sessions app)]\n(dom/div nil\n(dom/h1 nil (:title session))\n(dom/h3 nil (str \"By \" (:speaker-name session)))\n(dom/p nil (:description session))\n(dom/hr nil)\n(dom/p nil (str \"About \" (:speaker-name session) \":\"))\n(dom/p nil (:speaker-biography session))\n(dom/p nil (:twitter-handle session))\n(dom/p nil (:github-handle session))\n(dom/p nil (:speakers-website session))))))))\n</code></pre>"},{"location":"om-project-clojurex/refactor-root-component-for-sessions/#noteupdate-root-component-to-display-details-from-multiple-session","title":"Note::Update <code>root-component</code> to display details from multiple session","text":"<p>Add React DOM elements using <code>dom/div</code>, <code>dom/h2</code> and <code>dom/p</code>.</p> <p>See the React DOM Elements documentation for more details.</p> <p>Assume the data you need is contained within the <code>app-state</code> which is passed as the argument <code>app</code> to the <code>root-component</code>.</p>"},{"location":"om-project-clojurex/refactor-root-component-for-sessions/#hint","title":"Hint::","text":"<p>Clojure can iterate over a collection using functions such as <code>for</code></p> <p>Remember that React likes div tags around things too (as React does not render lists like list of DOM children)</p>"},{"location":"om-project-clojurex/refactor-root-component-for-sessions/#resulting-web-page","title":"Resulting web page","text":"<p>The web page with multiple sessions should look something like this:</p> <p></p>"},{"location":"om-project-clojurex/refactor-to-multi-session-model/","title":"Refactor To Multi Session Model","text":"<p>It would be a very short conference if there were only one session, so lets use the data model that holds multiple sessions</p> <p>A parent map is added to the model with a key called <code>:sessions</code> pointing to a vector.  Each session is an element of this vector</p> <p>Modelling an empty collection of sessions</p> <pre><code>{:sessions []}\n</code></pre> <p>Modelling a collection with one session</p> <pre><code>{:sessions [{:title \"Opening Keynote\"\n:description \"Something very inspirational\"\n:speaker-name \"John Stevenson\"\n:speaker-biography \"There's a frood who really knows where his towel is.\"\n:twitter-handle \"jr0cket\"\n:github-handle \"jr0cket\"\n:speakers-website \"http://jr0cket.co.uk\"}]}\n</code></pre> <p>Refactor the example session to give it a name</p> <pre><code>(def john {:title \"Opening Keynote\"\n:description \"Something very inspirational\"\n:speaker-name \"John Stevenson\"\n:speaker-biography \"There's a frood who really knows where his towel is.\"\n:twitter-handle \"jr0cket\"\n:github-handle \"jr0cket\"\n:speakers-website \"http://jr0cket.co.uk\"})\n</code></pre> <p>Now use that name inside the collection of sessions to make the example data easier to work with</p> <pre><code>{:sessions [john]}\n</code></pre>"},{"location":"om-project-clojurex/refactor-to-multi-session-model/#notemodel-multiple-sessions","title":"Note::Model multiple sessions","text":"<p>Update the model for the conference session to hold multiple sessions</p>"},{"location":"om-project-clojurex/refactor-to-multi-session-model/#hint","title":"Hint::","text":"<p>A common way to create a collection of things in Clojure is to use a vector, <code>[]</code>.</p>"},{"location":"om-project-clojurex/start-the-repl/","title":"Start the REPL","text":"<p>A REPL will run the project code every time we save files or evaluate expressions.  This provides an instant feedback loop to ensure our application does what we think it should do.</p>"},{"location":"om-project-clojurex/start-the-repl/#noterun-the-browser-repl-using-one-of-the-following-methods","title":"Note::Run the browser-repl using one of the following methods.","text":"<p>When you see the line <code>Successfully compiled \"resources/public/app.js\"</code> browse to http://localhost:3449 to see the running app.</p> <p>It may take 10-30 seconds to start the repl, especially if libraries are to be downloaded.  If nothing is displayed in your browser window, give it a few seconds and refresh the browser.</p>"},{"location":"om-project-clojurex/start-the-repl/#using-spacemacs-or-emacs-cider","title":"Using Spacemacs or Emacs &amp; CIDER","text":"<p><code>,'</code> in Spacemacs to start a REPL (<code>cider-jack-in</code>).</p> <p><code>, s a</code> to switch to the REPL buffer and enter the following expressions, pressing <code>RET</code> to evaluate each in tern. <pre><code>(go)\n(cljs-repl)\n</code></pre></p>"},{"location":"om-project-clojurex/start-the-repl/#command-line-other-editors","title":"Command Line &amp; other editors","text":"<p>Open a terminal and type <code>lein repl</code> to start a Clojure REPL or start a REPL from your editor.</p> <p>In the REPL, enter the following function calls then open a browser at http://localhost:3449</p> <pre><code>(run)\n(browser-repl)\n</code></pre> <p>The call to <code>(run)</code> starts the Figwheel server at port 3449, which takes care of live reloading ClojureScript code and CSS. Figwheel's server will also act as your app server, so requests are correctly forwarded to the http-handler you define.</p> <p>Running <code>(browser-repl)</code> starts the Figwheel ClojureScript REPL. Evaluating expressions here will only work once you've loaded the page, so the browser can connect to Figwheel.</p> <p>When you see the line <code>Successfully compiled \"resources/public/app.js\" in 21.36 seconds.</code>, you're ready to go. Browse to <code>http://localhost:3449</code> and enjoy.</p>"},{"location":"om-project-clojurex/testing/","title":"Testing","text":""},{"location":"om-project-clojurex/testing/#testing","title":"Testing","text":"<p>Tests can be written using <code>clojure.test</code> and <code>clojurescript.test</code>, which are both built into the language.</p> <p>https://clojurescript.org/tools/testing</p> <p>fixme This section needs expanding upon</p> <p>To run the Clojure tests, use</p> <pre><code>lein test\n</code></pre> <p>To run the Clojurescript you use doo.</p> <p>Doo can run your tests against a variety of JavaScript implementations, but in the browser and \"headless\". For example, to test with PhantomJS, use</p> <pre><code>lein doo phantom\n</code></pre>"},{"location":"om-project-clojurex/use-local-state-in-session-form/","title":"Use Local State In Session Form","text":"<pre><code>(defn session-add [cursor component]\n(reify\nom/IInitState\n(init-state [this]\n{:title \"title placeholder\"\n:description \"description placeholder\"\n:speaker-name \"speaker name placeholder\"\n:speaker-biography \"speaker biography placeholder\"\n:twitter-handle \"twitter placeholder\"\n:github-handle \"github placeholder\"\n:speaker-website \"website placeholder\"})\nom/IRenderState\n(render-state [_ state]\n(dom/div nil\n(dom/h3 nil \"New Session\")\n(dom/form #js {:className \"form-horizontal\"}\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:value (:title state)\n:placeholder \"Session Title\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:value (:speaker-name state)\n:placeholder \"Speaker Name\"})\n(dom/textarea #js {:className \"form-control\"\n:value (:description state)\n:placeholder \"Session Description\"\n:rows \"5\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:value (:speaker-biography state)\n:placeholder \"Speaker Biography\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:value (:twitter-handle state)\n:placeholder \"Twitter Handle\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:value (:github-handle state)\n:placeholder \"Github Handle\"})\n(dom/input #js {:type \"text\"\n:className \"form-control\"\n:value (:speaker-website state)\n:placeholder \"Speaker Website\"})\n(dom/button #js {:className \"btn btn-primary\"\n:onClick\n(fn [e]\n(.preventDefault e)\n(om/transact! cursor :sessions\n(fn [session]\n((fnil conj []) session\n{:title \"title placeholder\"\n:description \"description placeholder\"\n:speaker-name \"speaker name placeholder\"\n:speaker-biography \"speaker biography placeholder\"\n:twitter-handle \"twitter placeholder\"\n:github-handle \"github placeholder\"\n:speaker-website \"website placeholder\"}))))}\n\"Submit\"))))))\n</code></pre>"},{"location":"om-project-clojurex/use-local-state-in-session-form/#noterefactor-session-add-component","title":"Note::Refactor session-add component","text":"<p>Change <code>om/IRender</code> to <code>om/IRenderState</code>.  Add <code>state</code> to the render functions arguments</p> <p>Add a ':value' key to each of the form elements, pulling data from the local state.</p>"},{"location":"om-project-clojurex/use-local-state-in-session-form/#hint","title":"Hint::","text":"<p>The local state is now locked into the form.  It still needs to be locked the other way around.</p>"},{"location":"overview/","title":"ClojureScript Overview","text":"<p>Hint  I love ClojureScript because its powerful, flexible and fast way of developing client-side or native mobile application</p>"},{"location":"overview/#clojurescript-is","title":"ClojureScript is","text":"<ul> <li>a general purpose language that compiles to JavaScript and runs in a Browser, on NodeJS, or Java Nashorn JavaScript engines</li> <li>a functional programming language with a data centric approach (mostly pure) </li> <li>a very small syntax (12 primitives, 4 of which were added for Java interoperability)</li> <li>a dynamic language in terms of type inference and runtime (REPL)</li> <li>a fast-feedback approach for development, helping you quickly explore a problem domain</li> <li>a modern implementation of LISP</li> <li>a highly extensible language via macros</li> <li>an efficient way to manage state changes via persistent data structures &amp; software transactional memory</li> <li>blessed with an amazing collection of libraries to solve modern programming challenges </li> </ul> <p>Hint In functional programming we avoid changing state as much as possible.  If a function does not change state it is referentially transparent, always returning the same result when given the same input (arguments).  These are refered to as Pure Functions.  Pure functions are truely modular as they do not affect any other part of the system and do not require complex threading for scalability.</p>"},{"location":"overview/#clojure-clojurescript","title":"Clojure &amp; ClojureScript","text":"<p>ClojureScript is Clojure that compiles to to JavaScript and runs in the browser (JavaScript Engine).  Most of the code and libraries available for Clojure works seamlessly when compiled to JavaScript.</p> <p>ClojureScript contains a compiler for Clojure that targets JavaScript. It is designed to emit JavaScript code which is compatible with the advanced compilation mode of the Google Closure optimizing compiler.</p> <p>ClojureScript has recently had a strong focus on Reactive client side apps and mobile apps with Reactive Native.  Due to its immutable data structures, ClojureScript has been shown to outperform Facebook React, so much so that Facebook are now adding Immutable.js to their React framework to catch up.</p> <p>There is a common file extension, <code>.cljc</code> that signifies code that is written to run on both the JVM and any JavaScript engine.</p>"},{"location":"overview/#clojure-clojurescript-community","title":"Clojure &amp; ClojureScript Community","text":"<p>There is a vibrant and highly active community around Clojure &amp; Clojurescript.  In London alone there is a regular monthly talk and 4 coding dojo every month run by the London Clojurians</p>"},{"location":"overview/#community-resources","title":"Community resources","text":"<p>Clojure. tv and Planet Clojure are the tip of the iceburg to a large amount of Clojure resources available via the Internet.</p>"},{"location":"overview/clojurescript-platforms/","title":"Theory: ClojureScript platforms","text":"<p>ClojureScript can be developed and deployed to three main platforms</p> <p></p>"},{"location":"overview/clojurescript-platforms/#browser-javascript-engine","title":"Browser JavaScript Engine","text":"<p>Modern browsers all contain a JavaScript Engine and are a platform for front-end ClojuresScript apps.  For example, single page apps like react.js.</p>"},{"location":"overview/clojurescript-platforms/#source-maps","title":"Source maps","text":"<p>Browsers also provide inspection for your Clojurescript within the Browser.  Sourcemaps provide a link from the running JavaScript to the ClojureScript that generated it.  If you receive an error or are debugging you will see the relevant ClojureScript code (rather than have to work with the generated JavaScript).</p>"},{"location":"overview/clojurescript-platforms/#google-closure-compiler-tools","title":"Google Closure compiler &amp; tools","text":"<p>As ClojureScript used the Google Closure compiler to generate JavaScript, then you can set options to generate JavaScript that will run on many browsers (even back to IE 6).</p>"},{"location":"overview/clojurescript-platforms/#nodejs","title":"NodeJS","text":"<p>NodeJS is a server-side application that can act as web application server for your ClojureScript applications</p> <p>You can also connect to a ClojureScript REPL for your application running on NodeJS</p>"},{"location":"overview/clojurescript-platforms/#compiling-clojurescript-with-nodejs","title":"Compiling ClojureScript with NodeJS","text":"<p>work in progress</p>"},{"location":"overview/clojurescript-platforms/#java-nashorn","title":"Java Nashorn","text":"<p>The Java platform also includes a JavaScript engine called Nashorn.</p> <p>Nashorn is not widely used for ClojureScript development or deployment.  However, it could be useful if you do not have access to node.js or a browser environment.</p> <p>Nashorn is developed as part of the Java Open JDK and is advertised as a much faster JavaScript engine than the previous Rhino project.</p>"},{"location":"overview/clojurescript-platforms/#vertx","title":"Vert.x","text":"<p>???</p>"},{"location":"overview/compiling-to-javascript/","title":"Compiling to JavaScript","text":"<p>Isn't writing in one language and compiling it into another language just adding lots of complexity?</p> <p>Most programming languages compile into another language and compilers have been around since the first programming languages.  Those compilers typically generate a language that is only meant for the computer to read, not the developer.</p> <p>Scripting languages can be different in that they run without compilation, simply interpreting the script code you have written.</p>"},{"location":"overview/compiling-to-javascript/#transpiling","title":"Transpiling","text":"<p>However, its a fairly recent trend (for the last two decades) to use one language to generate another, often referred to as transpiling.  </p> <p>This concept has become quite common in the Javascript world, especially when developers want to make use of newer features in Javascript but still want their code to run across all the commonly used browsers.</p> <p>Examples of Javascript transpile languages</p> <ul> <li>CoffeeScript</li> <li>ClojureScript</li> <li>JavaScript 6 and onward (ECMAScript 6 and onward)</li> <li>PureScript</li> <li>TypeScript</li> </ul> <p>Hint Rather than call this compilation, generating one language from another is called Transpiling.</p>"},{"location":"overview/data-types/","title":"Basic values","text":"<p>Although you typically do not define types in Clojure (like you would do in Object Oriented languges) there are types underneath and Clojure decides on the most appropriate types to use for any given values.</p> <p>You can coerce a value to a particular type, typically when you are passing values to the host language (i.e Java / Javascript types)</p>"},{"location":"overview/data-types/#numbers","title":"Numbers","text":"<p>Integer and decimal numbers are supported</p> <pre><code>1 2 3 4 5 6.0\n</code></pre>"},{"location":"overview/data-types/#ratios","title":"Ratios","text":"<p>From mathematics, a ratio is a relationship between two numbers indicating how many times the first number contains the second.  In Clojure it also means that when dividing two or more integer numbers the value can be kept as a ratio if otherwise a decimal (real) number would be returned.</p> <p><pre><code>(/ 22 7.0)\n(/ 5 20)\n(/ (* 22/7 3) 3)\n</code></pre> Ratios delay the need to drop into decimal numbers.  Once you create a decimal number then everything it touches had a greater potential to becoming a decimal</p>"},{"location":"overview/data-types/#strings","title":"Strings","text":"<p>Strings are defined using double quotes</p> <pre><code>\"This is a string\"\n\"Strings are immutable too\"\n</code></pre>"},{"location":"overview/data-types/#symbols-and-binding","title":"Symbols and binding","text":"<p>The names we give functions and data structures to have an easy way to refer to them </p> <pre><code>(def name \"value\")\n(def name (fn [paramter] (behaviour)))\n(let [name \"value\"])\n</code></pre>"},{"location":"overview/data-types/#keywords","title":"Keywords","text":"<p>Used for enumerations and as keys in maps (a map is a series of zero or more key value pairs)</p>"},{"location":"overview/data-types/#collections","title":"Collections","text":"<p>There are four very special collections as part of the Clojure core, all immutable and referred to as persistent data structures</p> <ul> <li> <p>List - a sequentially accessed linked list.  The first element of a list is evaluated as a function call (unless a quote character is placed in front of the list)</p> </li> <li> <p>Map - a key value pair collection, typically known as a hash maps</p> </li> <li> <p>Vector - an array like structure in that it is indexed and fast for random access</p> </li> <li> <p>Set - a unique set of elements, which can be ordered but are not by default</p> </li> </ul> <p>See the section on persistent data structures for more details.</p>"},{"location":"overview/functional-programming/","title":"Functional Programming","text":"<p>\u201cIt is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.\u201d \u2014Alan Perlis</p> <p>As functional programming becomes more popular and people search for more declarative ways of expressing programs, it is only natural to wonder how immutable values and referentially transparent functions can be used to develop interactive systems. Even a fully reified notion of time is not enough to allow for the uncertainty of the timing and value of events.</p> <p>How does one model the value of a system at a specific time? Can such a model be manipulated formally, as in an algebra, to be reasoned about mathematically? How can continuous functions of time be combined with discreet events? And how does one reason about an uncertain future?</p> <p>Functional Reactive Programming (FRP) is a specific formalism of a model of behaviors that change in response to events, created by Conal Elliot. That's a pretty abstract statement, but FRP is abstract itself. It does not denote a particular implementation, but rather a formal semantics. It is not a style of programming or a paradigm. It's simply a formalism. And it is an answer to those hard questions.</p> <p>FRP has caught my eye as an elegant means of modeling state over time in an easily composable way. I also find it to be incredibly inspiring. The notion that approaching the problem conceptually and developing a formal semantics first can lead to better optimization potential and frankly simpler implementations has gotten me to dig deeper into many of my programs and find much simpler and more elegant representations and implementations.</p> <p>Let me say that again: * Easier to reason about * Simpler to implement * Easier to optimize</p> <p>Functional Reactive Programming (and Denotational Design, also by Conal Elliott) has a lot to teach us about how to design functional programs.</p> <p>While the full variety of FRP material is much larger than I cite here, these materials will get you started.</p>"},{"location":"overview/functional-programming/#conal-elliott-on-frp-audio-interview","title":"Conal Elliott on FRP Audio Interview","text":"<p>If you're looking for an explanation of the Functional Reactive Programming from the man who invented it, along with an idea of the intriguing process he used to invent it, this HaskellCast episode is for you.</p>"},{"location":"overview/functional-programming/#functional-reactive-animation","title":"Functional Reactive Animation","text":"<p>A great paper from 1997 that spells out an early form of Functional Reactive Programming. It specifies behaviors (functions of time to a value) that change when events occur.</p>"},{"location":"overview/functional-programming/#conal-elliots-home-page","title":"Conal Elliot's home page","text":"<p>Conal Elliot created FRP while he was researching graphics and animation. Be sure to check out his FRP papers section.</p>"},{"location":"overview/functional-programming/#push-pull-functional-reactive-programming","title":"Push-pull functional reactive programming","text":"<p>A more advanced formulation of Functional Reactive Programming that formalizes the types and operations using Haskell's common type classes (Functor, ApplicativeFunctor, Monoid, etc). This one also includes a video of the paper presentation given at ICFP.</p> <p>The main breakthrough of this paper is to model the notion of a future value for events that have not yet happened. But if they have not happened, how can future values be compared? For instance, how does one ask if event a happens before event b if neither of them has happened yet? The paper develops a cool and inspiring formalism which resolves this problem. And one is left with a value that represents the entire behavior of a system past, present, and future.</p>"},{"location":"overview/functional-programming/#elm-thesis-pdf","title":"Elm Thesis - PDF","text":"<p>Elm is a different take on FRP (and it is potentially not FRP, according to some). Instead of behaviors (functions of time to a value), Elm uses discreet signals which are transformed to other signals using functional map-like operations. Elm solves computationally expensive operations blocking the propagation of signals by making some signals asynchronous.</p> <ul> <li>Elm: Concurrent FRP for Functional GUIs</li> </ul>"},{"location":"overview/react-facebook/","title":"React","text":"<p>React is a new approach in synchronising client-side state and the Document Object Model (DOM)</p> <p>In the react API, HTML &amp; DOM elements are constructed form similarly named React API functions.</p>"},{"location":"overview/react-facebook/#om","title":"Om","text":"<p>uses Facebooks React API and requires developers to learn that API when developing with Om.</p>"},{"location":"overview/react-facebook/#reagent","title":"Reagent","text":"<p>provides a programming &amp; templating interface for facebooks react library.</p> <p>Rather than the steep learning curve that the React API requires, reagent uses the more familiar HTML templates via JavaScript language extensions (JSX).  This is Facebooks recommended way of using React.</p>"},{"location":"overview/react-facebook/#om-next","title":"Om-Next","text":"<p>does this use the API or JSX ?</p>"},{"location":"overview/react-om-and-om-next/","title":"Om and Om Next","text":""},{"location":"overview/react-om-and-om-next/#om-next","title":"Om Next","text":"<p>Om Next is a uniform yet extensible approach to building networked interactive applications. By providing a structured discipline over the management of application state, Om Next narrows the scope of incidental complexity often found in user interface development. The Om Next discipline is founded upon</p> <ul> <li>immutable data structures</li> <li>declarative data specifications</li> <li>a simple convention for routing data access and mutations</li> </ul> <p>Om Next borrows ideas liberally from Facebook's Relay, Netflix's Falcor, and Cognitect's Datomic. If you are not familiar with these technologies, fear not, this tutorial makes few assumptions. You will be guided through all the core concepts of Om Next. This will prepare you for later tutorials that show custom storage integration and transparent synchronization between your UI and a remote service.</p>"},{"location":"overview/react-re-frame/","title":"Re-frame","text":"<p>re-frame is an application framework for creating more complex single page applications [SPAs] in ClojureScript, using Reagent and [hiccup] style description for generating content.</p> <p></p> <p></p>"},{"location":"overview/react-re-frame/#why-use-re-frame","title":"Why use re-frame?","text":"<ol> <li> <p>You are developing [Single Page Applications (SPA)] in ClojureScript, and you are looking for a framework and guidelines on how to organise the parts of that application effectively.</p> </li> <li> <p><code>reactive programming</code>, <code>functional programming</code> and <code>immutable data</code> is the right approach for your application.</p> </li> </ol>"},{"location":"overview/react-re-frame/#functional-model-view-controller-design","title":"Functional Model View Controller design","text":"<p>re-frame has Model, View, and Components in its design, created with pure functions (or pure data).  An application is wired together via reactive data flows.</p> <p>To build a re-frame app, you:  - design your app's data structure (data layer)  - write and register subscription functions (query layer)  - write Reagent component functions  (view layer)  - write and register event handler functions  (control layer and/or state transition layer)</p>"},{"location":"overview/react-re-frame/#tutorials","title":"Tutorials","text":"<ul> <li>TODO MVC app</li> <li>Phonecat port</li> </ul>"},{"location":"overview/react-re-frame/#features","title":"Features","text":"<ol> <li>The functions you write are pure, so the computational pieces of your app can    be described, understood and tested independently.    You won't need sophisticated Dependency Injection to test. So much    incidental complexity evaporates.</li> <li>These computational parts are composed via reactive data flows - a dynamic,    unidirectional Signal graph.</li> <li>The resulting architecture involves \"derived data\" flowing in a two-stage, reactive loop.    Without realising it, you will be explicitly modelling time.</li> <li>It is fast, straight out of the box. You won't have to go through this sort of pain.</li> <li>The surprising thing about re-frame is how simple it is. Beautifully simple! Our reference    implementation is little more than 200 lines of (ClojureScript) code. Learn it in an afternoon.</li> <li>But it scales up nicely to more complex apps.  Frameworks are just pesky overhead at small    scale - measure them instead by how they help you tame the complexity of bigger apps.</li> <li>Re-frame is impressively buzzword compliant: it has FRP-nature,    unidirectional data flow, pristinely pure functions, conveyor belts, statechart-friendliness (FSM)    and claims an immaculate hammock conception.    It also has a charming xkcd reference (soon)    and a hilarious, insiders-joke T-shirt, ideal for conferences (in design).    What could possibly go wrong?</li> </ol>"},{"location":"overview/react-reagent/","title":"Reagent","text":"<p>Reagent provides a minimalistic interface between ClojureScript and React. It allows you to define efficient React components using nothing but plain ClojureScript functions and data, that describe your UI using a Hiccup-like syntax.</p> <p>The goal of Reagent is to make it possible to define arbitrarily complex UIs using just a couple of basic concepts, and to be fast enough by default that you rarely have to care about performance.</p>"},{"location":"overview/reactive-apps/","title":"Reactive apps","text":"<p>Reactive applications are about responding rapidly to events or streams of changes.</p> <p>The most obvious examples of reactive apps include:</p> <ul> <li>Web page: clicking a button on a web page and seeing the results instantly</li> <li>Mobile App: pressing an area on your mobile app and instantly sseing the results</li> <li>Spreadsheet App: updating a cell in a spreadsheet and seeing the data change instantly</li> <li>A developers IDE: running a compiler or unit tests on your code and seeing the failing lines of code highlighted in your code editor</li> </ul>"},{"location":"overview/reactive-apps/#the-react-manifesto","title":"The React Manifesto","text":"<p>The interest in React has grown considerably and now they have created the React Manifesto.  The most important paragraph for me is:</p> <p>Systems built as Reactive Systems are more flexible, loosely-coupled and scalable. This makes them easier to develop and amenable to change. They are significantly more tolerant of failure and when failure does occur they meet it with elegance rather than disaster. Reactive Systems are highly responsive, giving users effective interactive feedback.</p> <p></p> <p>Read more and potentially sign the React Manifesto</p>"},{"location":"overview/reactive-apps/#virtual-dom","title":"Virtual Dom","text":"<p>Reading from a DOM is inefficient</p> <p>Continuous random updates to the DOM is inefficient</p>"},{"location":"overview/reactive-apps/#batch-updating-the-dom","title":"Batch updating the DOM","text":""},{"location":"overview/reactive-apps/#clojure-immuatable-data-structures","title":"Clojure Immuatable Data structures","text":"<p>Immutable data structures are really fast when it comes to comparison</p>"},{"location":"overview/reactive-apps/#replay-from-root","title":"Replay from root","text":"<p>Playback all the changes that have been made to your app</p> <p>? Does this work in the same way as CQRS - does it make sense to make a comparison ?</p>"},{"location":"overview/single-page-apps/","title":"Single Page Apps","text":"<p>Clojurescript provides the most benefit when building single page apps.</p> <p></p>"},{"location":"overview/single-page-apps/#what-is-a-single-page-app-spa","title":"What is a Single Page App (SPA)","text":"<p>A single-page application (SPA) is a web application or web site that fits on a single web page with the goal of providing a more fluent user experience similar to a desktop application.</p> <p>In a SPA, either all necessary code \u2013 HTML, JavaScript, and CSS \u2013 is retrieved with a single page load, or the appropriate resources are dynamically loaded and added to the page as necessary, usually in response to user actions. The page does not reload at any point in the process, nor does control transfer to another page, although the location hash can be used to provide the perception and navigability of separate logical pages in the application, as can the HTML5 <code>pushState() API</code> .</p> <p>Interaction with the single page application often involves dynamic communication with the web server behind the scenes.</p> <p>See the Single-page application on Wikipedia for more details</p>"},{"location":"production/","title":"Production Clojurescript","text":"<p>Good practices when putting Clojurescript into production </p> <ul> <li>Advanced Compilation</li> <li>Externs</li> <li>Deployment</li> <li>Debugging in production</li> </ul>"},{"location":"production/externs/","title":"Externs","text":"<p>The ClojureScript compiler optimizes names by replacing them with shorter names.  This makes for much smaller Javascript files, minimising the time it takes to load them. </p> <p>This type of optimisation works very well for your own Clojurescript, however it can cause problems when optimising Javascript libraries.</p> <p>By specifying Externs for your project you tell the Clojurescript compiler which parts of your project are unsafe to optimize.</p> <ul> <li>Clojurescript Externs - LispCast</li> </ul>"},{"location":"quickstart/","title":"ClojureScript Quickstart","text":"<p>In this section we will create a simple project that uses the ClojureScript compiler to generate JavaScript code from our ClojureScript code.</p> <ul> <li>Create basic project</li> <li>Hello World</li> <li>Create build file</li> <li>Build Project</li> <li>Create a web page</li> <li>Google Closure</li> <li>Reduce boilerplate</li> <li>Auto-building</li> <li>Browser REPL</li> <li>Production Build</li> <li>Dependencies</li> <li>node.js</li> <li>Java Nashorn</li> </ul> <p>The standalone ClojureScript JAR bundles Clojure 1.7.0. .  ClojureScript itself only requires Java 7 but the standalone JAR comes bundled with useful Nashorn integration that requires Java 8.</p> <p>Hint Once you start creating ClojureScript projects you will use a build tool like Leiningen, Boot, Figwheel, or Maven.</p>"},{"location":"quickstart/auto-building/","title":"Auto-building","text":"<p>The ClojureScript compiler supports incremental compilation. It's convenient to have the ClojureScript compiler watch a directory and recompile as needed. Let's make a new helper script <code>watch.clj</code>:</p> <pre><code>(require 'cljs.build.api)\n(cljs.build.api/watch \"src\"\n{:main 'hello-world.core\n:output-to \"out/main.js\"})\n</code></pre> <p>Let's start auto building:</p> <pre><code>java -cp cljs.jar:src clojure.main watch.clj\n</code></pre> <p>You should see output like the following:</p> <pre><code>Building ...\nReading analysis cache for jar:file:/.../cljs.jar!/cljs/core.cljs\nAnalyzing src/hello_world/core.cljs\n... done. Elapsed 1.425505401 seconds\n</code></pre> <p>Edit <code>src/hello_world/core.cljs</code>. You should see recompilation output.</p> <p>Terminate auto building (using <code>Ctrl-C</code>) before proceeding to the next section.</p> <p>Further Reading: While not required for the remainder of the Quick Start, it's highly recommended that you familiarize yourself with basics of Google Closure Library. Many simple errors can be avoided by reinforcing your understanding of how Closure Library works.</p>"},{"location":"quickstart/browser-repl/","title":"Browser REPL","text":"<p>It's hard to imagine a productive Lisp experience without a REPL (Read-Eval-Print-Loop). ClojureScript ships with builtin REPL support for Node.js, Rhino, Nashorn, and browsers.</p> <p>Let's hook up a browser REPL to our project.</p> <p>First it is recommended that you install rlwrap. Under OS X the easiest way is to use brew and <code>brew install rlwrap</code>.</p> <p>Let's create a REPL script <code>repl.clj</code>:</p> <pre><code>(require 'cljs.repl)\n(require 'cljs.build.api)\n(require 'cljs.repl.browser)\n(cljs.build.api/build \"src\"\n{:main 'hello-world.core\n:output-to \"out/main.js\"\n:verbose true})\n(cljs.repl/repl (cljs.repl.browser/repl-env)\n:watch \"src\"\n:output-dir \"out\")\n</code></pre> <p>We build the project at least once before constructing the REPL.</p> <p>REPLs are always constructed in the same way. The first argument to <code>cljs.repl/repl</code> is the REPL evaluation environment (Node.js, Rhino, Nashorn, browser), the subsequent arguments are the same arguments you pass to <code>cljs.build.api/build</code> in addition to several options that are specific to REPLs. Note that we supply a <code>:watch</code> option with a source directory. This conveniently starts a REPL along with an auto building process. The auto building process will write its activity to <code>out/watch.log</code> so you can easily <code>tail -f out/watch.log</code>. We also specify <code>:output-dir</code> so that the REPL can reuse compiled files generated by the build.</p> <p>We also need to modify our source to load the browser REPL:</p> <pre><code>(ns hello-world.core\n(:require [clojure.browser.repl :as repl]))\n(defonce conn\n(repl/connect \"http://localhost:9000/repl\")) (enable-console-print!)\n(println \"Hello world!\")\n</code></pre> <p>We create the connection with <code>defonce</code>. This ensures the connection is constructed only one time - we may reload this namespace during development and we don't want multiple connection instances.</p> <p>Let's try it:</p> <pre><code>rlwrap java -cp cljs.jar:src clojure.main repl.clj\n</code></pre> <p>The first time will be somewhat slow as the REPL communication script needs to build. You will also see innocuous <code>WARNING</code>s from the Google Closure Compiler that can be ignored. You should eventually see the following message:</p> <pre><code>Waiting for browser to connect ...\n</code></pre> <p>Point your web browser at http://localhost:9000.</p> <p>You should get a REPL. (Note that the REPL will appear in your terminal, not in the browser.) </p> <p>Try evaluating a simple expression like <code>(+ 1 2)</code>.</p> <p>Debug Note: If the REPL doesn't connect immediately try refreshing the browser a few times (Chrome &amp; Firefox tend to be more stable than Safari). Note that eval will be slow in some browsers if you don't have the browser REPL tab focused. If for some reason the REPL completely hangs, just refresh the page.</p> <p>Run <code>tail -f out/watch.log</code> in a fresh terminal to view auto build progress.</p> <p>Try evaluating some expressions like <code>(first [1 2 3])</code>, or <code>(doc first)</code>, <code>(source first)</code>.</p> <p>Change your <code>src/hello_world/core.cljs</code> source file to look like the following:</p> <pre><code>(ns hello-world.core\n(:require [clojure.browser.repl :as repl]))\n(defonce conn\n(repl/connect \"http://localhost:9000/repl\"))\n(enable-console-print!)\n(println \"Hello world!\")\n;; ADDED\n(defn foo [a b]\n(+ a b))\n</code></pre> <p>At the REPL prompt, require your namespace by evaluating <code>(require '[hello-world.core :as hello])</code>. Try evaluating <code>(hello/foo 2 3)</code>, you should get the result <code>5</code>.</p> <p>Change your source file so that <code>foo</code> uses <code>*</code> instead of <code>+</code>:</p> <pre><code>(ns hello-world.core\n(:require [clojure.browser.repl :as repl]))\n(defonce conn\n(repl/connect \"http://localhost:9000/repl\"))\n(enable-console-print!)\n(println \"Hello world!\")\n(defn foo [a b]\n(* a b)) ;; CHANGED\n</code></pre> <p>We can get this new definition in our REPL by appending a <code>:reload</code> keyword  to our require statement thereby forcing a reload.  Evaluate <code>(require '[hello-world.core :as hello] :reload)</code> and try <code>(hello/foo 2 3)</code> you should get <code>6</code> this time.</p> <p>Lets make a mistake. Try evaluating <code>(ffirst [1])</code>. You should get a source mapped stack trace pointing at ClojureScript source locations not JavaScript ones. This makes debugging a lot nicer.</p>"},{"location":"quickstart/build-project/","title":"Build Project","text":"<p>Now we have a build file, build the project as follows:</p> <pre><code>java -cp cljs.jar:src clojure.main build.clj\n</code></pre> <p>On Windows: <pre><code>java -cp \"cljs.jar;src\" clojure.main build.clj\n</code></pre></p> <p>We invoke <code>java</code> and set the classpath to our JAR and the directory where our ClojureScript code lives. The <code>clojure.main</code> argument in this case allows us to easily execute a Clojure file.</p> <p>Debug Note: If you encounter an error about <code>cljs.build.api</code> not being found, make sure that you didn't write <code>(require 'cljs.build.api')</code>, many popular text editors will emit a matching single quote even in their Clojure mode.</p> <p>Control should return to the shell relatively quickly and you will have an <code>out</code> directory with compiled JavaScript including your simple program. You will see that many files were produced in addition to the <code>out/main.js</code> we specified. We'll explain this momentarily but first let's see how you can easily include the compiled output on a web page.</p>"},{"location":"quickstart/create-a-web-page/","title":"Create a web page","text":"<p>Create a file <code>index.html</code> and include the following:</p> <pre><code>&lt;html&gt;\n&lt;body&gt;\n&lt;script type=\"text/javascript\" src=\"out/main.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Open this file in a browser and open the JavaScript developer console so you can see the output. Nothing will appear in the main browser window as no content is rendered.</p> <p>You will not see <code>\"Hello world!\"</code> but instead you will likely see an error like the following:</p> <pre><code>Uncaught ReferenceError: goog is not defined\n</code></pre> <p>In order to understand this error we must examine a few basics around the Google Closure Library. While the following section may seem somewhat roundabout, a short review on how Google Closure Library works will make simple bugs considerably easier to spot.</p>"},{"location":"quickstart/create-basic-project/","title":"Create basic project","text":"<p>TODO Lets take a look at the fundamentals of running ClojureScript using the standalone ClojureScript compiler.</p> <p>Create a directory structure as follows:</p> <pre><code>cljs_compiler\n |_ src\n    |_ hello_world\n</code></pre> <p>Download the standalone ClojureScript JAR and copy the JAR into the <code>cljs_compiler</code> directory </p>"},{"location":"quickstart/create-build-file/","title":"Create build file","text":"<p>As ClojureScript is a Clojure library, a simple build tool can be easily scripted in a few lines of Clojure. </p> <p>Create a file called <code>build.clj</code> in the <code>cljs_compiler</code> directory and add the following Clojure code:</p> <pre><code>(require 'cljs.build.api)\n(cljs.build.api/build \"src\" {:output-to \"out/main.js\"})\n</code></pre> <p>Hint In order to compile the ClojureScript code, we use the <code>build</code> function from the library <code>cljs.build.api</code>.  To access the functions of this library we use the <code>require</code> function.  This is similar to import or include in other languages.</p> <p>The <code>cljs.build.api/build</code> function takes two arguments: the directory to compile and a map of options. In our code we include the option <code>:output-to</code> that specifies where to write the JavaScript.</p>"},{"location":"quickstart/dependencies/","title":"Dependencies","text":"<p>ClojureScript supports a wide variety of options for including ClojureScript and JavaScript dependencies (see [[Dependencies]] for details). However the simplest approach is to include a properly packaged JAR on the classpath. CLJSJS provides a nice set of curated JavaScript libraries that suffices to demonstrate how dependencies are handled.</p> <p>React is a popular dependency for ClojureScript projects. CLJSJS provides a bundled version. Let's see how to include it.</p> <p>Grab the JAR from Clojars:</p> <pre><code>curl -O https://clojars.org/repo/cljsjs/react/0.12.2-8/react-0.12.2-8.jar\n</code></pre> <p>Let's edit our simple program to look like the following so that React is properly required:</p> <pre><code>(ns hello-world.core\n(:require cljsjs.react))\n(enable-console-print!)\n(println \"Hello React!\")\n</code></pre> <p>Let's rebuild our project, all we need to do is extend our classpath to include the CLJSJS React JAR.</p> <pre><code>java -cp cljs.jar:src:react-0.12.2-8.jar clojure.main build.clj\n</code></pre> <p>If you refresh your <code>index.html</code> page you should see the usual React log indicating that React was successfully loaded.</p> <p>If you have a few dependencies, one convention is to put them into a folder called <code>lib</code>. Then you can launch your scripts like so:</p> <pre><code>java -cp 'cljs.jar:lib/*:src' clojure.main build.clj\n</code></pre> <p>As your dependency graph becomes more sophisticated it may make sense to rely on Maven or Leiningen to manage dependencies for you. Please refer to [[Dependencies]] for a comprehensive tutorial. What follows is just the basics.</p>"},{"location":"quickstart/dependencies/#leiningen","title":"Leiningen","text":"<p>All the commands above may be executed with the <code>run</code> feature of Leiningen. With Leiningen you do not need to specify the classpath.  For example for a REPL you would do something like the following from your project directory:</p> <pre><code>lein run -m clojure.main repl.clj\n</code></pre> <p>One important thing to remember with Leiningen is the <code>:source-paths</code> configuration parameter. The <code>:source-paths</code>, found in the project.clj, are appended to the classpath. For a ClojureScript build you should include all the source paths to your ClojureScript sources in the <code>:source-paths</code> parameter. The path \"src\" is included by default.</p> <p>This is especially important if you use another path besides \"src\".</p> <p>If you have any questions about the classpath you can see it easily by typing  <code>lein classpath</code>.</p>"},{"location":"quickstart/google-clojure/","title":"Google Closure","text":"<p>In order to abstract away JavaScript environment differences ClojureScript relies on the Google Closure Library (GCL). GCL supplies an important facility missing from JavaScript: namespaces and a way to declare dependencies between them. In fact ClojureScript namespaces get compiled to Google Closure namespaces.</p> <p>Loading dependencies correctly across various browser targets is a surprisingly tricky affair. GCL accomplishes this by maintaining a dependency graph. When you require a namespace it will write the needed script tags in dependency order for you.</p> <p>So what went wrong? If you look at <code>out/main.js</code> you will see some dependency graph building calls:</p> <pre><code>goog.addDependency(\"base.js\", ['goog'], []);\ngoog.addDependency(\"../cljs/core.js\", ['cljs.core'], ...);\ngoog.addDependency(\"../hello_world/core.js\", ['hello_world.core'], ...);\n</code></pre> <p>But wait, where is this <code>goog</code> object coming from?</p> <p>Oops. We never loaded it! In order for GCL to bootstrap we must at least load <code>goog/base.js</code>. You'll see this is available in <code>out/goog/base.js</code>. Let's add this to your page now:</p> <pre><code>&lt;html&gt;\n&lt;body&gt;\n&lt;script type=\"text/javascript\" src=\"out/goog/base.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"out/main.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Refresh the page.</p> <p>The error will be gone but you still won't see the desired <code>\"Hello world!\"</code>.</p> <p>Hrm. <code>out/main.js</code> didn't appear to have any of the logic that we wrote, in fact it only includes the needed dependency graph information for the ClojureScript standard library <code>cljs.core</code> and our namespace.</p> <p>Ah. The last step we missed was actually requiring our namespace to kick things off. Change <code>index.html</code> to the following.</p> <pre><code>&lt;html&gt;\n&lt;body&gt;\n&lt;script type=\"text/javascript\" src=\"out/goog/base.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"out/main.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\"&gt;\ngoog.require(\"hello_world.core\");\n// Note the underscore \"_\"! \n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Refresh your <code>index.html</code> and you should finally see <code>\"Hello world!\"</code> printing to the browser JavaScript console. If you're using a sufficiently modern browser you should even see the printing was invoked from a ClojureScript source file and not a JavaScript one thanks to source mapping (some browsers like Chrome require you to first enable source mapping, for more details look here).</p>"},{"location":"quickstart/hello-world/","title":"Hello World","text":"<p>Create a new file called <code>src/hello_world/core.cljs</code> and add the following code:</p> <pre><code>(ns hello-world.core)\n(enable-console-print!)\n(println \"Hello world!\")\n</code></pre> <ul> <li> <p>The first line declares the namespace, defining a named scope for our code.. Every ClojureScript file must declare a namespace and this namespace must match a path on disk. </p> </li> <li> <p>The second line enables direct printing to the JavaScript <code>console</code> object in your browser </p> </li> <li> <p>The third line is what should be a familiar print message.</p> </li> </ul>"},{"location":"quickstart/lumo/","title":"Lumo","text":"<p>Lumo is a fast, stand-alone Clojurescript REPL that runs on node.js and V8 Javascript platforms.</p> <p>Thanks to V8\u2019s custom startup snapshots, Lumo starts up instantaneously, making it the fastest Clojure REPL in existence.  However, as Lumo runs bootstrapped ClojureScript then compiling ClojureScript in JavaScript is generally slower than on the JVM.</p> <p>Here is a comparison of Clojure, Planck and Lumo\u2019s startup times.</p> <p></p> <p>Lumo employs some tricks to be extremely fast, including caching, lazy analysis cache loading and AOT-compiled macros.</p> <p>Lumo is free for use and its code is under an Open Source Software license (Eclipse public license).</p>"},{"location":"quickstart/lumo/#why-nodejs","title":"Why Node.js","text":"<p>Using Node.js as a platform means Lumo can run on all common operating systems (Ubuntu, MacOSX) and Microsoft Windows.</p> <p>Node.js has the largest and fastest growing package ecosystem today via npmjs.com.  Seamless interoperability with NPM plays a huge part in extending ClojureScript\u2019s reach even further.</p> <p>The fastest Clojure REPL in the world 09 Nov 2016</p>"},{"location":"quickstart/lumo/#why-lumo","title":"Why Lumo?","text":"<p>The startup time of the JVM has been a factor in adoption of Clojure, as starting a Clojure REPL feels slow compared to other tools like node.js.  </p> <p>Planck \u2014 through bootstrapped ClojureScript, and owing to the small latency exhibited by JavaScript VMs \u2014 managed to improve the time that it takes to bootstrap a Clojure(Script) REPL. Now Lumo aims to make tooling perform even faster.</p>"},{"location":"quickstart/lumo/#future-features","title":"Future Features","text":"<p>Lumo is not complete by any means. The initial release has a substantial set of features <code>lumo -h</code> or <code>lumo --help</code></p> <p>Features planned for Lumo include cursor hopping, pretty printing and colored output, as well as idiomatic ClojureScript wrappers for Node\u2019s APIs, such as performing I/O calls, spawning child processes and more.</p>"},{"location":"quickstart/lumo/#references","title":"References","text":"<ul> <li>Lumo - the fastest clojure repl in the world</li> </ul>"},{"location":"quickstart/nodejs/","title":"Running ClojureScript on Node.js","text":"<p>First install Node.js. For instructions on installing Node.js, see the Node.js wiki. Only the current stable versions of Node.js (&gt;= <code>0.12.X</code>) are supported at this time. Your <code>src/hello_world/core.cljs</code> should look like the following:</p> <pre><code>(ns hello-world.core\n(:require [cljs.nodejs :as nodejs]))\n(nodejs/enable-util-print!)\n(defn -main [&amp; args]\n(println \"Hello world!\"))\n(set! *main-cli-fn* -main)\n</code></pre> <p>Make a build helper file called <code>node.clj</code>:</p> <pre><code>(require 'cljs.build.api)\n(cljs.build.api/build \"src\"\n{:main 'hello-world.core\n:output-to \"main.js\"\n:target :nodejs})\n</code></pre> <p>The only differences are that we had to specify a <code>:nodejs</code> target and we do not output <code>main.js</code> to the <code>out</code> directory. This is important due to the way that Node.js resolves JavaScript source files.</p> <p>Node.js has great source mapping support, in order to enable it just install <code>source-map-support</code>:</p> <pre><code>npm install source-map-support\n</code></pre> <p>Let's build your Node project:</p> <pre><code>java -cp cljs.jar:src clojure.main node.clj\n</code></pre> <p>You can run your file with:</p> <pre><code>node main.js\n</code></pre> <p>Note: Under Node.js there is little reason to use advanced optimizations. While advanced optimizations does apply performance related optimizations, these are now largely obviated by optimizations present in modern JavaScript virtual machines like V8, SpiderMonkey, and JavaScriptCore. For Node.js, <code>:simple</code> or <code>:none</code> optimizations suffice and using them removes the need for extra steps like supplying an externs file.</p>"},{"location":"quickstart/nodejs/#nodejs-repl","title":"Node.js REPL","text":"<p>Running a Node.js REPL is much simpler than running a browser REPL. Create a helper build file called <code>node_repl.clj</code> that looks like the following:</p> <pre><code>(require 'cljs.repl)\n(require 'cljs.build.api)\n(require 'cljs.repl.node)\n(cljs.build.api/build \"src\"\n{:main 'hello-world.core\n:output-to \"out/main.js\"\n:verbose true})\n(cljs.repl/repl (cljs.repl.node/repl-env)\n:watch \"src\"\n:output-dir \"out\")\n</code></pre> <p>There's no need to add any REPL specific bits to <code>src/hello_world/core.cljs</code>, make sure it looks as described in the previous section.</p> <p>Let's start the REPL:</p> <pre><code>rlwrap java -cp cljs.jar:src clojure.main node_repl.clj\n</code></pre> <p>All the previously described REPL interactions for the browser should work.</p>"},{"location":"quickstart/production-build/","title":"Production Build","text":"<p>You may have noticed that <code>out</code> contains a lot of JavaScript. Fortunately the ClojureScript compiler generates output optimized for the Google Closure Compiler. The Google Closure Compiler performs many optimizations, but the most significant for browser-based clients are minification and dead code elimination.</p> <p>Let's make a new helper build script <code>release.clj</code>, it should look like the following:</p> <pre><code>(require 'cljs.build.api)\n(cljs.build.api/build \"src\"\n{:output-to \"out/main.js\"\n:optimizations :advanced})\n(System/exit 0)\n</code></pre> <p>Under <code>:advanced</code> optimizations <code>:main</code> is not needed as advanced compilation creates a single JavaScript artifact. We also add a <code>(System/exit 0)</code> as the Google Closure Compiler creates a thread pool that isn't shutdown - we know we're done we can just exit.</p> <p>Let's remove the dev time REPL bits from <code>src/hello_world/core.cljs</code>:</p> <pre><code>(ns hello-world.core)\n(enable-console-print!)\n(println \"Hello world!\")\n</code></pre> <p>Let's create a release build:</p> <pre><code>java -cp cljs.jar:src clojure.main release.clj\n</code></pre> <p>This process will take significantly longer which is why we don't use this compilation mode for development.</p> <p>Open <code>index.html</code>, you should still see <code>\"Hello world!\"</code> printed.</p> <p>Examine <code>out/main.js</code>, the file size should be around 80K. If you zip this file you'll see that it's around 19K. This is significantly smaller than a jQuery dependency yet when using ClojureScript you have implicit dependencies on the entire ClojureScript standard library (10KLOC) and the Google Closure Library (300KLOC). You can thank dead code elimination.</p>"},{"location":"quickstart/reduce-boilerplate/","title":"Reduce boilerplate","text":"<p>The previous section explained some important fundamental concepts around the Google Closure Library. However it also involved a substantial amount of boilerplate. We can eliminate this boilerplate by specifying a <code>:main</code> entry point in the options that we pass to <code>cljs.build.api/build</code>. Let's do that now:</p> <pre><code>(require 'cljs.build.api)\n(cljs.build.api/build \"src\"\n{:main 'hello-world.core\n:output-to \"out/main.js\"})\n</code></pre> <p>Change your HTML to the following:</p> <pre><code>&lt;html&gt;\n&lt;body&gt;\n&lt;script type=\"text/javascript\" src=\"out/main.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Rebuild on Mac or GNU/Linux:</p> <pre><code>java -cp cljs.jar:src clojure.main build.clj\n</code></pre> <p>On Windows: <pre><code>java -cp \"cljs.jar;src\" clojure.main build.clj\n</code></pre></p> <p>Refresh the page and you should still see <code>\"Hello world!\"</code> printed to the JavaScript console. If you examine <code>out/main.js</code> you'll see that it writes out the boilerplate script tags for you. The previous contents of <code>main.js</code> are now in <code>out/cljs_deps.js</code>, which is loaded alongside our namespace by the new <code>out/main.js</code>.</p>"},{"location":"quickstart/self-hosted-clojurescript/","title":"Self Hosted Clojurescript","text":"<p>Ever since ClojureScript was able to compile itself there has been the idea of building and running Clojurescript projects without dependency on Java. </p> <p>Planck and Lumo can run ClojureScript via the REPL or run ClojureScript scripts and now Lumo version 1.2.0 supports compiling an entire ClojureScript project, just like the regular JVM-based ClojureScript compiler. </p> <p>This has been achieved by porting the JVM-based code in the ClojureScript compiler to work under Lumo and use the Node.js platform. </p> <p>Self hosted Clojurescript is still a hosted language, just its hosted on a Javascript platform, in this case node.js</p> <p>Install Lumo 1.2.0 on Homebrew master with <code>brew install --HEAD lumo</code></p>"},{"location":"quickstart/self-hosted-clojurescript/#optimised-builds-with-google-clojure-compiler","title":"Optimised builds with Google Clojure compiler","text":"<p>Using <code>google-closure-compiler-js</code> the generated JavaScript can be minified and highly optimised via dead-code elimination, ensuring only the code you actually use is included in the final javascript file.</p> <p>This port has been generally straightforward, changing the synchronous JVM build API to the self-hosted ClojureScript asynchronous API has represented the most amount of work so far.</p>"},{"location":"quickstart/self-hosted-clojurescript/#no-external-dependencies","title":"No external dependencies","text":"<p>Compiling ClojureScript projects with Lumo requires no external dependencies (such as the Google Closure Library) apart from those required by the projects themselves.  All the necessary compiler dependencies are bundled within the single Lumo executable.</p>"},{"location":"quickstart/self-hosted-clojurescript/#example-build-script","title":"Example Build Script","text":"<p>Taking the example from the ClojureScript Quick Start guide, simply change the <code>cljs.build.api</code> to <code>lumo.build.api</code>.  This example script will also use advanced optimisations so we can see the JavaScript version of the Google Closure Compiler in action.</p> <pre><code>(require '[lumo.build.api :as b])\n(b/build \"src\"\n{:main 'hello-world.core\n:output-to \"main.js\"\n:optimizations :advanced\n:target :nodejs})\n</code></pre>"},{"location":"quickstart/self-hosted-clojurescript/#running-the-build","title":"Running The Build","text":"<p>Run the build script with Lumo, adding the <code>src</code> folder to the classpath with <code>--classpath</code> command line option so Lumo can find the project.</p> <pre><code>$ lumo --classpath src build.cljs\n</code></pre> <p>Hint run <code>lumo -h</code> to see all the lumo options</p>"},{"location":"quickstart/self-hosted-clojurescript/#run-your-clojurescript-project","title":"Run your Clojurescript project","text":"<p>Run the compiled project with node.js using the command</p> <pre><code>node main.js\n</code></pre>"},{"location":"quickstart/self-hosted-clojurescript/#caveats","title":"Caveats","text":"<p>Lumo currently ships with its own version of the ClojureScript compiler, so for now its not possible to compile ClojureScript projects against any other versions. This does avoid having any external dependencies when compiling ClojureScript projects with Lumo though.</p> <p>The Google Closure Compiler JS is a JavaScript port of the Java version, generated using GWT. It take longer to optimize code when compared to the Java version. It also ships with fewer features than its Java counterpart as not every feature included in the Java version is portable to JavaScript.</p> <p>There is a large amount of work remaining to achieve feature parity with the current ClojureScript compiler on the JVM.  This feature of Lumo should therefor be considered pre-alpha</p> <p>Please report issues, and if you want to help, do get in touch (e.g. on Twitter)!</p>"},{"location":"re-frame/","title":"Re-frame","text":""},{"location":"re-frame/todo-mvc/","title":"Re-frame ToDo MVC","text":""},{"location":"reactjs/","title":"react.js","text":"<p>This section is still work in progress, however you can get the working project from: https://github.com/jr0cket/calculator-reactjs</p> <p>Run the project with <code>lein figwheel</code> or run it from your favourite editor</p>"},{"location":"reactjs/project-calculator-create-project/","title":"Create Project","text":""},{"location":"reactjs/project-calculator-introduction/","title":"Project: Calculator","text":""},{"location":"reagent/","title":"Reagent","text":"<p>Reagent provides a ClojureScript interface to React.js, simplifying the development of single page apps and web user interfactes.  Reagent apps are very fast as immutable data structures makes calculating virtual dom changes extremely efficient.</p> <p>React components are ClojureScript functions, state is held in ClojureScript data structures and the user interface can be generated using a Hiccup-like syntax.</p>"},{"location":"reagent/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":""},{"location":"reagent/#designing-a-reagent-app","title":"Designing a Reagent app","text":"<p>A simple reagent app consists of 3 main sections</p> <ul> <li>state - shared between one or more components</li> <li>components - behavior of the application, such as rendering content</li> <li>rendering - render components and update them when state changes</li> </ul>"},{"location":"reagent/#state","title":"State","text":"<p>The application state is modeled using Clojure data structures, e.g. hash-maps, vectors, contained within a reagent atom.</p> <p>A reagent atom is a mutable container into which new values can be swapped or reset in a controlled way (Software Transactional Memory)</p>"},{"location":"reagent/#components-are-clojure-functions","title":"Components are Clojure functions","text":"<pre><code>(defn hello []\n[:div \"I am a reagent component, defining HTML content using the hiccup style syntax\"])\n</code></pre>"},{"location":"reagent/#rendering","title":"Rendering","text":"<ul> <li>Reagent Rocks tutorial</li> </ul>"},{"location":"reagent/interact-with-the-repl/","title":"Interacting with the REPL","text":"<p>With a running REPL you can make changes instantly.</p> <p>Place your browser where you can see both it and the editor / repl you are using to make changes.  Then you can see just how fast Clojurescript development is.</p> <p>If all is well you now have a browser window saying 'Hello Chestnut', and a REPL prompt that looks like cljs.user=&gt;.</p>"},{"location":"reagent/interact-with-the-repl/#make-changes-from-the-repl","title":"Make changes from the REPL","text":"<p>Quickly experiment with your app by entering Clojurescript code into the repl.</p> <pre><code>(in-ns conference-reagent.core)\n(swap! app-state assoc :text \"I feel the power of the REPL\")\n</code></pre> <p>The first line changes the namespace to <code>conference-reagent.core</code>, giving you access to the functions and definitions of our project.</p> <p>The second line updates a value in the application data model, <code>app-state</code>.  Specifically this line runs the <code>assoc</code> function to update the value pointed to by <code>text</code> in the map that is referred to by the name <code>app-state</code>.  The <code>swap</code> function is used as the map is defined as an <code>atom</code>, a mutable container, providing a managed way to update the state.</p>"},{"location":"reagent/interact-with-the-repl/#noteuse-the-repl-to-change-the-message-in-the-browser-window","title":"Note::Use the REPL to change the message in the browser window","text":"<p>Enter the following lines of code in the REPL:</p>"},{"location":"reagent/interact-with-the-repl/#hint","title":"Hint::","text":"<p>Atoms are covered in more detail in section ..., you dont need to understand them just yet.</p>"},{"location":"reagent/interact-with-the-repl/#make-changes-in-the-clojurescript-file","title":"Make changes in the Clojurescript file","text":"<p>Make more permanent changes by editing the file and saving the changes.</p> <ol> <li> <p>Open <code>resources/public/css/style.css</code> and change some styling of the H1 element. Notice how it's updated instantly in the browser.</p> </li> <li> <p>Open <code>src/cljs/conference-reagent/core.cljs</code>, and change <code>dom/h1</code> to <code>dom/h2</code>. As soon as you save the file, your browser is updated.</p> </li> <li> <p>Open <code>src/cljs/conference-reagent/core.cljs</code> and add the following code: <pre><code>(swap! app-state assoc :text \"Updates from the Editor\")\n</code></pre> Evaluate this line of code and again to see how the browser updates.</p> </li> </ol>"},{"location":"reagent/interact-with-the-repl/#notechange-files-in-the-project-watch-the-saved-changes-update-the-browser","title":"Note::Change files in the Project &amp; watch the saved changes update the browser","text":"<p>Make the following changes to the CSS styles and main Clojurescript file, to see how quickly your changes are reloaded.</p>"},{"location":"reagent/wip/","title":"Work In Progress","text":""},{"location":"reagent/wip/#do-not-deref-inside-lazy-sequences","title":"Do not deref inside lazy sequences","text":"<p>Hey, any idea why this doesn't work? Clicking on the button doesn't update the component</p> <p><pre><code>(defn root-component []\n(let [selected (r/atom 0)]\n(fn []\n[:p [:button {:on-click #(reset! selected 1)} \"Click me\"]\n(map\n(fn [x] (str (= x @selected)))\n[0 1 2])])))\n</code></pre> However, this works and update the component correctly:</p> <pre><code>(defn root-component []\n(let [selected (r/atom 0)]\n(fn []\n[:p [:button {:on-click #(reset! selected 1)} \"Click me\"]\n(str (map\n(fn [x] (= x @selected))\n[0 1 2]))])))\n</code></pre> <p>(note the difference of where I put the str function)</p> <p>dereferencing the selected atom inside of a lazy sequence, so reagent isn\u2019t able to capture the dereference and set up its tracking magic for you if you lift the dereference out of the map you should see it work:</p> <pre><code>(defn root-component []\n(let [selected (r/atom 0)]\n(fn []\n[:p [:button {:on-click #(reset! selected 1)} \"Click me\"]\n(let [selected-val @selected]\n(map\n(fn [x] (str (= x selected-val)))\n[0 1 2])]))))\n</code></pre>"},{"location":"reagent-project-clojurex/","title":"Reagent Project: ClojureX conference application","text":"<p>Creating a full stack clojurescript app with Reagent that will provide an interactive experience for conference attendees.</p> <ul> <li>Browse the schedule of sessions</li> <li>Star sessions that you want to attend</li> <li>Show your schedule (sessions you have stared)</li> <li>Show sessions by topic</li> </ul>"},{"location":"reagent-project-clojurex/create-project/","title":"Create the project","text":"<p>Create the project using the Leiningen Chestnut template</p> <pre><code>lein new chestnut conference-reagent -- --reagent\n</code></pre> <p>This will create a new project that includes the Reagent libraries (rather than the default om libraries).</p> <p>Open the <code>conference-reagent/project.clj</code> file to review the dependencies already added to the project.</p> <p>The only difference in dependencies is <code>[reagent \"0.6.0-rc\"]</code> instead of <code>omcljs/om</code>.</p> <pre><code>  :dependencies [[org.clojure/clojure \"1.8.0\"]\n[org.clojure/clojurescript \"1.9.89\" :scope \"provided\"]\n[com.cognitect/transit-clj \"0.8.285\"]\n[ring \"1.4.0\"]\n[ring/ring-defaults \"0.2.0\"]\n[bk/ring-gzip \"0.1.1\"]\n[ring.middleware.logger \"0.5.0\"]\n[compojure \"1.5.0\"]\n[environ \"1.0.3\"]\n[reagent \"0.6.0-rc\"]]\n</code></pre>"},{"location":"reagent-project-clojurex/create-project/#hintpassing-options-to-leiningen","title":"Hint::Passing Options to Leiningen","text":"<p>The <code>--</code> after the project name is needed to tell the command line to pass the option <code>--reagent</code> to the <code>lein</code> command, rather than be interpreted by the command line shell itself.</p>"},{"location":"reagent-project-clojurex/create-project/#hintrunning-multiple-projects","title":"Hint::Running multiple projects","text":"<p>To use Figwheel with multiple projects we will need to change the <code>:server-port</code> configuration to use a different port number.</p> <p>Edit the <code>project.clj</code>.</p> <p>Find the <code>:figwheel</code> section.</p> <p>Uncomment the <code>:server-port</code> configuration and change the number to something unique, eg. 3450</p>"},{"location":"reagent-project-clojurex/project-so-far/","title":"React ClojureX project so far","text":"<p>Thanks to the chestnut template our project already has some code that runs, so lets review what it does.</p>"},{"location":"reagent-project-clojurex/project-so-far/#defining-the-namespace","title":"Defining the namespace","text":"<p>Clojurescript uses namespaces to separate your application into logical areas.  The namespace matches the directory strucuture and filename.</p> <p>So the <code>conference-reagent.core</code> namespace is defined in a file <code>src/cljs/conference-reagent/core.cljs</code></p> <p>As we are using functions from the reagent library, we include that library using the alias <code>reagent</code>.  Using <code>:refer</code> we replace the clojurescript atom with the reagent atom.</p> <pre><code>(ns conference-reagent.core\n(:require [reagent.core :as reagent :refer [atom]]))\n</code></pre>"},{"location":"reagent-project-clojurex/project-so-far/#show-information-in-the-browser","title":"Show information in the browser","text":"<p>Show the log and error messages in the browser console.</p> <pre><code>(enable-console-print!)\n</code></pre>"},{"location":"reagent-project-clojurex/project-so-far/#defining-the-app-state","title":"Defining the App State","text":"<p>We want to have a model of our data that we can track when it changes.  This is managed in our <code>app-state</code>.</p> <p>The inital <code>app-state</code> is a map (hash map) that is an immutable data structure.  To manage changes to our state we wrap the <code>app-state</code> map with an atom.</p> <p>An atom is a mutable container.  As the clojurescript atom has been replaced by the reagent atom, then reagent can track any changes to the contents and decide when to update components based on that change.</p> <pre><code>(defonce app-state (atom {:text \"Hello Chestnut!\"}))\n</code></pre>"},{"location":"reagent-project-clojurex/project-so-far/#a-reagent-component","title":"A reagent component","text":"<p>The <code>greeting</code> function uses a hiccup like syntax to generate HTML from simple Clojure data structures.</p> <p>In this example a <code>h1</code> heading is generated which contains the value pointed to by the key called <code>:text</code> from our <code>app-state</code> map.</p> <pre><code>(defn greeting []\n[:h1 (:text @app-state)])\n</code></pre>"},{"location":"reagent-project-clojurex/project-so-far/#reagent-render","title":"Reagent render","text":"<p>The <code>reagent/render</code> function is used to display the components on screen.</p> <p>The components to render are passed as a vector (array) to the render function, this allows reagent to control when a component is rendered (and re-rendered due to a change of state).</p> <p>The components are rendered to a placeholder in the <code>resources/public/index.html</code> file, which contains a div with the class name <code>app</code>.</p> <pre><code>(reagent/render [greeting] (js/document.getElementById \"app\"))\n</code></pre>"},{"location":"reagent-project-clojurex/project-so-far/#hint","title":"Hint","text":"<p>Our application is going to render a single component which defines the overall single page app.  That component will contain a number of child components.</p> <p>To render multiple components seperately, simply define more placeholder class names in the html file.</p>"},{"location":"reagent-project-clojurex/start-the-repl/","title":"Start the REPL","text":"<p>A REPL will run the project code every time we save files or evaluate expressions.  This provides an instant feedback loop to ensure our application does what we think it should do.</p> <p>It may take 10-30 seconds to start the repl, especially if libraries are to be downloaded.  If nothing is displayed in your browser window, give it a few seconds and refresh the browser.</p>"},{"location":"reagent-project-clojurex/start-the-repl/#noterun-the-browser-repl-using-one-of-the-following-methods","title":"Note::Run the browser-repl using one of the following methods.","text":"<p>When you see the line <code>Successfully compiled \"resources/public/app.js\"</code> browse to http://localhost:3449 to see the running app.</p>"},{"location":"reagent-project-clojurex/start-the-repl/#hint","title":"Hint::","text":"<p>If you changed the <code>:figwheel :server-port</code> number in <code>project.clj</code> then you should use that number instead of 3449.</p>"},{"location":"reagent-project-clojurex/start-the-repl/#using-spacemacs-or-emacs-cider","title":"Using Spacemacs or Emacs &amp; CIDER","text":"<p>Use the command <code>clojurescript-jack-in</code> and open a browser at http://localhost:3449 </p> <pre><code>(setq cider-cljs-lein-repl\n\"(do (user/run)\n           (user/browser-repl))\")\n</code></pre>"},{"location":"reagent-project-clojurex/start-the-repl/#hintconfigure-emacs-to-use-browser-repl","title":"Hint::Configure Emacs to use browser-repl","text":"<p>Add the following elisp code to your <code>.spacemacs</code> (in <code>dotspacemacs/user-config</code>) or Emacs <code>.init.el</code> file to ensure the project (figwheel) runs the browser-repl rather than the default nashorn repl in the JVM.</p>"},{"location":"reagent-project-clojurex/start-the-repl/#command-line-other-editors","title":"Command Line &amp; other editors","text":"<p>Open a terminal and type <code>lein repl</code> to start a Clojure REPL or start a REPL from your editor.</p> <p>In the REPL, enter the following function calls then open a browser at http://localhost:3449 </p> <pre><code>(run)\n(browser-repl)\n</code></pre> <p>The call to <code>(run)</code> starts the Figwheel server at port 3449, which takes care of live reloading ClojureScript code and CSS. Figwheel's server will also act as your app server, so requests are correctly forwarded to the http-handler you define.</p> <p>Running <code>(browser-repl)</code> starts the Figwheel ClojureScript REPL. Evaluating expressions here will only work once you've loaded the page, so the browser can connect to Figwheel.</p> <p>When you see the line <code>Successfully compiled \"resources/public/app.js\" in 21.36 seconds.</code>, you're ready to go. Browse to <code>http://localhost:3449</code> and enjoy.</p>"},{"location":"reagent-projects/tic-tac-toe/","title":"Reagent Projects: Tic-tac-toe game","text":"<p>A classic tic-tac-toe game where you have to create a line of three consecutive <code>X</code> or <code>0</code> marks on the game board before your computer opponent does.</p> <p>The game uses ClojureScript, reagent and Scalable Vector Graphics (SVG) for the game.  Bulma CSS framework is used to create a professionally looking web page for the game.</p> <p></p>"},{"location":"reagent-projects/tic-tac-toe/#example-code","title":"Example code","text":"<p>The source code for this project can be found on Github at practicalli/tictactoe-reagent</p>"},{"location":"reagent-projects/tic-tac-toe/#credits","title":"Credits","text":"<ul> <li>Building Tic Tac Toe in ClojureScript (Reagent/Figwheel) on YouTube</li> </ul>"},{"location":"reagent-projects/tic-tac-toe/#references-other-approaches","title":"References &amp; other approaches","text":"<ul> <li>TicTacToe to Othello</li> <li>t3 - tictactoe with reagent, minimax ai and testing with speclj</li> </ul>"},{"location":"reagent-projects/tic-tac-toe/add-project-to-git/","title":"Tic-tac-toe: Add Project to Git Version Control","text":"<p>To manages the changes in the project I am using Git version control.</p> <p>The figwheel template includes a <code>.gitignore</code> file that defines file &amp; directories that should automatically be excluded from any commit.</p> <p>This initial commit should have included the following files:</p> <p></p>"},{"location":"reagent-projects/tic-tac-toe/add-project-to-git/#notecreate-local-git-repository-and-commit-changes","title":"Note::Create local git repository and commit changes","text":"<pre><code>git init\ngit add .\ngit commit -m \"Leiningen Project using figwheel template with reagent option\"\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/add-project-to-git/#optionally-update-project-description-license","title":"Optionally: Update project description &amp; license","text":"<p>I encourage you to write a simple project description in the <code>project.clj</code> file to give a high level idea of what the project is about.</p> <p>If the project is open source then I also include the online repository for the code in the <code>:url</code> section.</p> <p>I also prefer to use a Creative Commons license rather than the Eclipse public license for open source works.</p> <p></p>"},{"location":"reagent-projects/tic-tac-toe/add-project-to-git/#reference-default-exclusions-in-gitignore","title":"Reference: Default exclusions in .gitignore","text":"<p>The figwheel template includes a <code>.gitignore</code> file including the relevant patterns to exclude files that are typically not useful to commit to a git repository.</p> <pre><code>/resources/public/js/compiled/**\nfigwheel_server.log\npom.xml\n*jar\n/lib/\n/classes/\n/out/\n/target/\n.lein-deps-sum\n.lein-repl-history\n.lein-plugins/\n.repl\n.nrepl-port\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/add-project-to-git/#hintavoid-including-tooling-editor-specific-exclusions","title":"Hint::Avoid including tooling &amp; editor specific exclusions","text":"<p>The <code>.gitignore</code> file should only be used for project specific exclusions.</p> <p>If you have common exclusions for your tooling or editors across multiple projects, then you can use the <code>~/.gitignore_global</code> file.</p> <p>Git Ignore for Clojure &amp; Emacs - ignore Emacs backup &amp; temporary files</p>"},{"location":"reagent-projects/tic-tac-toe/button--start-a-new-game/","title":"Button: Start a new game","text":"<p>Add a button to the <code>tictactoe-game</code> component to start a new game.</p> <p>The button resets the board by updating the <code>app-state</code>.  The current <code>app-state :board</code> is swapped with a new game board with all the values set to <code>:empty</code>.</p> <pre><code>(defn tictactoe-game []\n[:div\n[:div\n[:h1 (:text @app-state)]\n[:p \"Do you want to play a game?\"]]\n[:button {:on-click (fn new-game-click [e]\n(swap! app-state assoc :board (game-board board-dimension)))}\n\"Start a new game\"]\n[:center\n[:svg {:view-box \"0 0 3 3\"\n:width 500\n:height 500}\n(for [x-cell (range (count (:board @app-state)))\ny-cell (range (count (:board @app-state)))]\n(case (get-in @app-state [:board y-cell x-cell])\n:empty [cell-empty x-cell y-cell]\n:cross [cell-cross x-cell y-cell]\n:nought [cell-nought x-cell y-cell]))]]])\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/chrome-devtools/","title":"Chrome DevTools","text":"<p>The Chrome Developer Tools (DevTools for short), are a set of web authoring and debugging tools built into Google Chrome. The DevTools provide web developers deep access into the internals of the browser and their web application. Use the DevTools to efficiently track down layout issues, set JavaScript breakpoints, and get insights for code optimization.</p> <p>As our ClojureScript generates JavaScript, then the Chrome DevTools provide an additional feedback tool for when our code is running in the browser.</p> <p>Whilst we build the Tic Tac Toe game we will use the Console Panel, Elements Panel and Sources Panel.</p> <p></p>"},{"location":"reagent-projects/tic-tac-toe/chrome-devtools/#noteopen-the-devtools-console","title":"Note::Open the DevTools Console","text":"<p>You can open the DevTools  using one of the following ways</p> <ul> <li>Keyboard shortcut: Press Ctrl-Shift-i</li> <li>Mouse context menu: Right click on the Hello World page and select Inspect from the menu.</li> <li>The Chrome browser menu: Select \"More tools\" &gt; \"Developer tools\"</li> </ul> <p>When the DevTools window opens, select the Console tab.</p>"},{"location":"reagent-projects/tic-tac-toe/chrome-devtools/#info","title":"Info::","text":"<p>If you see a warning message saying \"some customer formaters were not rendered\", this is fixed on the next page when we \"Enable custom formatters\"</p>"},{"location":"reagent-projects/tic-tac-toe/clean-the-project/","title":"Cleaning up","text":"<p>If the project is behaving strangely, a quick solution may be to clean the project.  This removes anything built from source code and ensures your not picking up older versions.</p> <p>To clean all compiled files:</p> <pre><code>lein clean\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/cljs-devtools-addon/","title":"ClojureScript DevTools addon - cljs-devtools","text":""},{"location":"reagent-projects/tic-tac-toe/cljs-devtools-addon/#enable-custom-formatters-for-clj-devtools","title":"Enable custom formatters for clj-devtools","text":"<p>To enable custom formatters you simply need to switch on the Enable custom formatters option in the DevTools preferences.  This option is under the Console section of those preferences</p> <p></p>"},{"location":"reagent-projects/tic-tac-toe/cljs-devtools-addon/#_1","title":"Cljs DevTools addon","text":""},{"location":"reagent-projects/tic-tac-toe/cljs-devtools-addon/#info","title":"Info::","text":"<p>If you see a warning message saying \"some customer formaters were not rendered\", this is fixed on the next page when we \"Enable custom formatters\"</p>"},{"location":"reagent-projects/tic-tac-toe/code-review-initial-project/","title":"Tic-tac-toe: Code Review - Initial Project","text":"<p>Lets take a quick look at the project files to see what the figwheel template created when we ran <code>lein new figwheel tictactoe-reagent -- --reagent</code></p>"},{"location":"reagent-projects/tic-tac-toe/code-review-initial-project/#project-configuration","title":"Project configuration","text":"<p>The <code>project.clj</code> contains all the configuration for the ClojureScript project.  This included the libraries (dependencies) that the project uses.</p>"},{"location":"reagent-projects/tic-tac-toe/code-review-initial-project/#main-clojurescript-file","title":"Main ClojureScript file","text":"<p>The <code>src/tictactoe-reagent/core.cljs</code> file contains the code that the project will call when run.</p>"},{"location":"reagent-projects/tic-tac-toe/component-game-board/","title":"Component Game Board","text":"<p>Now we have experiment with the board design, lets put our results into a component.</p> <pre><code>(defn game-board\n\"Create a data structure to represent the values of cells in the game board.\n  A vector is used to hold the overall game board\n  Each nested vector represents a line of the game board.\n  Dimension specifies the size of the game board.\"\n[dimension]\n(vec (repeat dimension (vec (repeat dimension :empty)))))\n</code></pre> <p>Lets create a default dimension for the board (width &amp; height)</p> <p>As the game board is square, we only use one value for height and width</p> <pre><code>(def board-dimension 3)\n</code></pre> <p>Update the <code>app-state</code> so that it doesn't get over-written on reload</p> <pre><code>(defonce app-state\n(atom\n{:page\n{:title \"Lets Play TicTacToe\"\n:message \"Do you want to play a game?\"}\n:board\n(game-board board-dimension)}))\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/component-tictactoe-game/","title":"Component: TicTacToe","text":"<p>A reagent component is simply a Clojure function.  So we can take the hello world function and change it to <code>tictactoe-game</code>.</p> <p>First we will add a simple title and message to the component.  So the text of these is not hard-coded in the component, we will pull them from the app-state.</p> <pre><code>(defn tictactoe-game []\n[:div\n[:h1 (get-in @app-state [:page :title])]\n[:p  (get-in @app-state [:page :message])]])\n</code></pre> <p>Now lets update the <code>app-state</code> to hold the title and message we want to display in the component.</p> <pre><code>(defonce app-state\n(atom\n{:page\n{:title \"Lets Play TicTacToe\"\n:message \"Do you want to play a game?\"}}))\n</code></pre> <p>Next we need to model the game board and add the board to the <code>tictactoe-game</code> component.</p>"},{"location":"reagent-projects/tic-tac-toe/computer-move--basic/","title":"Computer Move: Basic","text":"<p>Lets assume that the human player always goes first for now.</p> <p>Once the human player has taken their turn, we will call a function for the computer to take their turn.</p> <p>So we add a call to <code>computer-move</code> to the <code>:on-click</code> option of the <code>cell-empty</code> function.</p> <pre><code>(defn cell-empty\n\"Generate a cell that has not yet been clicked on\"\n[x-cell y-cell]\n^{:key (str x-cell y-cell)}\n[:rect {:width 0.9\n:height 0.9\n:fill \"grey\"\n:x x-cell\n:y y-cell\n:on-click\n(fn rectangle-click [e]\n(println \"Cell\" x-cell y-cell \"was clicked!\")\n(println\n(swap! app-state assoc-in [:board y-cell x-cell] :nought))\n(computer-move))}])\n</code></pre> <p>Then add the <code>computer-move</code> function</p> <pre><code>(defn computer-move\n\"Takes a turn for the computer, adding an X shape to the board\"\n[]\n(swap! app-state assoc-in [:board 0 0] :cross))\n</code></pre> <p></p> <p></p>"},{"location":"reagent-projects/tic-tac-toe/computer-move--basic/#hint-thinking-time","title":"Hint:: Thinking time","text":"<p>We could add some artificial thinking time to the computer move using <code>js/setTimeout</code>.  If you do set some thinking time, then you should also visualise that the computer is thinking, so the human player knows what is going on. <pre><code>(js/setTimeout (fn []) timeout)\n</code></pre></p>"},{"location":"reagent-projects/tic-tac-toe/computer-move--random-available-cell/","title":"Computer Move: Random Available Cell","text":"<pre><code>(defn computer-move\n\"Takes a turn for the computer, adding an X shape to the board\"\n[]\n(let [available-cells\n(for [row    (range board-dimension)\ncolumn (range board-dimension)\n:when (=\n:empty\n(get-in (@app-state :board) [column row]))]\n[column row])\nnext-move (when (seq available-cells)\n(rand-nth available-cells))]\n(if next-move\n(do\n(prn \"Computer move at:\" next-move)\n(swap! app-state assoc-in [:board (first next-move) (second next-move)] :cross))\n(prn \"Computer move: no more moves available\"))))\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/computer-move--random-available-cell/#hint","title":"Hint::","text":"<p>If there are no more moves left, then a message could be displayed on the web page, so the user knows (although as the cells are all full, then its kind of implied)</p>"},{"location":"reagent-projects/tic-tac-toe/computer-move--repl-experiments/","title":"Computer Move: REPL Experiments","text":"<p>Lets define a sample game board to work with, a board that is part way through a game should give us a good way to test computer moves</p> <pre><code>(def game-board-example-mid-game\n[[:cross :nought :empty]\n[:empty :nought :empty]\n[:cross :nought :empty]])\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/computer-move--repl-experiments/#iterate-over-the-board","title":"Iterate over the board","text":"<p>To make a move there needs to be an empty cell on the board to make a move in.</p> <pre><code>(= :empty (get-in game-board-example-mid-game [1 0]))\n;; =&gt; true\n(= :empty (get-in game-board-example-mid-game [0 2]))\n;; =&gt; true\n</code></pre> <p>lets get the co-ordinates for all the cells on the board that are empty, so we know which cells are available</p> <pre><code>(for [row    (range board-dimension)\ncolumn (range board-dimension)\n:when  (= :empty\n(get-in game-board-example-mid-game [row column]))]\n[row column])\n;; =&gt; ([0 2] [1 0] [1 2] [2 2])\n</code></pre> <p>We can use the same approach, but assigning it to a local name with let, so we can do more with the result</p> <pre><code>(let [available-cells (for [row    (range 3)\ncolumn (range 3)\n:when (= :empty\n(get-in game-board-example-mid-game [row column]))]\n[row column])]\navailable-cells)\n;; =&gt; ([0 2] [1 0] [1 2] [2 2])\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/computer-move--repl-experiments/#did-we-find-any-empty-cells","title":"Did we find any empty cells","text":"<p>We can check with the <code>empty?</code> function and therefore check if there are available cells by inverting the check with <code>not</code></p> <pre><code>(empty? '([0 2] [1 0] [1 2] [2 2]))\n(not (empty? '([0 2] [1 0] [1 2] [2 2])))\n</code></pre> <p>However there is a Clojure idiom to use seq (mentioned in the docs for empty?)</p> <pre><code>#_(seq '([0 2] [1 0] [1 2] [2 2]))\n;; =&gt; ([0 2] [1 0] [1 2] [2 2])\n#_(seq '())\n;; =&gt; nil\n</code></pre> <p>So with seq if there are empty cells, those values are returned, otherwise <code>nil</code> is returned (which is falsey)</p>"},{"location":"reagent-projects/tic-tac-toe/computer-move--repl-experiments/#randomly-selecting-an-available-cell","title":"Randomly selecting an available cell","text":"<p>To get one of the co-ordinates assuming there are available cells, we can use rand-nth</p> <pre><code>#_(rand-nth '([0 2] [1 0] [1 2] [2 2]))\n;; =&gt; [0 2]\n</code></pre> <p>Putting seq and rand-nth together we can get one of the available positions</p> <pre><code>(def available-cells-example '([1 0] [0 2] [1 2] [2 2]))\n(when (seq available-cells-example)\n(rand-nth available-cells-example))\n;; =&gt; [1 2]\n</code></pre> <p>The computer can now make moves until no more cells are available</p> <pre><code>(let [available-cells\n(for [row    (range board-dimension)\ncolumn (range board-dimension)\n:when (=\n:empty\n(get-in game-board-example-mid-game [column row]))]\n[column row])\nnext-move (when (seq available-cells)\n(rand-nth available-cells))]\n(if next-move\n(str \"update app-state\")\n(str \"display messages saying no more moves\")))\n;; =&gt; \"update app-state\"\n</code></pre> <p>Now we can fit this algorithm into our game code</p>"},{"location":"reagent-projects/tic-tac-toe/computer-moves/","title":"Computer Moves","text":"<p>Its going to be an easy game if we do not have an opponent, so lets add a computer opponent.</p> <p></p>"},{"location":"reagent-projects/tic-tac-toe/create-project/","title":"Tic-tac-toe: Create project","text":"<p>Create the project using the figwheel-main template to quickly create a working configuration.  The template can be used with Clojure CLI tools or Leiningen</p> <p>The project will include the reagent library as a dependency, along with code for a working reagent application.</p> <p>{% tabs deps=\"deps.edn projects\", lein=\"Leiningnen projects\" %}</p> <p>{% content \"deps\" %} Use the <code>:project/new</code> alias from <code>practicalli/clojure-deps-edn</code> to create a new Clojure CLI tools project, using the figwheel-main template.</p> <pre><code>clojure -M:project/new figwheel-main practicalli/tictactoe -- --reagent\n</code></pre> <p>The output of the command should look similar to this:</p> <p></p>"},{"location":"reagent-projects/tic-tac-toe/create-project/#depsedn-configuration","title":"deps.edn configuration","text":"<p>The template creates a project <code>deps.edn</code> configuration.</p> <p>The aliases section includes the figwheel-main and rebel-readline-cljs libraries.  This has been renamed from <code>:fig</code> to <code>:figwheel</code>.</p> <p>The aliases section also has 3 different build configurations, each of which runs figwheel with a specific configuration.  One of these aliases should be used with the <code>:figwheel</code> alias.</p> <ul> <li><code>:build</code> is the development build of the project and runs a rebel readline REPL</li> <li><code>:minify</code> (renamed from <code>:min</code>) generates a single javascript file for deployment, using advanced deployment</li> <li><code>:test-runner</code> (renamed from <code>:test</code>) will run unit tests and show a test report in the browser</li> </ul> <pre><code>{:paths [\"src\" \"resources\"]\n:deps\n{org.clojure/clojure       {:mvn/version \"1.10.0\"}\norg.clojure/clojurescript {:mvn/version \"1.10.773\"}\nreagent                   {:mvn/version \"0.10.0\" }}\n:aliases\n{:figwheel\n{:extra-deps\n{com.bhauman/rebel-readline-cljs {:mvn/version \"0.1.4\"}\ncom.bhauman/figwheel-main       {:mvn/version \"0.2.11\"}}\n:extra-paths [\"target\" \"test\"]}\n;; build configurations\n:build\n{:main-opts [\"-m\" \"figwheel.main\" \"-b\" \"dev\" \"-r\"]}\n:minify\n{:main-opts [\"-m\" \"figwheel.main\" \"-O\" \"advanced\" \"-bo\" \"dev\"]}\n:test-runner\n{:main-opts [\"-m\" \"figwheel.main\" \"-co\" \"test.cljs.edn\" \"-m\" \"practicalli.test-runner\"]}\n} ;; End of aliases\n}  ;; End of deps.edn\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/create-project/#starting-the-development-build","title":"Starting the development build","text":"<p>Open a terminal window in the root of the tictactoe projects and run the <code>clojure</code> command with the <code>:figwheel</code> and <code>:build</code> aliases</p> <pre><code>clojure -M:figwheel:build\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/create-project/#starting-the-unit-test-runner","title":"Starting the unit test runner","text":"<p>Open a terminal window in the root of the tictactoe projects and run the <code>clojure</code> command with the <code>:figwheel</code> and <code>:test-runner</code> aliases</p> <pre><code>clojure -M:figwheel:test-runner\n</code></pre> <p>{% content \"lein\" %}</p> <p>Use Leiningen build tool to create a new Clojurescript project, using the figwheel-main template.</p> <pre><code>lein new figwheel practicalli.tictactoe -- --reagent\n</code></pre> <p></p> <p>{% endtabs %}</p>"},{"location":"reagent-projects/tic-tac-toe/create-project/#project-structure","title":"Project structure","text":"<p>The project created should have the following files and directories</p> <p></p> <p>You can use any command line or graphical file browser to view the project structure.</p>"},{"location":"reagent-projects/tic-tac-toe/deploy-to-production/","title":"Deploy to production","text":""},{"location":"reagent-projects/tic-tac-toe/deploy-to-production/#production-builds","title":"Production builds","text":"<p>To create a production build, run:</p> <pre><code>lein do clean, cljsbuild once min\n</code></pre> <p>Open your browser in <code>resources/public/index.html</code>. You will not get live reloading, nor a REPL.</p>"},{"location":"reagent-projects/tic-tac-toe/deploy-to-production/#hintwhat-does-a-production-build-do","title":"Hint::What does a production build do","text":"<p>Creating a production build in this way Minifys the resulting JavaScript code, reducing names of vars and function to a minimum number of characters.  This result in a much smaller JavaScript file which takes a little less time to be transmitted.</p> <p>The production build also carries out Dead Code analysis, where any code that is never called is simply removed from the resulting JavaScript.</p> <p>Both these actions result in a much faster execution of the JavaScript code, resulting in a better experience in the web browser.</p>"},{"location":"reagent-projects/tic-tac-toe/design-game-board/","title":"Designing the Game Board","text":"<p>Using the REPL we can experiment with different ways to model the game board.</p>"},{"location":"reagent-projects/tic-tac-toe/design-game-board/#how-to-represent-a-cell","title":"How to represent a cell","text":"<p>A cell is either going to be empty, or contain a nought or cross.  For simplicity, we will start with three keywords</p> <pre><code>:empty\n:nought\n:cross\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/design-game-board/#representing-the-whole-board","title":"Representing the whole board","text":"<p>We could just hard code the board as a vector of rows, with each row being a vector.  In this example we set all the board cells to <code>:empty</code></p> <pre><code>[[:empty :empty :empty]\n[:empty :empty :empty]\n[:empty :empty :empty]]\n</code></pre> <p>Generating a data structure to represet the game board</p> <p>To create a row is simple to do using the repeat function to generate 3 :empty keywords and return them as a list</p> <pre><code>(repeat 3 :empty)\n</code></pre> <p>To make this a vector we can just wrap that in a vec function</p> <pre><code>(vec (repeat 3 :empty))\n</code></pre> <p>To create three rows we just repeat the code above 3 times</p> <pre><code>(vec (repeat 3 (vec (repeat 3 :empty))))\n</code></pre> <p>We can use the above code in a function and replace 3 with a local name that takes the value of the argument passed in so lets write a game-board function.</p> <p>If you need a quick break while modeling your game board, here is a very silly distraction</p> <p>{% youtube %} https://youtu.be/0h9jN12QbdE</p>"},{"location":"reagent-projects/tic-tac-toe/detecting-victory--rows/","title":"Dectecting Victory - rows only","text":"<p>A function that will test to see if a row has a winning line</p> <pre><code>(defn winning-row\n\"Return the winner, :nought or :cross if there is a winning row, otherwise return false\"\n[cell-row]\n(if (and (apply = cell-row)\n(apply #(not= :empty %) cell-row))\n(first cell-row)\nfalse))\n</code></pre> <p>Lets add something simple to check if the first row is a winner</p> <pre><code>(defn check-for-winner\n\"Checks the app-state to see if there is a current winner\"\n[]\n(let [winner (winning-row (first (@app-state :board)))]\n(prn \"The winner is:\" winner)\nwinner))\n</code></pre> <p>Now lest update check-for-winner to try all rows.  We will assume that there will be only one winning row.</p>"},{"location":"reagent-projects/tic-tac-toe/detecting-victory-function/","title":"Detecting Victory: Function","text":"<pre><code>(defn cell-empty?\n[cell-value] (not= :empty cell-value))\n</code></pre> <pre><code>(defn winning-line? [cell-row]\n(and\n(apply = cell-row)\n(apply cell-empty? cell-row)))\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/detecting-victory-repl-experiments-pattern-matching/","title":"Detecting Victory: Pattern matching REPL Experiments","text":"<p>A seemingly simple approach to detecting a winner is to use pattern matching.  Clojure also has the concept of destructuring, extracting values from a data structure based on a pattern.</p> <p>The limitation with this approach is that more patterns need to be created if the size of the board changes</p> <p>For a fixed 3x3 game board there are only 8 winning combinations, we could just create a pattern for each win. The patterns are the same for <code>:nought</code> and <code>:cross</code> we could just compare that each value is equal</p>"},{"location":"reagent-projects/tic-tac-toe/detecting-victory-repl-experiments-pattern-matching/#define-patterns-for-matching-horizontal-winning-lines","title":"Define patterns for matching horizontal winning lines","text":"<pre><code>(def column-first\n[[cell-0 _ _]\n[cell-1 _ _]\n[cell-2 _ _]])\n(def column-second\n[[_ cell-0 _]\n[_ cell-1 _]\n[_ cell-2 _]])\n(def column-third\n[[_ _ cell-0]\n[_ _ cell-1]\n[_ _ cell-2]])\n(defn check-winning-rows\n[board]\n(let [[[cell-0 _ _]\n[cell-1 _ _]\n[cell-2 _ _]]\nboard]\n(if (= cell-0 cell-1 cell-2)\ncell-0\nfalse)))\n(check-winning-rows [[:cross :cross :cross]\n[:cross :cross :cross]\n[:cross :cross :cross]])\n;; =&gt; :cross\n(check-winning-rows [[:cross :cross :nought]\n[:nought :nought :cross]\n[:cross :cross :nought]])\n;; =&gt; false\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/detecting-victory-repl-experiments-pattern-matching/#pattern-matching-diagonals","title":"Pattern matching diagonals","text":"<pre><code>(= [:cross :cross :cross] [:cross :cross :cross])\n(def board-of-crosses   [[:cross :cross :cross]\n[:cross :cross :cross]\n[:cross :cross :cross]])\n(def board-of-stalemate [[:cross :cross :nought]\n[:nought :nought :cross]\n[:cross :cross :nought]])\n(=  [[:cross :cross :cross] [:cross :cross :cross] [:cross :cross :cross]]\n[[:cross :cross :cross] [:cross :cross :cross] [:cross :cross :cross]])\n;; =&gt; true\n(=  [[:cross :cross :cross] [:cross :cross :cross] [:cross :cross :cross]]\n[[:cross :cross :cross] [:cross :cross :cross] [:cross :cross :nought]])\n;; =&gt; true\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/detecting-victory-repl-experiments-pattern-matching/#pattern-matching-using-destructuring","title":"Pattern matching using destructuring","text":"<p>Using destructuring we can just look at the values we are interested in</p> <p>The let destructuring pattern pulls out the values for the diagonal line, from top left to bottom right</p> <pre><code>(let [[[cell-00 _ _][_ cell-11 _][_ _ cell-22]] board-of-crosses]\n(= cell-00 cell-11 cell-22))\n;; =&gt; true\n(let [[[cell-00 _ _][_ cell-11 _][_ _ cell-22]] board-of-stalemate]\n(println cell-00 \":\" cell-11 \":\" cell-22)\n(= cell-00 cell-11 cell-22))\n;; =&gt; false\n</code></pre> <p>Not sure naming these patterns with a def is that useful Not this way, as its not correct clojure (names are not defined)</p> <p>Should create two functions instead</p> <pre><code>#_(def diagonal-row--top-left-to-bottom-right\n[[cell-00 _ _]\n[_ cell-11 _]\n[_ _ cell-22]])\n#_(def diagonal-row--top-right-to-bottom-left\n[[_ _ cell-02]\n[_ cell-11 _]\n[cell-20_ _]])\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/detecting-victory-repl-experiments/","title":"Detecting Victory: REPL Experiments","text":""},{"location":"reagent-projects/tic-tac-toe/detecting-victory-repl-experiments/#find-a-winning-row","title":"Find a winning row","text":"<p>To find a winning row we can compare the values in the vector with each other</p> <pre><code>#_(apply = [:cross :cross :cross])\n;; =&gt; true\n#_(apply = [:nought :nought :nought])\n;; =&gt; true\n#_(apply = [:empty :cross :empty])\n;; =&gt; false\n#_(apply = [:cross :nought :empty])\n;; =&gt; false\n</code></pre> <p>However, this approach also matches an :empty row or column</p> <pre><code>#_(apply = [:empty :empty :empty])\n;; =&gt; true\n</code></pre> <p>Using an anonymous function over the collection allows us to compare each value, if all values are not= :empty then we can return true</p> <pre><code>(apply  (fn [cell-value] (not= :empty cell-value))[:empty :cross :cross])\n</code></pre> <p>As we will probably call this multiple times, lets convert it into a named function.</p> <pre><code>(defn cell-empty?\n[cell-value] (not= :empty cell-value))\n</code></pre> <p>Hmm, still not idea, as any combination that does not contain :empty will return true</p> <pre><code>(cell-empty? [[:cross :nought :cross]])\n</code></pre> <p>Applying both checks will give the right results</p> <pre><code>(defn winning-line? [cell-row]\n(and\n(apply = cell-row)\n(apply cell-empty? cell-row)))\n#_(winning-line? [:cross :cross :cross])\n;; =&gt; true\n#_(winning-line? [:nought :nought :nought])\n;; =&gt; true\n#_(winning-line? [:cross :nought :cross])\n;; =&gt; false\n#_(winning-line? [:empty :empty :empty])\n;; =&gt; false\n#_(winning-line? [:empty :nought :cross])\n;; =&gt; false\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/detecting-victory/","title":"Detecting Victory","text":"<p>So far we can play the game until all the cells contain either a nought or cross.</p> <p>Lets add some code to detect winning moves.</p> <p>A winning move is one of either</p> <ul> <li>a row of 3 consecutive noughts or crosses</li> <li>a column of 3 consecutive noughts or crosses</li> <li>a diagonal line of 3 consecutive noughts or crosses</li> </ul> <p></p>"},{"location":"reagent-projects/tic-tac-toe/figwheel-helper-functions/","title":"Figwheel Helper Functions","text":"<p>The lein-figwheel template provides several helper functions in <code>dev/user.clj</code> to start Figwheel and a Clojurescript REPL from a Clojure REPL.</p> <p>In a development environment a Clojure REPL will start in <code>user</code> namespace, so the functions in <code>dev/user.clj</code> are available when you run a Clojure REPl in Spacemacs - <code>SPC m '</code></p> <pre><code>(ns user\n(:require\n[figwheel-sidecar.repl-api :as f]))\n;; user is a namespace that the Clojure REPL loads if its available\n;; Helper functions can also be added for starting and stopping a webserver or other development services\n(defn fig-start\n\"This starts the figwheel server and watch based auto-compiler.\"\n[]\n(f/start-figwheel!))\n(defn fig-stop\n\"Stop the figwheel server and watch based auto-compiler.\"\n[]\n(f/stop-figwheel!))\n;; com.cemerick/piggieback is added as a :profile :dev :dependency to support an nREPL environment\n(defn cljs-repl\n\"Launch a ClojureScript REPL that is connected to your build and host environment.\"\n[]\n(f/cljs-repl))\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/figwheel-helper-functions/#warningcontent-relates-to-the-classic-figwheel-version","title":"WARNING::Content relates to the classic figwheel version","text":"<p>This approach is not require when using <code>figwheel-main</code>, only for older projects that were created using the original version of figwheel</p>"},{"location":"reagent-projects/tic-tac-toe/figwheel-helper-functions/#emacs-jack-in","title":"Emacs jack-in","text":"<p>You can use these Figwheel helper functions with Emacs &amp; Cider (and Spacemacs) by adding the following function in your <code>init.el</code> configuration file (or ~/.spacmacs file in the <code>dotspacemacs/user-config</code> section)</p> <pre><code>(setq cider-cljs-lein-repl\n\"(do\n    (user/fig-start)\n    (user/cljs-repl))\")\n</code></pre> <p>When you run the Emacs command <code>clojurescript-jack-in</code> the <code>cider-cljs-lein-repl</code> name is evaluated and the two helper functions are run one after the other.</p>"},{"location":"reagent-projects/tic-tac-toe/figwheel-helper-functions/#atom-and-protorepl","title":"Atom and ProtoREPL","text":"<p>See the ClojureScript section on Practicalli, ProtoREPL</p>"},{"location":"reagent-projects/tic-tac-toe/interact-with-the-repl-evaluate-code/","title":"Interact with the REPL evaluate code","text":"<p>Evaluating code in the REPL directly is useful for testing quick changes to your application, so its very useful for changing the <code>app-state</code> and seeing the results.</p> <p>Any code you enter in the REPL directly that you want to use again can be added to the source code file as a comment.</p> <pre><code>(swap! app-state assoc :text \"Evaluating code in the REPL is fun\")\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/interact-with-the-repl-evaluate-code/#noteupdate-the-text-in-app-state","title":"Note::Update the :text in <code>app-state</code>","text":"<p>In the repl, update the string value that is associated with :text in the map inside the <code>app-state</code> atom.</p> <p>The swap! function is used to update the value of an atom. The assoc function can be used to create a new value in a map</p>"},{"location":"reagent-projects/tic-tac-toe/interact-with-the-repl-via-editor/","title":"Interact with the REPL via your editor","text":"<pre><code>(defn tictactoe-game []\n[:div\n[:h1 (:text @app-state)]\n[:p \"Do you want to play a game?\"]])\n</code></pre> <pre><code>(defonce app-state (atom {:text \"Lets Play TicTacToe\"}))\n</code></pre> <p>When you save a change to the <code>app-state</code> nothing happens in the browser.</p> <p>As we use <code>defonce</code> rather than <code>def</code>, then Clojure does not update the definition if it already exists.  This prevents your app state from being cleared every time you save a change in your editor.</p> <p>To see the change of a <code>defonce</code> you need to refresh your browser page.</p>"},{"location":"reagent-projects/tic-tac-toe/interact-with-the-repl-via-editor/#hint","title":"Hint::","text":"<p>Your editor should either be running the Clojure/ClojureScript REPL's or connected to the REPLs run with <code>lein figwheel</code></p>"},{"location":"reagent-projects/tic-tac-toe/interact-with-the-repl-via-editor/#noteedit-welcome-message","title":"Note::Edit welcome message","text":"<p>Edit the message [:h3] in the <code>hello-world</code> component and see how it changes in the web browser <pre><code>(defn hello-world []\n[:div\n[:h1 (:text @app-state)]\n[:h3 \"Edit this and watch it change!\"]])\n</code></pre></p>"},{"location":"reagent-projects/tic-tac-toe/interact-with-the-repl-via-editor/#notechange-the-title-by-editing-the-app-state","title":"Note::Change the title by editing the <code>app-state</code>","text":"<p>Change the :text message in <code>app-state</code> and see what happens in the browser <pre><code>(defonce app-state (atom {:text \"Hello World\"}))\n</code></pre></p>"},{"location":"reagent-projects/tic-tac-toe/interact-with-the-repl/","title":"Interact with the REPL","text":"<p>Using the REPL gives you instant feedback as it evaluates your code.</p> <p>When Figwheel is running it sends any saved changes to the REPL and automatically updates your application in the web browser, instantly showing you the results or bugs :)</p> <p>You can develop the game with the REPL by saving code changes in your editor or entering code in the REPL directly (or a combination of both).</p> <p>This section shows you how to interact with the REPL.</p>"},{"location":"reagent-projects/tic-tac-toe/react-unique-index/","title":"React Unique Index","text":"<p>When we render the game board in React.js it really wants a unique index for every cell in the grid of cells.</p>"},{"location":"reagent-projects/tic-tac-toe/react-unique-index/#inforeference","title":"Info::Reference","text":"<p>Redit: How to use reagent in ClojureScript for Iterating</p>"},{"location":"reagent-projects/tic-tac-toe/react-unique-index/#warning-in-browser","title":"Warning in browser","text":"<p>In the Developer console of the browser, you see the following error:</p> <p>Every element in a sequence should have a unique key</p> <p></p>"},{"location":"reagent-projects/tic-tac-toe/react-unique-index/#what-reactjs-is-looking-for","title":"What React.js is looking for","text":"<p>When we render the game board in React.js we use the following generated data structure</p> <pre><code>([:rect {:width 0.9, :height 0.9, :fill \"purple\", :x 0, :y 0}]\n[:rect {:width 0.9, :height 0.9, :fill \"purple\", :x 0, :y 1}]\n[:rect {:width 0.9, :height 0.9, :fill \"purple\", :x 0, :y 2}]\n[:rect {:width 0.9, :height 0.9, :fill \"purple\", :x 1, :y 0}]\n[:rect {:width 0.9, :height 0.9, :fill \"purple\", :x 1, :y 1}]\n[:rect {:width 0.9, :height 0.9, :fill \"purple\", :x 1, :y 2}]\n[:rect {:width 0.9, :height 0.9, :fill \"purple\", :x 2, :y 0}]\n[:rect {:width 0.9, :height 0.9, :fill \"purple\", :x 2, :y 1}]\n[:rect {:width 0.9, :height 0.9, :fill \"purple\", :x 2, :y 2}])\n</code></pre> <p>For the developer we can see that combining the <code>:x</code> and <code>:y</code> co-ordinates would provide an implied index, React.js is looking for something implicit.</p>"},{"location":"reagent-projects/tic-tac-toe/react-unique-index/#adding-meta-data-to-each-cell","title":"Adding Meta data to each cell","text":"<p>To fix this issue, we add a piece of metadata to each cell in the game board by combining the <code>:x</code> and <code>:y</code> co-ordinates into a single value.</p> <pre><code>^{:key (str x-cell y-cell)}\n</code></pre> <p>So when we iterate through the game board using the <code>for</code> function, we generate a unique metadata :key for each cell, ie. 00, 01, 02, etc</p> <pre><code>(for [x-cell (range (count (:board @app-state)))\ny-cell (range (count (:board @app-state)))]\n^{:key (str x-cell y-cell)})\n)\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/reagent-design-defining-components/","title":"Reagent Design: Defining Components","text":""},{"location":"reagent-projects/tic-tac-toe/reagent-design-manage-app-state/","title":"Reagent Design: Manage App State","text":"<p>State changes are an unavoidable in an user interface (UI).  A UI wouldnt be much good if it didnt change and show you new information.</p> <p>An Atom is used manage state changes in Reagent, specifically the Atom from the Reggent library</p> <p>Unlike most things in Clojure, an Atom is mutable.  This means that when you use a function to change the atom, the contents of that atom really changes.</p>"},{"location":"reagent-projects/tic-tac-toe/reagent-design-manage-app-state/#game-state","title":"Game state","text":"<p>The state of the game changes as the players take turns.  The squares on the board will change state from containing nothing, a nought or a cross.</p>"},{"location":"reagent-projects/tic-tac-toe/reagent-design-manage-app-state/#why-use-an-atom-isnt-mutable-state-bad","title":"Why use an Atom?  Isnt mutable state bad?","text":"<p>Clojure developers minimise the use of mutable state where possible.  However in a user interface, state needs to change (or your user interface never changes).</p> <p>Atoms provide a simple way for developers to manage mutable state, ensuring that only one part of a program can change the atom at any point in time.  So you do not need to manage concurrency and threads for an atom, making your code very simple.</p>"},{"location":"reagent-projects/tic-tac-toe/reagent-design-manage-app-state/#atoms-dont-make-their-contents-mutable","title":"Atoms dont make their contents mutable","text":"<p>Just because an Atom is mutable, doesnt mean the data inside the atom is mutable.  For example, if you put a vector of 3 numbers in an atom and then call a function to add a 4th number, the original vector is not changed, simply replaced by a new copy of that vector containing 4 numbers.</p> <p>So you are still working with immutable data, its just convieniently held in a mutable container so its easy to change.</p>"},{"location":"reagent-projects/tic-tac-toe/reagent-design-manage-app-state/#using-defonce-over-def","title":"Using defonce over def","text":"<p>We are using <code>defonce</code> rather than def to stop the value of the atom being reloaded every time we make a change to our code.</p> <p>Using <code>def</code> instead, then every time we saved our code our app-state would be reset back to the initial values.</p> <pre><code>(defonce app-state (atom {:text \"Hello world!\"}))\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/reagent-design-manage-app-state/#hint-manual-app-state-reset","title":"Hint:: Manual app-state reset","text":"<p>If you manually reload the page of your application in the browser then the <code>app-state</code> will be set back to its initial value.</p>"},{"location":"reagent-projects/tic-tac-toe/reagent-design-manage-app-state/#hint-atom-vs-reagent-atom","title":"Hint:: Atom Vs Reagent Atom","text":"<p>The Reagent library automatically watches Reagent atoms for changes and will automatically update any components using data in those atoms.</p> <p>The Clojure language has a built-in atom type which does a similar job to the Reagent Atom, however you need to write your own code to watch for changes to get the same results at Regent.</p>"},{"location":"reagent-projects/tic-tac-toe/reagent-design-reloading-state/","title":"Reagent Design: Reloading State","text":""},{"location":"reagent-projects/tic-tac-toe/reagent-design/","title":"Reagent Design","text":"<p>A quick summary of the key parts of Reagent that we will use in the TicTacToe project</p> <ul> <li>Defining Components</li> <li>Managing application state</li> <li>Reloading features (on-js-load)</li> </ul> <p>TODO: Add the above as sub-secttions</p>"},{"location":"reagent-projects/tic-tac-toe/refactor--cross-cell/","title":"Refactor: Cross Cell","text":"<p>A component to draw a cell containing a cross.</p> <p>As there is not a cross shape in SVG, we use two SVG <code>:line</code> to create an X shape.  Each line defines its start and end co-ordinates, <code>:x1 :y1 , :x2 :y2</code>.  To make this a single image we group the lines together with <code>:g</code></p> <p>As the shape is made up of two lines, then the colour is defined just with <code>:stroke</code>.  We set <code>:stroke-linecap</code> to <code>round</code> so the ends of each line has a nice round shape.</p> <p>Rather than use <code>cx</code> and <code>cy</code> options place the two lines in the center of the cell, we set a <code>:transform</code> to move the X shape into the center.</p> <pre><code>(defn cell-cross\n\"A cell with a cross inside it\"\n[x-cell y-cell]\n^{:key (str x-cell y-cell)}\n[:g {:stroke \"purple\"\n:stroke-width 0.4\n:stroke-linecap \"round\"\n:transform\n(str \"translate(\" (+ 0.42 x-cell) \",\" (+ 0.42 y-cell) \") \"\n\"scale(0.3)\")}\n[:line {:x1 -1 :y1 -1 :x2 1 :y2 1}]\n[:line {:x1 1 :y1 -1 :x2 -1 :y2 1}]])\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/refactor--empty-cell/","title":"Refactor: Empty Cell","text":"<pre><code>(defn cell-empty\n\"Generate a cell that has not yet been clicked on\"\n[x-cell y-cell]\n^{:key (str x-cell y-cell)}\n[:rect {:width 0.9\n:height 0.9\n:fill \"grey\"\n:x x-cell\n:y y-cell\n:on-click\n(fn rectangle-click [e]\n(println \"Cell\" x-cell y-cell \"was clicked!\")\n(println\n(swap! app-state assoc-in [:board y-cell x-cell] :cross)))}])\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/refactor--nought-cell/","title":"Refactor: Nought Cell","text":"<p>A component to draw a cell containing a nought.</p> <p>Using the SVG <code>:circle</code> we define a radius <code>:r</code> and decide what colour the circle should be <code>:fill</code>.</p> <p>The <code>:stroke</code> is the line around the edge of the graphic, so by making the <code>:fill</code> colour the same as the background colour and having a <code>:stroke</code> of green gives a O shape rather than a solid circle.</p> <p>The <code>cx</code> and <code>cy</code> options place the O shape in the center of the cell.</p> <pre><code>(defn cell-nought\n\"A cell with a nought inside it\"\n[x-cell y-cell]\n^{:key (str x-cell y-cell)}\n[:circle {:r 0.36\n:fill \"white\"\n:stroke \"green\"\n:stroke-width 0.1\n:cx (+ 0.42 x-cell)\n:cy (+ 0.42 y-cell)}])\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/refactor--nought-cell/#hint","title":"Hint::","text":"<p>No need for an <code>:on-click</code> event for the nought component, as once it has been chosen in a game it should not change.</p>"},{"location":"reagent-projects/tic-tac-toe/refactor-into-components/","title":"Refactor Into Components","text":"<p>Keep the <code>tictactoe-game</code> component fairly simple by creating functions to generate the graphics for different cells.</p> <pre><code>(defn tictactoe-game []\n[:div\n[:div\n[:h1 (:text @app-state)]\n[:p \"Do you want to play a game?\"]]\n[:center\n[:svg {:view-box \"0 0 3 3\"\n:width 500\n:height 500}\n(for [x-cell (range (count (:board @app-state)))\ny-cell (range (count (:board @app-state)))]\n(case (get-in @app-state [:board y-cell x-cell])\n:empty [cell-empty x-cell y-cell]\n:cross [cell-cross x-cell y-cell]\n:nought [cell-nought x-cell y-cell]))]]])\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/render-game-board/","title":"Render Game Board","text":"<p>Generate the board from the data structure in @app-state.</p> <p>Each cell of the board will be a coloured square (rectangle)</p> <pre><code>(defn tictactoe-game []\n[:div\n[:div\n[:h1 (:text @app-state)]\n[:p \"Do you want to play a game?\"]]\n[:center\n[:svg {:view-box \"0 0 3 3\"\n:width 500\n:height 500}\n(for [x-cell (range (count (:board @app-state)))\ny-cell (range (count (:board @app-state)))]\n^{:key (str x-cell y-cell)}\n[:rect {:width 0.9\n:height 0.9\n:fill \"green\"\n:x x-cell\n:y y-cell}])]]])\n</code></pre> <p>This is what the board should look like</p> <p></p>"},{"location":"reagent-projects/tic-tac-toe/repl-in-developer-console/","title":"REPL In Developer Console","text":""},{"location":"reagent-projects/tic-tac-toe/review-reagent-project/","title":"Review Reagent Project","text":"<p>Lets look at the major parts of the code we have been given when we created the project from the <code>figwheel</code> template.</p>"},{"location":"reagent-projects/tic-tac-toe/review-reagent-project/#project-configuration-dependencies-plugins","title":"Project Configuration - dependencies &amp; plugins","text":"<p>Clojure, ClojureScript and reagent are the important dependencies in this project.  The <code>core.async</code> library is often used to avoid using callbacks in react-style applications, but we do not use <code>core.async</code> in this example.</p> <pre><code>  :dependencies [[org.clojure/clojure \"1.9.0-alpha17\"]\n[org.clojure/clojurescript \"1.9.908\"]\n[org.clojure/core.async  \"0.3.443\"]\n[reagent \"0.7.0\"]]\n</code></pre> <p>The <code>lein-figwheel</code> plugin provides all the nice features of figwheel, especially live reloading of code changes into the browser.</p> <p>The <code>lein-cljsbuild</code> compiles the ClojureScript code into JavaScript.  There is an exclusion on this plugin to avoid pulling in a second dependency of Clojure (as we have explicitly defined it in the dependencies)</p> <pre><code>  :plugins [[lein-figwheel \"0.5.13\"]\n[lein-cljsbuild \"1.1.7\" :exclusions [[org.clojure/clojure]]]]\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/review-reagent-project/#web-page","title":"Web page","text":"<p>The web page is a very simple html page containing a <code>&lt;div&gt;</code> element with an id of <code>app</code>.  When we look at the react <code>render</code> in the ClojureScript code, we see that this id is used as a placeholder for our ClojureScript application.</p> <pre><code>  &lt;body&gt;\n&lt;div id=\"app\"&gt;\n&lt;h2&gt;Figwheel template&lt;/h2&gt;\n&lt;p&gt;Checkout your developer console.&lt;/p&gt;\n&lt;/div&gt;\n&lt;script src=\"js/compiled/tictactoe_reagent.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/review-reagent-project/#clojurescript-code","title":"ClojureScript code","text":"<p>Include the reagent implementation of atom into the namespace.</p> <p>The reagent atom is the same as the clojure atom in that it is a mutable container that manages state changes through software transactional memory.</p> <p>The reagent atom (sometimes referred to as ratom) allows reagent to watch changes in the application state and update reagent components are affected by the state change.</p> <pre><code>(ns tictactoe-reagent.core\n(:require [reagent.core :as reagent :refer [atom]]))\n</code></pre> <p>Enable printing out messages to the JavaScript console window from the ClojureScript code.</p> <p>Using <code>enable-console-print!</code> sets print-fn to console.log, which makes logging to a browser\u2019s console very simple.</p> <pre><code>(enable-console-print!)\n(println \"This text is printed from src/tictactoe-reagent/core.cljs. Go ahead and edit it and see reloading in action.\")\n</code></pre> <p>A common approach for react style applications is to define a name called <code>app-state</code> that uses an atom.</p> <p><code>defonce</code> is used over <code>def</code> so that the <code>app-state</code> is not reset each time you save a change in the ClojureScript file.</p> <pre><code>;; define your app data so that it doesn't get over-written on reload\n(defonce app-state (atom {:text \"Hello world!\"}))\n</code></pre> <p>The figwheel reagent project provides an example component called <code>hellow-world</code></p> <p>Components in reagent are simply Clojure functions.</p> <pre><code>(defn hello-world []\n[:div\n[:h1 (:text @app-state)]\n[:h3 \"Edit this and watch it change!\"]])\n</code></pre> <p>Components are displayed in your application using the reagent <code>render</code> function.</p> <p>The <code>render</code> function takes one or more components as an argument as well as a place on the page to render those components.</p> <pre><code>(reagent/render-component [hello-world]\n(. js/document (getElementById \"app\")))\n</code></pre> <p>The project also comes with a helper function that is called every time figwheel compiles a new saved change and pushes it to the JavaScript REPL.</p> <p>You can force an update each time you save a change to the ClojureScript source code.  For example, the commented out <code>swap</code> function would increment a counter in the <code>app-state</code></p> <pre><code>(defn on-js-reload []\n;; optionally touch your app-state to force rerendering depending on\n;; your application\n;; (swap! app-state update-in [:__figwheel_counter] inc)\n)\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/review-reagent-project/#hint-print-board-game-state-on-every-change","title":"Hint:: Print board game state on every change","text":"<p>The <code>on-js-reload</code> function can be used to print out the board game every time a change is made. <pre><code>(defn on-js-reload []\n(prn \"Game board state:\" (@app-state :board)))\n</code></pre></p>"},{"location":"reagent-projects/tic-tac-toe/start-the-repl/","title":"Tic-tac-toe: Start the REPL with Figwheel","text":"<p>Figwheel provides the connection between your ClojureScript code and the REPL in your browser.</p> <p>When you save changes to your code (ClojureScript, HTML or CSS) then figwheel will push those changes into the browser REPL and update the page in the browser.</p> <p>{% youtube %} https://www.youtube.com/watch?v=7QUz81C0hz0</p>"},{"location":"reagent-projects/tic-tac-toe/start-the-repl/#noterun-figwheel","title":"Note::Run Figwheel","text":"<p>In your terminal window, run figwheel from the project root directory: <pre><code>lein figwheel\n</code></pre></p> <p>Alternatively: start the repl in your Clojure editor, eg in Spacemacs its <code>clojurescript-jack-in</code></p>"},{"location":"reagent-projects/tic-tac-toe/start-the-repl/#what-just-happened","title":"What just happened ?","text":"<p>Dependencies for the project were checked and any missing libraries were downloaded (nothing missing in the video above).</p> <p>The ClojureScript code in the project is compiled.  Once compiled, a new browser window or tab will automatically open at http://localhost:3449/index.html</p> <p>When figwheel connects to the browser, a ClojureScript REPL prompt connected to the browser appears in the terminal window.</p> <p></p> <p>Figwheel is now running and will auto compile and send all changes to the browser without the need to manually reload the page in the browser.</p>"},{"location":"reagent-projects/tic-tac-toe/svg-overview/","title":"SVG Overview","text":"<p>You can draw SVG with different shapes, including rectangle <code>:rect</code>, circle.  To draw lines you can use <code>:path</code></p> <p>SVG objects are created using the same Hiccup style syntax as generating HTML, obviously with different tags.</p> <p>Style options are added within a map <code>{}</code>.</p> <pre><code>[:svg\n[:rect {:width 30\n:height 30\n:fill \"blue\"\n:stroke \"red\"\n:stroke-width 6}]]\n</code></pre> <p>A <code>:view-box</code> allows you to set your own unit of size within the SVG canvas</p> <pre><code>[:center\n[:svg {:view-box \"0 0 3 3\"\n:width 500\n:height 500}\n[:rect {:width 0.9\n:height 0.9\n:fill \"green\"}]]]\n</code></pre>"},{"location":"reagent-projects/tic-tac-toe/test-figwheel/","title":"Test Figwheel","text":"<p>An alert box should appear in the browser window that opened when figwheel was run.</p> <p></p> <p></p>"},{"location":"reagent-projects/tic-tac-toe/test-figwheel/#notetest-figwheel-via-the-repl","title":"Note::Test Figwheel via the REPL","text":"<p>Verify figwheel is working by entering the following code at the REPL prompt in the terminal window.</p> <p>This will be the same terminal window in which you ran <code>lein figwheel</code> <pre><code>(js/alert \"Am I connected to the browser repl with figwheel?\")\n</code></pre></p>"},{"location":"reagent-projects/tic-tac-toe/test-figwheel/#notetest-figwheel-from-source-code-changes","title":"Note::Test Figwheel from source code changes","text":"<p>Verify figwheel is working by editing the code in the file <code>src/tictactoe-reagent/core.cljs</code>.</p> <p>Find the <code>hello-world</code> function and change the last line to show a different message <pre><code>(defn hello-world []\n[:div\n[:h1 (:text @app-state)]\n[:h3 \"Changes in the code are loaded as soon as you save the file!\"]])\n</code></pre></p>"},{"location":"reagent-projects/tic-tac-toe/update-game-board/","title":"Update Game Board","text":"<p>When we click on a cell with the mouse we want to change that cell to be a nought or cross (depending on which side we are playing).</p> <p>To change a cell we add an <code>:on-click</code> event to each cell in the board game.  The <code>:on-click</code> event is an option on the <code>[rect ,,,]</code> that defines the cell.</p> <p>In this example we just change the <code>app-state</code> to <code>:clicked</code> and add some basic debugging so we can see the results in the developer console.</p> <pre><code> :on-click\n(fn rectangle-click [e]\n(println \"Cell\" x-cell y-cell \"was clicked!\")\n(println\n(swap! app-state assoc-in [:board y-cell x-cell] :clicked)))}])]]])\n</code></pre> <p>We could add a simple if condition to determine which colour to fill the cell</p> <pre><code>(defn tictactoe-game []\n[:div\n[:div\n[:h1 (:text @app-state)]\n[:p \"Do you want to play a game?\"]]\n[:center\n[:svg {:view-box \"0 0 3 3\"\n:width 500\n:height 500}\n(for [x-cell (range (count (:board @app-state)))\ny-cell (range (count (:board @app-state)))]\n^{:key (str x-cell y-cell)}\n[:rect {:width 0.9\n:height 0.9\n:fill (if (= :empty (get-in @app-state [:board y-cell x-cell]))\n\"green\"\n\"purple\")\n:x x-cell\n:y y-cell\n:on-click\n(fn rectangle-click [e]\n(println \"Cell\" x-cell y-cell \"was clicked!\")\n(println\n(swap! app-state assoc-in [:board y-cell x-cell] :clicked)))}])]]])\n</code></pre>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#content-deliver-network-services","title":"Content Deliver Network services","text":"<ul> <li>cdnjs</li> </ul>"},{"location":"related-libraries/","title":"Related Libraries","text":""},{"location":"testing/","title":"Testing","text":""},{"location":"web-design-basics/","title":"Websites with ClojureScript","text":"<p>ClojureScript is a great language for creating websites, using data structures to define document structure around content and styles.</p> <p>Websites with ClojureScript can use Cascading Style Sheet (CSS) frameworks such as Bootstrap and Bulma to enhance the look of a website and add responsive design.  So building websites that work across multiple display formats is straight forward.</p> <p>Single Page Apps can be created using reagent, a React.js style library that abstracts the complexities of react with the data centric approach of ClojureScript.</p>"},{"location":"web-design-basics/#web-development-and-design-basics","title":"Web development and design basics","text":"<p>Covering basic constructs and concepts in web page development and design using ClojureScript.</p>"},{"location":"web-design-basics/#example-projects","title":"Example projects","text":"<p>Several example projects are included to insprire your own creations.</p> <ul> <li>ClojureBridge London website - reagent and Bulma CSS library</li> <li>Tic Tac Toe game - reagent, Scalable Vector Graphics and Bulma CSS library</li> </ul>"},{"location":"web-design-basics/bootstrap-jumbotron/","title":"Bootstrap: Jumbotron","text":"<p>Jumbotron is a simple banner style header to the web page.</p> <p>Use this in your main component to help draw the page</p> <p>We wrap the jumbotron in a bootstrap container (see previous section)</p> <pre><code>(defn conference [app-state]\n[:div {:className \"container\"}\n[:div {:className \"jumbotron\"}\n[:h1 (:conference-name app-state)]\n[:h2 (:community app-state)]\n[:h3 (:slogan app-state)]]])\n</code></pre> <p></p>"},{"location":"web-design-basics/bootstrap-jumbotron/#jumbotron-styles","title":"Jumbotron styles","text":"<p>Inline or added to local styles.css</p>"},{"location":"web-design-basics/bootstrap/","title":"Bootstrap","text":""},{"location":"web-design-basics/bootstrap/#add-bootstrap-to-a-project","title":"Add bootstrap to a project","text":"<p>If you are using static html page to load in your application then you can add the Bootstrap and style-sheet includes directly to <code>resources/public/index.html</code></p> <pre><code>&lt;!-- Latest compiled and minified CSS --&gt;\n&lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\"&gt;\n&lt;!-- Optional theme --&gt;\n&lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css\" integrity=\"sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp\" crossorigin=\"anonymous\"&gt;\n&lt;!-- Latest compiled and minified JavaScript --&gt;\n&lt;script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\" integrity=\"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;\n&lt;link href=\"css/style.css\" rel=\"stylesheet\" type=\"text/css\"&gt;\n</code></pre>"},{"location":"web-design-basics/bootstrap/#todo-adding-bootstrap-when-generating-the-page","title":"TODO:: Adding bootstrap when generating the page","text":"<p>How to add bootstrap when generating the page from Clojure, rather than use a static page (as in one of the dojos at uswitch)</p>"},{"location":"web-design-basics/clojurebridge-london-bootstrap-website/","title":"Create a Clojurebridge London website","text":"<p>We have a very simple website for ClojureBridge London and we would like to know how to make it easier to use.</p> <p>We would also like to have a website create with Clojure or preferably ClojureScript, so we can host the website on GitHub pages.</p>"},{"location":"web-design-basics/clojurebridge-london-bootstrap-website/#infothis-section-is-new-so-feedback-is-appreciated","title":"Info::This section is new, so feedback is appreciated","text":""},{"location":"web-design-basics/clojurebridge-london-bootstrap-website/#hintan-example-clojurescript-website-using-bootstrap-css-library","title":"HINT::An example ClojureScript website using Bootstrap CSS library","text":"<p>Clojure Study Group project contains examples of code you can include to create your ClojureScript website</p>"},{"location":"web-design-basics/clojurebridge-london-bootstrap-website/#create-a-clojurescript-project","title":"Create a ClojureScript project","text":"<p>This will create a project with a working web page (usually described as a single page app).</p>"},{"location":"web-design-basics/clojurebridge-london-bootstrap-website/#note-create-a-clojurescript-website-for-clojurebridge-london","title":"Note:: Create a ClojureScript website for ClojureBridge London","text":"<p>Create a project using the figwheel template, adding reagent library.</p> <pre><code>lein new figwheel clojurebridge-website -- --reagent\n</code></pre>"},{"location":"web-design-basics/clojurebridge-london-bootstrap-website/#add-bootstrap-css-library","title":"Add Bootstrap CSS library","text":"<p>Bootstrap is a simple way to structure and make your website more appealing, using a wide range of CSS styles available.</p> <p>See the Clojure study group index.html file for an example</p> <p>The Bootstrap Introduction documentation includes examples of layouts and component styles you can include in your website.</p>"},{"location":"web-design-basics/clojurebridge-london-bootstrap-website/#noteadd-bootstrap-to-project-web-page","title":"Note::Add Bootstrap to project web page","text":"<p>Edit the <code>resources/public/index.html</code> file in your project Add the following line of code inside the <code>&lt;head&gt;</code> tag: <pre><code>    &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css\" integrity=\"sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS\" crossorigin=\"anonymous\"&gt;\n</code></pre></p>"},{"location":"web-design-basics/clojurebridge-london-bootstrap-website/#adding-sections-to-the-website","title":"Adding sections to the website","text":"<p>Create a function for each section of the website you want to add.</p>"},{"location":"web-design-basics/clojurebridge-london-bootstrap-website/#hintreagent-examples","title":"HINT::Reagent examples","text":"<p>Introduction to Reagent has many simple examples of functions you can include in the website</p> <p>Guide to Reagent has even more examples</p>"},{"location":"web-design-basics/clojurebridge-london-bootstrap-website/#create-a-banner-heading-using-bootstrap-jumbotron-style","title":"Create a banner heading using Bootstrap jumbotron style","text":"<pre><code>(defn website-title []\n[:div {:class \"jumbotron practicalli-jumbotron\"}\n[:h1 (get-in @app-state [:website :title])]\n[:h4 (get-in @app-state [:website :description])]])\n</code></pre>"},{"location":"web-design-basics/clojurebridge-london-bootstrap-website/#writing-html-in-clojure-with-hiccup","title":"Writing html in Clojure with hiccup","text":"<p>Rather than write <code>&lt;div&gt; &lt;/div&gt;</code>, <code>&lt;h1&gt; &lt;/h1&gt;</code>, <code>&lt;p&gt;  &lt;/p&gt;</code> pairs of tags in html, we define our content using a syntax called hiccup.</p> <p>A vector, <code>[]</code> is used to hold the name of the html tag, represented by a keyword such as <code>:div</code></p> <p>Defining our content in this way makes it easier to generate and transform using Clojure, so you can generate structure and content dynamically too.</p>"},{"location":"web-design-basics/clojurebridge-london-bootstrap-website/#references","title":"References","text":"<ul> <li>Reagent Mysteries - part 1: vectors and sequences</li> <li>SVG in reagent</li> </ul>"},{"location":"web-design-basics/clojurebridge-london-website/","title":"Simple ClojureScript websites","text":"<p>Create a relatively simple, responsive website that is deployed live on the Internet (or privately if preferred).</p> <p>Discover how to use the following tools:</p> <ul> <li>ClojureScript - writing functions for sections of content</li> <li>Reagent - add basic state management to the website</li> <li>Bulma - a CSS only framework for responsive design</li> <li>Figwheel-main - an interactive development environment for ClojureScript</li> <li>GitHub / GitLab Pages - free services for deploying websites on the Internet</li> </ul>"},{"location":"web-design-basics/clojurebridge-london-website/#example-clojurescript-websites","title":"Example ClojureScript websites","text":"<ul> <li>ClojureBridge London, a landing page for the event using Bulma CSS, global navigation and responsive design.</li> <li>ClojureBridge London source code</li> <li>Practicalli, a landing page using Bulma CSS (similar to the above)</li> <li>Clojure Study Group project a ClojureScript and bootstrap website</li> </ul>"},{"location":"web-design-basics/clojurebridge-london-website/#looking-for-something-more","title":"Looking for something more?","text":"<p>pesterhazy/cljs-spa-example is a more involved example of a Single Page Application in ClojureScript.  This project uses figwheel-main, reagent, webpack, router5, yarn package management for npms,</p>"},{"location":"web-design-basics/clojurebridge-london-website/#references","title":"References","text":"<ul> <li>Reagent Mysteries - part 1: vectors and sequences</li> <li>SVG in reagent</li> </ul>"},{"location":"web-design-basics/clojurebridge-london-website/add-bluma-css/","title":"Add Bulma CSS library","text":"<p>Bulma is a CSS only framework (no JavaScript) that provides a range of easy to apply styles using meaningful style names.  Its quite lightweight and therefore fast to load along with your website.</p> <p>Bulma also recommends using FontAwesome library, to add common logos such at GitHub.</p>"},{"location":"web-design-basics/clojurebridge-london-website/add-bluma-css/#add-bulma-css-and-fontawesome-icons-to-project-web-page","title":"Add Bulma CSS and FontAwesome icons to project web page","text":"<p>Edit the <code>resources/public/index.html</code> file in your project</p> <p>Add the following line of code inside the <code>&lt;head&gt;</code> tag:</p> <pre><code>&lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css\"&gt;\n&lt;script defer src=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css\"&gt;&lt;/script&gt;\n</code></pre> <p>See the Practicalli Landing page index.html file for an example</p>"},{"location":"web-design-basics/clojurebridge-london-website/add-bluma-css/#bulma-via-clojure-hiccup-code","title":"Bulma via Clojure Hiccup code","text":"<p>When using Clojure Hiccup code to generate the HTML page that loads the application (or any other HTML pages), Bulma CSS and FontAwesome can also be included using  the hiccup style syntax.</p> <pre><code>[:link {:rel \"stylesheet\"\n:href \"https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css\"}]\n[:script {:defer true\n:src \"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css\"}]\n</code></pre>"},{"location":"web-design-basics/clojurebridge-london-website/add-content-namespace/","title":"Refactor content to its own namespace","text":"<p>Create a new namespace called <code>clojurebridge-landing-page.content</code> in the file <code>src/clojurebridge_landing_page/content.cljs</code></p> <p>Move all function definitions, except <code>landing-page</code> from the content section to the new file for the namespace.</p>"},{"location":"web-design-basics/clojurebridge-london-website/add-content-namespace/#require-the-content-namespace","title":"Require the <code>content</code> namespace","text":"<p>Edit the the file <code>src/clojurebridge_landing_page/core.cljs</code>.</p> <p>Update the <code>clojurebridge-landing-page.core</code> namespace to require the new <code>clojurebridge-landing-page.content</code> namespace</p> <p>The <code>content</code> namespace should be given the alias <code>content</code></p> <pre><code>(ns ^:figwheel-hooks clojurebridge-london-landing-page.core\n(:require\n[goog.dom :as gdom]\n[reagent.core :as reagent :refer [atom]]\n[clojurebridge-landing-page.content :as content]))\n</code></pre>"},{"location":"web-design-basics/clojurebridge-london-website/add-content-namespace/#add-the-alias-to-the-function-calls","title":"Add the alias to the function calls","text":"<p>The landing page represents the order in which content sections are organised.</p> <p><code>level-separator</code> provides a named separation between each component.  The name is used by the navigation bar on the web page to jump to a specific content section on the page.</p> <p>Using the name on the separator ensures the top of the content section is not displayed under the navigation bar</p> <pre><code>(defn landing-page []\n[:div\n[content/navigation-top]\n[content/banner-columns]\n[content/sponsor-current (get-in @app-state [:sponsors :current])]\n(content/level-separator \"overview\")\n[content/overview]\n(content/level-separator \"showcase\")\n[content/showcase]\n(content/level-separator \"learning-paths\")\n[content/learning-paths]\n(content/level-separator \"install\")\n[content/install]\n(content/level-separator \"schedule\")\n[content/schedule]\n(content/level-separator \"resources\")\n[content/resources]\n(content/level-separator \"coaches\")\n[content/coaches]\n(content/level-separator \"sponsors\")\n[content/sponsors]\n])\n</code></pre> <p>The landing page should continue to work as before.  If not, ensure all files are saved and check if figwheel is showing errors on the bottom of the landing page.</p>"},{"location":"web-design-basics/clojurebridge-london-website/add-navigation/","title":"Add Navigation bar","text":"<p>To jump to specific content, we will add a navigation bar at the top of the page.</p> <p>The navigation will be fixed in place, so it will not move as the page is scrolled.</p> <p>The navigation will be responsive, so when the website is viewed on smaller screens, the navigation will show as a drop-down button (referred to as a burger as that is the rough shape of the icon typically used).</p>"},{"location":"web-design-basics/clojurebridge-london-website/add-navigation/#navigation-section","title":"Navigation section","text":"<p>Create a function to define the navigation, using the <code>navbar</code> class from Bulma.</p> <pre><code>(defn navigation-top\n\"A responsive navigation that is fixed to the top of the page\"\n[]\n[:nav {:class      \"navbar is-fixed-top is-dark\"\n:role       \"navigation\"\n:aria-label \"main navigation\"}\n[:div {:class \"container\"}\n[:div {:class \"navbar-brand\"}\n[:a {:class \"navbar-item\"\n:href  \"/\"}\n[:img {:src \"images/clojurebridge-logo.png\"}]]\n[:span {:class       \"navbar-burger burger\"\n:data-target \"navbarClojureBridge\"}\n;; Empty spans needed for navbar burger\n[:span][:span][:span]]]\n[:div {:id    \"navbarClojureBridge\"\n:class \"navbar-menu\"}\n[:div {:class \"navbar-start\"}\n[:a {:class \"navbar-item\"\n:href  \"#overview\"} \"Overview\"]\n[:a {:class \"navbar-item\"\n:href  \"#showcase\"} \"Showcase\"]\n[:a {:class \"navbar-item\"\n:href  \"#learning-paths\"} \"Learning Paths\"]\n[:a {:class \"navbar-item\"\n:href  \"#schedule\"} \"Schedule\"]\n[:a {:class \"navbar-item\"\n:href  \"#install\"} \"Install\"]\n[:a {:class \"navbar-item\"\n:href  \"#resources\"} \"Resources\"]\n[:a {:class \"navbar-item\"\n:href  \"#resources\"} \"Coaches\"]\n[:a {:class \"navbar-item\"\n:href  \"#sponsors\"} \"Sponsors\"]\n[:span {:class \"navbar-item\"}\n[:a {:class  \"button is-inverted\"\n:target \"_blank\"\n:href   \"https://github.com/ClojureBridgeLondon/landing-page-draft\"}\n[:span {:class \"icon\"}\n[:i {:class \"fab fa-github\"}]]\n[:span \"Issues/PRs\"]]]]]]]\n)\n</code></pre>"},{"location":"web-design-basics/clojurebridge-london-website/add-navigation/#fixing-spacing-under-navbar","title":"Fixing spacing under navbar","text":"<p>To prevent hiding content under the navigation bar, we add the <code>has-navbar-fixed-top</code> class to the body of the <code>index.html</code> file</p> <pre><code>  &lt;body class=\"has-navbar-fixed-top\"&gt;\n</code></pre>"},{"location":"web-design-basics/clojurebridge-london-website/add-navigation/#script-to-populate-the-drop-down-menu","title":"Script to populate the drop-down menu","text":"<p>As Bulma does not have any JavaScript functionality, we need to add a script to dynamically populate the navigation bar drop-down menu when on smaller devices.</p> <pre><code>    &lt;!-- Script for Bulma hamburger menu --&gt;\n&lt;!-- https://www.adam-bray.com/2018/04/03/responsive-bulma-css-navigation-bar/ --&gt;\n&lt;script&gt;\n(function() {\nvar burger = document.querySelector('.burger');\nvar nav = document.querySelector('#'+burger.dataset.target);\nburger.addEventListener('click', function(){\nburger.classList.toggle('is-active');\nnav.classList.toggle('is-active');\n});\n})();\n&lt;/script&gt;\n</code></pre>"},{"location":"web-design-basics/clojurebridge-london-website/add-navigation/#todo","title":"TODO::","text":"<p>The script is the approach that Bulma suggests.  However, it should be possible to write ClojureScript to do this work.  This JavaScript would then be removed.</p> <p>One approach is to make the navigation data part of the application state, then it can be easily used and updated.  Using the application state helps make the webpage layout more dynamic, as changes to the application state will cause parts of the website to be re-drawn (re-rendered).</p>"},{"location":"web-design-basics/clojurebridge-london-website/add-welcome-message/","title":"Add welcome message to the website","text":"<p>Update the <code>landing-page</code> function to contain content.</p> <p>Use the hiccup style to define the structure of the content</p> <p>Add style class names to the hiccup code to use CSS styles from Bulma.  Feel free to experiment on what you want to add here.</p>"},{"location":"web-design-basics/clojurebridge-london-website/add-welcome-message/#simple-example","title":"Simple Example","text":"<pre><code>;; ------------------------------------------\n;; Content components\n(defn landing-page []\n[:section {:class \"section\"}\n[:h1\n{:class \"title\"}\n\"Welcome to ClojureBridge\"]\n;; Content will just use HTML tags directly, useful when you have no specific styles\n;; https://bulma.io/documentation/elements/content/\n[:div {:class \"content\"}\n[:p\n\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras sed enim ante. Nullam consectetur, sapien in rutrum facilisis, augue velit finibus est, at lobortis odio eros sollicitudin risus. Nullam mollis, metus a varius volutpat, metus elit mollis est, finibus pretium dui enim non velit. Praesent sit amet volutpat nulla. Sed volutpat venenatis nisi id sagittis. Nunc nec efficitur mi. Duis consequat sapien ultricies quam bibendum, elementum faucibus sapien bibendum. Morbi diam elit, gravida iaculis metus vitae, ullamcorper mattis mi. Maecenas luctus lorem metus. Maecenas eleifend nisl sit amet felis accumsan, sit amet tincidunt turpis consequat. Cras non molestie ante, a pellentesque dui.\"]\n[:p\n\"Vivamus ullamcorper at orci ac tincidunt. Vivamus tincidunt sed erat nec consequat. Donec venenatis lorem justo, eget imperdiet arcu ultrices vitae. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Donec congue tempor posuere. Sed nec nisl mauris. Maecenas elementum quam justo, vitae auctor felis dapibus a. Phasellus leo justo, mattis a auctor tempus, facilisis vel tellus. Etiam at scelerisque justo, ac facilisis purus. Duis in leo pretium purus bibendum ultricies ac vitae lectus. Proin nec mi nec urna sollicitudin iaculis. In a orci felis. Sed luctus posuere luctus. Cras id euismod orci, id mollis nibh. Vestibulum et tellus quis lorem placerat scelerisque non et nisl. Ut dictum lacus nulla, sit amet ultricies eros pharetra vitae. \"]\n]])\n</code></pre>"},{"location":"web-design-basics/clojurebridge-london-website/add-welcome-message/#hintlorem-ipsum-generators","title":"Hint::Lorem ipsum generators","text":"<p>When you want to thing about the layout of a page without considering the wording of the content, you can use a Lorem ipsum generator to create text that most people will not just sit and read.</p>"},{"location":"web-design-basics/clojurebridge-london-website/add-welcome-section/","title":"Refactor welcome to a specific component","text":"<p>Rename the <code>landing-page</code> function to <code>welcome-message</code>.</p> <p>Below the <code>welcome-message</code> function, create a new <code>landing-page</code> function definition as follows</p> <pre><code>(defn landing-page []\n[welcome-message])\n</code></pre> <p>The <code>welcome-message</code> function needs to be defined above the <code>landing-page</code> function, as it <code>welcome-message</code> is call this new <code>landing-page</code> function.</p>"},{"location":"web-design-basics/clojurebridge-london-website/app-state-section/","title":"App State driven section","text":"<p>The sponsor section of the website will change the sponsor details each time we have a new event.  Rather than hard code the sponsor details, we can add them to the application state.  Then each time we have a new event, all we need to do is update that state with new sponsor details.</p> <p>Update the map to contain a <code>:sponsors</code> key whose value is a map.</p> <p>That map containes <code>:current</code> and <code>:past</code> sponsors (past sponsors will be a map that has the number of the event and the sponsor details copied from the :current map).</p> <pre><code>(defonce\napp-state\n(atom\n{:text \"Hello world!\"\n:sponsors\n{:current\n{:name    \"Functional Works\"\n:logo    \"images/functional-works-logo.svg\"\n:website \"https://functional.works-hub.com/\"\n:message \"Breaking down the barriers to hiring the right software engineers,\n            providing a platform to managing the whole process (written in ClojureScript).\"}\n:past    {:9 {,,,}}}}))\n</code></pre> <p>Here is an example of a current sponsor component.</p> <pre><code>(defn sponsor-current\n\"Sponsors for our current event, to help that sponsor get some exposure\n  Argument: hash-map of strings - :name, :website, :logo, :message\"\n[sponsor-details]\n[:div {:class \"container\"}\n[:div {:class \"box\"}\n[:div {:class \"column is-half is-8 is-offset-2\"}\n[:a {:href (get sponsor-details :website)}\n[:h3 {:class \"title is-5 has-text-centered\"} (str \"Our Sponsors:\" \" \" (get sponsor-details :name))]]\n[:div {:class \"columns\"}\n[:div {:class \"column\"}\n[:figure {:class \"image\"}\n[:a {:href (get sponsor-details :website)}\n[:img {:src \"images/functional-works-logo.png\"}]]]]\n[:div {:class \"column\"}\n[:div {:class \"content\"}\n[:p (get sponsor-details :message)]]]]]]])\n</code></pre>"},{"location":"web-design-basics/clojurebridge-london-website/create-project/","title":"Create a ClojureScript project","text":"<p>Create a new ClojureScript project for the development of a website for ClojureBridge London</p> <p>Use the figwheel-main template with the reagent library to create the the foundation of the project code.</p> <p>{% tabs deps=\"deps.edn projects\", lein=\"Leiningnen projects\" %}</p> <p>{% content \"deps\" %}</p> <p>Clojure CLI tools and clj-new, for example using the <code>:project/new</code> alias from practicalli/clojure-deps-edn user-level aliases for community tools. <pre><code>clj -M:project/new figwheel-main clojurebridge/landing-page -- --reagent\n</code></pre></p> <p>{% content \"lein\" %}</p> <p>Using Leiningen</p> <pre><code>lein new figwheel-main clojurebridge/landing-page -- --reagent\n</code></pre> <p>{% endtabs %}</p> <p>A working project is created and when run will show a very basic web page</p>"},{"location":"web-design-basics/clojurebridge-london-website/create-project/#hintfigwheel-main-template","title":"Hint::figwheel-main template","text":"<p>figwheel-main-template project provides a simple way to create a minimal ClojureScript project, optionally using reagent, rum, or react to create a react-style single page app (SPA)</p>"},{"location":"web-design-basics/clojurebridge-london-website/deploy-build/","title":"Creating a Deploy build configuration","text":"<p>Create a build configuration for deployment, to remove the need to copy the <code>.js</code> file to the deploy location.</p> <p>These instructions assume the <code>/docs</code> directory is used by GitHub pages for deploying the website.</p>"},{"location":"web-design-basics/clojurebridge-london-website/deploy-build/#create-a-deploy-build-configuration-file","title":"Create a deploy build configuration file","text":"<p>Copy the <code>dev.cljs.edn</code> to <code>deploy.cljs.edn</code>.</p> <p>Edit <code>deploy.cljs.edn</code> and add the <code>ouptput-to:</code> configuration option</p> <pre><code>^{:watch-dirs   [\"test\" \"src\"]\n:css-dirs     [\"resources/public/css\"]\n:auto-testing true}\n{:main clojurebridge-landing-page.core\n:output-to \"docs/cljs-out/dev-main.js\"}\n</code></pre>"},{"location":"web-design-basics/clojurebridge-london-website/deploy-build/#hintadjust-file-and-path-if-required","title":"Hint::Adjust file and path if required","text":"<p>This configuration assumes GitHub pages has been configured to use the <code>/docs</code> directory in the master branch to serve the website.</p>"},{"location":"web-design-basics/clojurebridge-london-website/deploy-build/#create-a-new-alias","title":"Create a new alias","text":"<p>Edit the <code>project.clj</code> file.</p> <p>Add a new <code>:aliases</code> line, the same as the <code>fig:min</code> line, except using <code>deploy</code> at the end.</p> <pre><code>  :aliases {\"fig\"        [\"trampoline\" \"run\" \"-m\" \"figwheel.main\"]\n\"fig:build\"  [\"trampoline\" \"run\" \"-m\" \"figwheel.main\" \"-b\" \"dev\" \"-r\"]\n\"fig:min\"    [\"run\" \"-m\" \"figwheel.main\" \"-O\" \"advanced\" \"-bo\" \"dev\"]\n\"fig:deploy\" [\"run\" \"-m\" \"figwheel.main\" \"-O\" \"advanced\" \"-bo\" \"deploy\"]\n\"fig:test\"   [\"run\" \"-m\" \"figwheel.main\" \"-co\" \"test.cljs.edn\" \"-m\" juxt-edge.test-runner]}\n</code></pre>"},{"location":"web-design-basics/clojurebridge-london-website/deploy-build/#deploying-updates","title":"Deploying updates","text":"<p><code>lein fig:deploy</code> will now deploy any changes to your ClojureScript app without the need to copy any files.</p> <p>In a terminal window open in the root of your project, run the commands:</p> <pre><code>lein clean\nlein fig:deploy\n</code></pre> <p>Then commit the new file and push to GitHub</p> <pre><code>git commit -a \"Deploy version 4.2\"\ngit push origin master\n</code></pre> <p>If you make any changes to the index.html or css/styles.css files, then still need to copy them into <code>/docs</code> directory manually, then commit those changes too.</p>"},{"location":"web-design-basics/clojurebridge-london-website/further-ideas/","title":"Further content ideas","text":"<p>The site could be developed further as an exercise by the reader. Suggested ideas for new content sections include</p> <ul> <li>Registration (sign up button, date, location, etc.)</li> <li>Current sponsor (details of the current sponsor, sponsor messaging)</li> <li>ClojureBridge overview (description of the event)</li> <li>Clojure Showcase (some projects that demonstrate what Clojure can do)</li> <li>Learning paths (links to the various curriculums)</li> <li>Clojure Installation (how to set up a development environment)</li> <li>ClojureBridge Schedule (what happens and when)</li> <li>Resources (documentation, how to practice clojure, books, videos, etc)</li> <li>Coaching guide (documentation to help coaches coach the students)</li> <li>Sponsors guide (how to sponsor ClojureBridge and what to get out of it)</li> <li>Past events (overview of all previous events, date, location, sponsors, etc.)</li> <li>Models of learning (ideas on how to learn more effectively)</li> </ul> <p>Create a function for each content section that will be developed and add call that function from the <code>landing-page</code> function.</p>"},{"location":"web-design-basics/clojurebridge-london-website/further-ideas/#hintreagent-examples","title":"HINT::Reagent examples","text":"<p>Introduction to Reagent has many simple examples of functions you can include in the website</p> <p>Guide to Reagent has even more examples</p>"},{"location":"web-design-basics/clojurebridge-london-website/further-ideas/#create-a-banner-heading-using-bootstrap-hero-style","title":"Create a banner heading using Bootstrap hero style","text":"<p>CSS frameworks have a <code>hero</code> or <code>jumbotron</code> class for creating a large banner area on a page, highlighting the main concept or theme of the website.</p> <pre><code>(defn website-title []\n[:section {:class \"hero\"}\n[:h1 (get-in @app-state [:website :title])]\n[:h4 (get-in @app-state [:website :description])]])\n</code></pre>"},{"location":"web-design-basics/clojurebridge-london-website/github-pages-deploy/","title":"Deploy to GitHub pages","text":"<p>GitHub pages is a free service for serving up content in static files, its ideal for websites that do not require their own database or other services (or simply plugs into purely online services and API's).</p> <p>Create a repository on GitHub for this ClojureScript project</p> <p>Add that repository as a remote repository to the local Git repository for this project</p> <pre><code>git remote add origin &lt;repository URI from GitHub&gt;\n</code></pre>"},{"location":"web-design-basics/clojurebridge-london-website/github-pages-deploy/#project-specific-landing-pages","title":"Project specific landing pages","text":"<p>There are two approaches when adding a website to a specific project.</p> <ul> <li>add files to a <code>gh-pages</code> branch (classic approach)</li> <li>add files to <code>/docs</code> directory on the master branch (new approach)</li> </ul> <p>We will use the new approach and deploy our files in <code>/docs</code></p>"},{"location":"web-design-basics/clojurebridge-london-website/github-pages-deploy/#alternative-organisation-user-landing-pages","title":"Alternative: Organisation / user Landing pages","text":"<p>For Organisations on GitHub, like ClojureBridgeLondon and Pracitalli, I use two separate Git repositories</p> <ul> <li>ClojureScript repository - created by Leiningen / figwheel template</li> <li>Deployment repository - only contains specific files for deployment</li> </ul>"},{"location":"web-design-basics/clojurebridge-london-website/github-pages-deploy/#creating-the-files-for-deployment","title":"Creating the files for deployment","text":"<p>During development the build of the ClojureScript application is contained in multiple files, as this makes it easy to do fast updates of just the specific parts of the application.</p> <p>When we deploy, we generate a single JavaScript file that contains our application.  We also minify the application to make it quick to load into the browser.</p>"},{"location":"web-design-basics/clojurebridge-london-website/github-pages-deploy/#note","title":"Note::","text":"<p>In the root of your ClojureScript project (where project.clj file is) run the commands: <pre><code>lein clean\nlein fig:min\n</code></pre></p>"},{"location":"web-design-basics/clojurebridge-london-website/github-pages-deploy/#add-directory-to-github","title":"Add directory to GitHub","text":"<p>Create the <code>/docs</code> and <code>/docs/cljs-out</code> directories in the project first.</p> <p>Add a <code>README.md</code> file with a message describing the purpose of the /docs directory.</p> <p>Commit the <code>README.md</code> file and push to your GitHub repository</p>"},{"location":"web-design-basics/clojurebridge-london-website/github-pages-deploy/#set-github-pages-location","title":"Set GitHub pages location","text":"<p>Visit the GitHub repository website and update the Settings to point to `/docs as the source of GitHub pages</p> <p>Setting &gt; GitHub Pages &gt; Source</p> <p>master branch /docs folder</p> <p></p>"},{"location":"web-design-basics/clojurebridge-london-website/github-pages-deploy/#copy-the-files","title":"Copy the files","text":"<p>Copy the following files into the <code>/docs</code> directory.</p> <pre><code>cp resources/public/index.html docs\n\ncp -r resources/public/css docs\n\ncp -r resources/public/images images\n\ncp resources/public/cljs-out/dev-main.js docs/cljs-out/\n</code></pre>"},{"location":"web-design-basics/clojurebridge-london-website/github-pages-deploy/#commit-and-push-the-files","title":"Commit and push the files","text":"<p>Commit all the changes in the <code>/docs</code> directory.</p> <p>Push the commit to GitHub <code>git push origin master</code></p> <p>Visit your live website at https://.github.io/clojurebridge-landing-page/"},{"location":"web-design-basics/clojurebridge-london-website/github-pages-deploy/#deploying-updates","title":"Deploying updates","text":"<p>Any changes to your ClojureScript app that you want to deploy, then you only need to build the single javascrpt file again</p> <pre><code>lein clean\nlein fig:min\n</code></pre> <p>Then copy the new javascript file to the <code>docs/cljs-out</code> directory</p> <pre><code>cp resources/public/cljs-out/dev-main.js docs/cljs-out/\n</code></pre> <p>Commit the new file and push to GitHub <pre><code>git commit -a \"New version\"\ngit push origin master\n</code></pre></p> <p>If you make any changes to the index.html or css/styles.css files, then you will need to copy them into <code>/docs</code> directory and commit those changes too</p>"},{"location":"web-design-basics/clojurebridge-london-website/hiccup-for-html/","title":"Writing html in Clojure with hiccup","text":"<p>Rather than write <code>&lt;div&gt; &lt;/div&gt;</code>, <code>&lt;h1&gt; &lt;/h1&gt;</code>, <code>&lt;p&gt;  &lt;/p&gt;</code> pairs of tags in html, we define our content using a syntax called hiccup.</p> <p>A vector, <code>[]</code> is used to hold the name of the html tag, represented by a keyword such as <code>:div</code></p> <p>Defining our content in this way makes it easier to generate and transform using Clojure, so you can generate structure and content dynamically too.</p> <p>For example this simple html code uses open and closing tags to define the scope of where to apply that tag.</p> <pre><code>&lt;div&gt;\n&lt;h1&gt;Hello World&lt;/h1&gt;\n&lt;h3&gt;Live reloading in the repl makes web development fun!&lt;/h3&gt;\n&lt;/div&gt;\n</code></pre> <p>In Clojure, we only have the one tag, which is represented by a keyword that has the same name as the HTML tag.  The vector defines the scope of the tag.</p> <p>Using vectors for scope its trivial to use structured editing to organise and refactor the structure of your web page content.</p> <pre><code>(defn hello-world []\n[:div\n[:h1 (:text @app-state)]\n[:h3 \"Live reloading in the repl makes web development fun!\"]])\n</code></pre>"},{"location":"web-design-basics/clojurebridge-london-website/hiccup-for-html/#using-state-for-dynamic-content","title":"Using state for dynamic content","text":"<p>We can also use dynamic information from the application state, defined as an atom called <code>app-state</code>.  As this name refers to an atom, we need to use the <code>@</code> character or the <code>deref</code> function to access its values</p> <p>In this example, the atom contains a Clojure map with a key called <code>text</code>.  We can get the value associated with <code>text</code> in the map by de-referencing the atom. <pre><code>[:h1 (get @app-state :text)]\n</code></pre></p> <p>Its quite common to use the short form when the key of a map is the keyword type <pre><code>[:h1 (:text @app-state)]\n</code></pre></p>"},{"location":"web-design-basics/clojurebridge-london-website/live-reloading/","title":"Live reloading","text":"<p>figwheel-main provides live reloading of our application in the browser.  When we save a change to the code (ClojureScript or CSS), that change is automatically pushed to the browser and the web page is updates.</p> <p>A ClojureScript logo will appear briefly in the corner of the web page to indicate an update is being pushed to the JavaScript engine in the browser.</p>"},{"location":"web-design-basics/clojurebridge-london-website/live-reloading/#edit-the-code-to-see-live-reloading","title":"Edit the code to see live reloading","text":"<p>Edit the file <code>landing-page/src/clojurebridge/landing_page.cljs</code></p> <p>Change the heading 3 contents in the <code>hello-world</code> function</p> <pre><code>(defn hello-world []\n[:div\n[:h1 (:text @app-state)]\n[:h3 \"Live reloading in the repl makes web development fun!\"]])\n</code></pre> <p>The web page should have automatically updated</p> <p></p>"},{"location":"web-design-basics/clojurebridge-london-website/organising-the-code/","title":"Re-organising the code a little","text":"<p>Create comments to make it easier to identify the specific parts of the code</p>"},{"location":"web-design-basics/clojurebridge-london-website/organising-the-code/#hintgood-structure-helps-refactor-later","title":"Hint::Good structure helps refactor later","text":"<p>Having an organised structure to your code helps you maintain the code and help you refactor code into multiple namespaces.</p>"},{"location":"web-design-basics/clojurebridge-london-website/organising-the-code/#rename-main-component-to-landing-page","title":"Rename main component to landing-page","text":"<p>To make our code clearer, rename <code>hello-world</code> function to <code>landing-page</code></p> <pre><code>(defn landing-page []\n[:div\n[:h1 (:text @app-state)]\n[:h3 \"Live reloading in the REPL makes web development fun!\"]])\n</code></pre> <p>And update the <code>mount</code> function to use this new function name as the main component</p> <pre><code>(defn mount [el]\n(reagent/render-component [landing-page] el))\n</code></pre>"},{"location":"web-design-basics/clojurebridge-london-website/organising-the-code/#create-a-system-section","title":"Create a system section","text":"<p>Move the <code>get-app-element</code> to the other mount / reagent functions and call that section System</p> <pre><code>;; ------------------------------------------\n;; System\n(defn get-app-element []\n(gdom/getElement \"app\"))\n(defn mount [el]\n(reagent/render-component [landing-page] el))\n</code></pre>"},{"location":"web-design-basics/clojurebridge-london-website/organising-the-code/#add-a-datetime-stamped-reload-message","title":"Add a date/time stamped reload message","text":"<p>As a quick sanity check, add a date / time stamp to the println message at the top of the file, so you can see the time figwheel reloads the page in the REPL output.</p> <pre><code>;; ------------------------------------------\n;; simple debug statement for each build\n(println (js/Date.) \"Reloading: src/clojurebridge_landing_page/core.cljs\")\n</code></pre>"},{"location":"web-design-basics/clojurebridge-london-website/organising-the-code/#final-result","title":"Final result","text":"<p>After all the changes the file should look as follows</p> <pre><code>(ns ^:figwheel-hooks clojurebridge-landing-page.core\n(:require\n[goog.dom :as gdom]\n[reagent.core :as reagent :refer [atom]]))\n;; ------------------------------------------\n;; simple debug statement for each build\n(println (js/Date.) \"Reloading: src/clojurebridge_landing_page/core.cljs\")\n;; ------------------------------------------\n;; Application state\n;; define your app data so that it doesn't get over-written on reload\n(defonce app-state (atom {:text \"Hello world!\"}))\n;; ------------------------------------------\n;; Helper functions\n(defn multiply [a b] (* a b))\n;; ------------------------------------------\n;; Content components\n(defn landing-page []\n[:div\n[:h1 (:text @app-state)]\n[:h3 \"Live reloading in the REPL makes web development fun!\"]])\n;; ------------------------------------------\n;; System\n(defn get-app-element []\n(gdom/getElement \"app\"))\n(defn mount [el]\n(reagent/render-component [landing-page] el))\n(defn mount-app-element []\n(when-let [el (get-app-element)]\n(mount el)))\n;; conditionally start your application based on the presence of an \"app\" element\n;; this is particularly helpful for testing this ns without launching the app\n(mount-app-element)\n;; specify reload hook with ^;after-load metadata\n(defn ^:after-load on-reload []\n(mount-app-element)\n;; optionally touch your app-state to force rerendering depending on\n;; your application\n;; (swap! app-state update-in [:__figwheel_counter] inc)\n)\n</code></pre>"},{"location":"web-design-basics/clojurebridge-london-website/repl-workflow/","title":"REPL Workflow","text":"<p>Calling <code>(mount-app-element)</code> will update the application with any evaluated changes, regardless of whether the file has been saved.</p> <p>When saving a file, Figwheel will update the running application in the browser with any code changes.</p> <p>Updating the state updates the running application in the browser.</p>"},{"location":"web-design-basics/clojurebridge-london-website/repl-workflow/#reloading-code","title":"Reloading code","text":"<p>Make a change to the code, e.g. updating a function definition to display a different string for a sub-heading</p> <pre><code>(defn hello-world []\n[:div\n[:h1 (:text @app-state)]\n[:h3 \"Evaluate code in the REPL can update your ClojureScript application in the browser\"]])\n</code></pre> <p>Update the application in the browser by evaluating the call to <code>(mount-app-element)</code></p>"},{"location":"web-design-basics/clojurebridge-london-website/repl-workflow/#testing-different-states","title":"Testing different states","text":"<p>Changes to the application state, held in the <code>app-state</code> atom, trigger reagent to update any components (functions) that are using that data and redrawing that component in the live running application</p> <p>Changing the value provides a convenient way to test the application in different states and see the results immediately.</p> <p>A rich comment block can be used to hold different states that are useful to set in the application, using either a <code>swap!</code> or <code>reset!</code> expression.</p> <pre><code>(comment\n(reset! app-state {:text \"Welcome to the Figwheel REPL experience\"})\n) ;; End of rich comment block\n</code></pre>"},{"location":"web-design-basics/clojurebridge-london-website/repl-workflow/#testing-without-the-app-element","title":"Testing without the app element","text":"<p><code>(mount-app-element)</code> will conditionally start the application based on the presence of an \"app\" element in the index.html page.</p> <p>When the \"app\" element is not there then the namespace can be tested without launching the application in the browser.</p>"},{"location":"web-design-basics/clojurebridge-london-website/repl-workflow/#figwheel-main-template-reload-code","title":"Figwheel-main template reload code","text":"<p>When the <code>--reagent</code> option is used with the figwheel-main template then several function definitions are included to help with reloading the application</p> <p><code>get-app-element</code> finds the \"app\" element in the <code>resources/public/index.html</code> page using the Google doom library</p> <pre><code>(defn get-app-element []\n(gdom/getElement \"app\"))\n</code></pre> <p><code>mount</code> passes the component to render to the reagent <code>render</code>function along with the element in the web page that defines where to inject the application.</p> <p>The component is the function definition  that represents the entry point to the application.</p> <pre><code>(defn mount [el]\n(rdom/render [hello-world] el))\n</code></pre> <p><code>mount-app-element</code> uses the above two functions to start the application within the web page.</p> <pre><code>(defn mount-app-element []\n(when-let [el (get-app-element)]\n(mount el)))\n</code></pre> <p><code>(mount-app-element)</code> is called when the namespace is loaded to start the application within the web page.</p> <p><code>on-reload</code> is called every time Figwheel process reloads the application and can be used to add behaviour and state changes that should happen each time.  The commented example adds a counter so that the total number of times the application is reloaded is captured.</p> <pre><code>;; conditionally start your application based on the presence of an \"app\" element\n;; this is particularly helpful for testing this ns without launching the app\n(mount-app-element)\n;; - P9I: Reloads the app-element too, updating any evaluated definitions in the REPL\n;; specify reload hook with ^;after-load metadata\n(defn ^:after-load on-reload []\n(mount-app-element)\n;; optionally touch your app-state to force rerendering depending on\n;; your application\n;; (swap! app-state update-in [:__figwheel_counter] inc)\n)\n</code></pre>"},{"location":"web-design-basics/clojurebridge-london-website/responsive-design/","title":"responsive-design","text":""},{"location":"web-design-basics/clojurebridge-london-website/responsive-design/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":"<p>Discuss ideas behind Bulma</p>"},{"location":"web-design-basics/clojurebridge-london-website/run-the-project/","title":"Run the project","text":"<p>On the command line, change into the directory <code>landing-page</code> and run the command to start building the project</p> <p>{% tabs deps=\"Clojure CLI\", lein=\"Leiningnen\", spacemacs=\"Spacemacs\"  %}</p> <p>{% content \"deps\" %}</p> <pre><code>clojure -M:fig:build\n</code></pre> <p>{% content \"lein\" %}</p> <pre><code>lein fig:build\n</code></pre> <p>{% content \"spacemacs\" %}</p>"},{"location":"web-design-basics/clojurebridge-london-website/run-the-project/#spacemacs-and-cider-jack-in","title":"Spacemacs and Cider Jack-in","text":"<p><code>SPC f f</code> to open the file <code>landing-page/src/clojurebridge/landing_page.cljs</code></p> <p><code>, m s</code> (<code>sesman-start</code>) and select the command <code>cider-jack-in-cljs</code></p> <p>When prompted for the REPL type, select <code>figwheel-main</code></p> <p></p> <p>When prompted for the build, type <code>dev</code></p> <p></p> <p>{% endtabs %}</p> <p>After a few moments, the default web browser will automatically open at [http://localhost:9500/] and show the running ClojureScript application.</p> <p></p>"},{"location":"web-design-basics/clojurebridge-london-website/interacting/","title":"Interacting with the website","text":"<p>So far our website has been pretty static.  We can change the page by saving new function definitions or by updating data in the application state.</p> <p>What about user interaction?</p> <p>In this section we will learn how to interact with the website and understand how reagent manages updates for us.</p> <p>Ideas we could do</p> <ul> <li> <p>a daily like / love / interested button  - each time the button is pressed it increases the number of likes (eg. a fancy counter).  Without persisting the number of likes in a data store, the number of likes would be reset each time the application is deployed.</p> </li> <li> <p>minimise a section, minimise all sections but that which you click on</p> </li> </ul>"},{"location":"web-design-basics/clojurebridge-london-website/interacting/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":""},{"location":"why-clojurescript/","title":"Why ClojureScript","text":"<p>Clojurescript is a well designed, general purpose programming language that generates highly optimised Javascript output.</p> <p>The Clojurescript syntax is small and simple to learn, although becoming used to thinking functionally will take a little more effort.  Functional programming will make your applications simpler to understand and therefore easier to maintain and extend.</p> <p>Clojurescript also provides an easy way to use Javascript and its vast array of libraries.  You can call Javascript functions using the same syntax as Clojurescript.</p> <p>Application design is simple and yet powerfull, with a focus on managing data with immutable data structures (list, vector, map &amp; set).</p> <p></p>"},{"location":"why-clojurescript/#leaning-clojurescript-is-valuable","title":"Leaning Clojurescript is valuable","text":"<p>So in this section we will cover the aspects that make learning ClojureScript valuable.</p> <ul> <li>Community</li> <li>Google Closure</li> <li>Build Tools</li> <li>Source Maps</li> <li>CLJSJS</li> <li>cljx &amp; cljc</li> <li>Transit</li> <li>Using Bootstrap</li> <li>Devcards</li> <li>Functional Reactive Apps</li> </ul> <p>Hint Many ideas and imagery were used from the Clojure Conj talk: Clojure for Skeptics by Derek Slager on Youtube.com.</p>"},{"location":"why-clojurescript/google-clojure/","title":"Google Closure","text":"<p>The Closure Library is a broad, well-tested, modular, and cross-browser JavaScript library. You can pull just what you need from a large set of reusable UI widgets and controls, and from lower-level utilities for DOM manipulation, server communication, animation, data structures, unit testing, rich-text editing, and more.</p> <p>The Closure Library is server-agnostic, and is intended for use with the Closure Compiler. Who uses Closure Library?</p> <p>The Closure Library serves as the base JavaScript library for many Google products, including:</p> <p></p> <p>Now that the Closure Library is open source, more and more developers outside Google are integrating the library in their own projects. What can the Closure Library do for me?</p> <p>If you are developing a large or growing application, you may benefit from the Closure Library's breadth. A well-tested library can insulate you from cross-browser compatibility issues and the minutiae of client-side programming, letting you focus on the fun stuff. </p> <p>Find out more at:</p> <ul> <li>Google Clojure Library</li> <li>Google Clojure tooling</li> </ul>"},{"location":"why-clojurescript/interoperability/","title":"Interoperability","text":"<p>Using Javascript functions and libraries is very easy from Clojurescript, its also really easy to make your Clojurescript accessible from Javascript too.</p> <p></p>"},{"location":"why-clojurescript/interoperability/#importing-javascript","title":"Importing Javascript","text":"<p>The CLJ JS website provides a huge range of Javascript libraries that can simply be added as a dependency to your Clojurescript code.  It acts as package management tool for Javascript libraries and makes those packages available via a web-based library.</p> <p>Since ClojureScript 0.0-2727 the <code>:foreign-libs</code> option provides an excellent way to integrate Javascript into ClojureScript applications. CLJSJS provides Javascript libraries and their appropriate extern files packaged up with deps.cljs. CLJSJS aims to concentrate packaging efforts to make everyone\u2019s life a little easier.</p> <p></p>"},{"location":"why-clojurescript/lightweight/","title":"Lightweight","text":"<p>Clojurescript is very lightweight, just like Clojure itself.  Clojurescript is much more lightweight when you compare it to other libraries</p> <p></p> <p>jQuery is bigger than Clojurescript and if you add persistent data structures via immutable.js then the Javascript app is nearly twice as big.</p>"},{"location":"why-clojurescript/lightweight/#size-matters","title":"Size matters","text":"<p>The size of your client-side and mobile web apps really matters.  Even 5G networks will not really fix the problem for mobile web apps.</p> <p></p> <p>Its ironic that the article that talks about how broken the mobile web is provides a perfect example of why it is broken.  When looking at the contents of this page there is 7Mb of Javascript to download.</p> <p>Its a common pattern to just ship the whole libraries</p>"},{"location":"why-clojurescript/lightweight/#optimised-clojurescript-eliminating-dead-code","title":"Optimised Clojurescript - eliminating dead code","text":"<p>By changing the Clojurescript <code>project.clj</code> configuration file to include <code>optimisation</code> set to true, the compiler (Google Closure compiler) with eliminate any code that is not used.  Typically reducing the size of the Javascript files generated by a huge factor.</p> <p></p> <p>See the section on Google Clojure library and tools to know more.</p>"},{"location":"why-clojurescript/lightweight/#modularised-code","title":"Modularised code","text":"<p>As you build bigger apps and especially single page apps, then you need to break up your Javascript into different sections to that you only need to load what you are using.  By using modules in Clojurescript you can easily optimise your code for deployment</p> <p></p>"},{"location":"why-clojurescript/react-native/","title":"React Native","text":"<p>React Native enables you to build world-class application experiences on native platforms using a consistent developer experience based on JavaScript and React. The focus of React Native is on developer efficiency across all the platforms you care about \u2014 learn once, write anywhere. Facebook uses React Native in multiple production apps and will continue investing in React Native.</p>"},{"location":"why-clojurescript/source-maps/","title":"HTML Source Maps","text":"<p>When you have a highly interactive development environment set up with Clojure &amp; Figwheel, the last thing you want to do is to try and pick through the JavaScript code and figure out which bit of Clojurescript is causing the problem.  With Source Maps you dont have to.</p> <p>Source Maps allows you to see your Clojurescript code in the browser and see where your code is failing.</p> <p></p> <p>You can set breakpoints in your Clojurescript code and they will appear in the source maps view in your browser.  You will also notice that the code is syntax highlighted, as browsers like Google Chrome support syntax highlighting directly (possibly through CodeMirror)</p>"},{"location":"why-clojurescript/source-maps/#how-source-maps-work","title":"How source maps work","text":"<p>ClojureScript now supports HTML source maps so that you can debug ClojureScript directly in the browser, using the configuration option :source-map.</p> <p><code>:source-map</code> can be either a boolean, or if optimizations are enabled, a path to a file for the map.</p> <p>If you are building using leiningen, the Clojurescript build section in <code>project.clj</code> would look like:</p> <pre><code> :cljsbuild {\n:builds [{:id \"main\"\n:source-paths [\"src\"]\n:compiler {\n:output-to \"main.js\"\n:output-dir \"out\"\n:optimizations :none\n:source-map true}}]})\n</code></pre> <p>After compilation, when you open an HTML file linking to the generated js file in your browser ensure that source maps are enabled via the Developer Tools settings.</p> <p>For more details, see the Clojure.org page on Source Maps</p>"},{"location":"why-clojurescript/who-uses-clojurescript/","title":"Who uses ClojureScript","text":"<p>There are a growing number of companies using Clojure already and a similarly growing list of companies using Clojurescript</p> <ul> <li>Funding Circle</li> <li>Circle CI</li> </ul>"},{"location":"why-clojurescript/who-uses-clojurescript/#circle-ci","title":"Circle CI","text":"<p>Circle CI is a hosted continuous integration service and they have used ClojureScript for their front end web app (and many other apps).</p> <p></p> <p>You can see examples of their Clojurescript front end code on Github, which uses the Om reactive framework.</p>"},{"location":"why-clojurescript/why-not-javascript/","title":"Why not JavaScript","text":"<p>JavaScript is continue to evolve and there are many great things to come with ECMAscript 6 and beyond.  However, there is also a lot of legacy syntax to contend with, making the language less clean to develop with.</p> <p></p>"},{"location":"why-clojurescript/why-not-javascript/#javascript-the-good-parts","title":"JavaScript - the good parts","text":"<p>I am sure we have all seen the comparison between the JavaScript book and JavaScript - the good parts book.  But if not, here it is:</p> <p></p>"},{"location":"why-clojurescript/why-not-javascript/#lots-to-remember","title":"Lots to remember","text":"<p>JavaScript can have a lot of syntax to remember, take for instance Operator precedence.  Here is a table that shows the orders</p> <p></p> <p>In ClojureScript there is not table as we have no operators, they are just functions</p>"}]}